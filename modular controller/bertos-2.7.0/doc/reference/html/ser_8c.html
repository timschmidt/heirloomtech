

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_f7c89dbd63e8f34e572fe939945c15d7.html">drv</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ser.c File Reference</div>  </div>
</div>
<div class="contents">

<p>Buffered serial I/O driver.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ser_8h_source.html">ser.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="wdt_8h_source.html">wdt.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="timer_8h_source.html">timer.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ser__p_8h_source.html">ser_p.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cfg__ser_8h_source.html">cfg/cfg_ser.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cfg__proc_8h_source.html">cfg/cfg_proc.h</a>&quot;</code><br/>
<code>#include &lt;<a class="el" href="debug_8h_source.html">cfg/debug.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="formatwr_8h_source.html">mware/formatwr.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="power_8h_source.html">cpu/power.h</a>&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
</div>
<p><a href="ser_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a52d0e331b57c0a314281e54841e11ee3">ser_putchar</a> (int c, struct <a class="el" href="structSerial.html">Serial</a> *port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>c</em> in tx FIFO buffer.  <a href="#a52d0e331b57c0a314281e54841e11ee3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a32f422d8c4ff671a949a95e7f101d131">ser_getchar</a> (struct <a class="el" href="structSerial.html">Serial</a> *port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a character from the rx FIFO buffer.  <a href="#a32f422d8c4ff671a949a95e7f101d131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a0b14117674c7eb7e846258fd7639c474">ser_getchar_nowait</a> (struct <a class="el" href="structSerial.html">Serial</a> *fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a character from the rx FIFO buffer.  <a href="#a0b14117674c7eb7e846258fd7639c474"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a484978acb82401b9b05d1290bf7a1b96">ser_read</a> (struct <a class="el" href="structKFile.html">KFile</a> *fd, void *_buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read at most <em>size</em> bytes from <em>port</em> and put them in <em>buf</em>.  <a href="#a484978acb82401b9b05d1290bf7a1b96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#ad8d90597ca4fa918d755f68f4863630d">ser_write</a> (struct <a class="el" href="structKFile.html">KFile</a> *fd, const void *_buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a buffer to serial.  <a href="#ad8d90597ca4fa918d755f68f4863630d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f9fc76f87264fb606d3a479454facb"></a><!-- doxytag: member="ser.c::ser_setbaudrate" ref="a11f9fc76f87264fb606d3a479454facb" args="(struct Serial *fd, unsigned long rate)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a11f9fc76f87264fb606d3a479454facb">ser_setbaudrate</a> (struct <a class="el" href="structSerial.html">Serial</a> *fd, unsigned long rate)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the baudrate for the serial port. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0d6ef44282fb53998309af1b9aca675"></a><!-- doxytag: member="ser.c::ser_setparity" ref="ac0d6ef44282fb53998309af1b9aca675" args="(struct Serial *fd, int parity)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#ac0d6ef44282fb53998309af1b9aca675">ser_setparity</a> (struct <a class="el" href="structSerial.html">Serial</a> *fd, int parity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parity for the <em>fd</em> serial port. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a232d7e97772224c88a20185f7be2efea"></a><!-- doxytag: member="ser.c::ser_purge" ref="a232d7e97772224c88a20185f7be2efea" args="(struct Serial *fd)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a232d7e97772224c88a20185f7be2efea">ser_purge</a> (struct <a class="el" href="structSerial.html">Serial</a> *fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush both the RX and TX buffers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ef3b3e9d3ea4334ef716d5f28b8b98e"></a><!-- doxytag: member="ser.c::ser_purgeRx" ref="a0ef3b3e9d3ea4334ef716d5f28b8b98e" args="(struct Serial *fd)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a0ef3b3e9d3ea4334ef716d5f28b8b98e">ser_purgeRx</a> (struct <a class="el" href="structSerial.html">Serial</a> *fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush RX buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af22e072e28cfdf79135e04b7a7dbd2d0"></a><!-- doxytag: member="ser.c::ser_purgeTx" ref="af22e072e28cfdf79135e04b7a7dbd2d0" args="(struct Serial *fd)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#af22e072e28cfdf79135e04b7a7dbd2d0">ser_purgeTx</a> (struct <a class="el" href="structSerial.html">Serial</a> *fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush TX buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#ac1d5a213137c2e5dcb7947472ce9c2f2">ser_flush</a> (struct <a class="el" href="structKFile.html">KFile</a> *fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all pending output is completely transmitted to the other end.  <a href="#ac1d5a213137c2e5dcb7947472ce9c2f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structSerial.html">Serial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#ac4f83de5a8d44e892e7fe9991d83d277">ser_open</a> (struct <a class="el" href="structSerial.html">Serial</a> *fd, unsigned int unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a serial port.  <a href="#ac4f83de5a8d44e892e7fe9991d83d277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb3db5cb3ce22960d2f0baece32d8e45"></a><!-- doxytag: member="ser.c::ser_close" ref="aeb3db5cb3ce22960d2f0baece32d8e45" args="(struct KFile *fd)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#aeb3db5cb3ce22960d2f0baece32d8e45">ser_close</a> (struct <a class="el" href="structKFile.html">KFile</a> *fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up serial port, disabling the associated hardware. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed731e52886841f3ef5cc0b86fa1c533"></a><!-- doxytag: member="ser.c::ser_reopen" ref="aed731e52886841f3ef5cc0b86fa1c533" args="(struct KFile *fd)" -->
static struct <a class="el" href="structKFile.html">KFile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#aed731e52886841f3ef5cc0b86fa1c533">ser_reopen</a> (struct <a class="el" href="structKFile.html">KFile</a> *fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopen serial port. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a088372086f192b2a8cfc8b12f80a1fb7">ser_init</a> (struct <a class="el" href="structSerial.html">Serial</a> *fds, unsigned int unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init serial driver for <em>unit</em>.  <a href="#a088372086f192b2a8cfc8b12f80a1fb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#a4c8fa1f837109faf70636f10bebe5b32">spimaster_read</a> (struct <a class="el" href="structKFile.html">KFile</a> *fd, void *_buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from SPI bus.  <a href="#a4c8fa1f837109faf70636f10bebe5b32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc296a538012e77f0e10388c8f1d29ac"></a><!-- doxytag: member="ser.c::spimaster_write" ref="adc296a538012e77f0e10388c8f1d29ac" args="(struct KFile *fd, const void *buf, size_t size)" -->
static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#adc296a538012e77f0e10388c8f1d29ac">spimaster_write</a> (struct <a class="el" href="structKFile.html">KFile</a> *fd, const void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to SPI bus. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ser_8c.html#af4bfb3489fcd1c04e4041741e2f72e95">spimaster_init</a> (<a class="el" href="structSerial.html">Serial</a> *fds, unsigned int unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init SPI serial driver <em>unit</em> in master mode.  <a href="#af4bfb3489fcd1c04e4041741e2f72e95"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Buffered serial I/O driver. </p>
<p>The serial rx interrupt buffers incoming data in a software FIFO to decouple the higher level protocols from the line speed. Outgoing data is buffered as well for better performance. This driver is not optimized for best performance, but it has proved to be fast enough to handle transfer rates up to 38400bps on a 16MHz 80196.</p>
<p>MODULE CONFIGURATION</p>
<ul>
<li><code>CONFIG_SER_HWHANDSHAKE</code> - set to 1 to enable RTS/CTS handshake. Support is incomplete/untested. </li>
<li><code>CONFIG_SER_TXTIMEOUT</code> - Enable software serial transmission timeouts</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac1d5a213137c2e5dcb7947472ce9c2f2"></a><!-- doxytag: member="ser.c::ser_flush" ref="ac1d5a213137c2e5dcb7947472ce9c2f2" args="(struct KFile *fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ser_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKFile.html">KFile</a> *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait until all pending output is completely transmitted to the other end. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The current implementation only checks the software transmission queue. Any hardware FIFOs are ignored. </dd></dl>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00323">323</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="a32f422d8c4ff671a949a95e7f101d131"></a><!-- doxytag: member="ser.c::ser_getchar" ref="a32f422d8c4ff671a949a95e7f101d131" args="(struct Serial *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ser_getchar </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structSerial.html">Serial</a> *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a character from the rx FIFO buffer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will switch out the calling process if the rx buffer is empty. If the buffer is empty and <em>port-&gt;rxtimeout</em> is 0 return EOF immediatly.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EOF on error or timeout, <em>c</em> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00140">140</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0b14117674c7eb7e846258fd7639c474"></a><!-- doxytag: member="ser.c::ser_getchar_nowait" ref="a0b14117674c7eb7e846258fd7639c474" args="(struct Serial *fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ser_getchar_nowait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structSerial.html">Serial</a> *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a character from the rx FIFO buffer. </p>
<p>If the buffer is empty, <a class="el" href="ser_8c.html#a0b14117674c7eb7e846258fd7639c474" title="Fetch a character from the rx FIFO buffer.">ser_getchar_nowait()</a> returns EOF immediatly. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Deprecated, use ser_getchar with rx_timeout set to 0. </dd></dl>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00183">183</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="a088372086f192b2a8cfc8b12f80a1fb7"></a><!-- doxytag: member="ser.c::ser_init" ref="a088372086f192b2a8cfc8b12f80a1fb7" args="(struct Serial *fds, unsigned int unit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ser_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structSerial.html">Serial</a> *&#160;</td>
          <td class="paramname"><em>fds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Init serial driver for <em>unit</em>. </p>
<p>Use values SER_UARTn as values for <em>unit</em>. </p>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00421">421</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac4f83de5a8d44e892e7fe9991d83d277"></a><!-- doxytag: member="ser.c::ser_open" ref="ac4f83de5a8d44e892e7fe9991d83d277" args="(struct Serial *fd, unsigned int unit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structSerial.html">Serial</a>* ser_open </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structSerial.html">Serial</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a serial port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td><a class="el" href="structKFile.html" title="Context data for callback functions which operate on pseudo files.">KFile</a> <a class="el" href="structSerial.html" title="Serial handle structure.">Serial</a> struct interface. </td></tr>
    <tr><td class="paramname">unit</td><td><a class="el" href="structSerial.html" title="Serial handle structure.">Serial</a> unit to open. Possible values are architecture dependant. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00344">344</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="a52d0e331b57c0a314281e54841e11ee3"></a><!-- doxytag: member="ser.c::ser_putchar" ref="a52d0e331b57c0a314281e54841e11ee3" args="(int c, struct Serial *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ser_putchar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structSerial.html">Serial</a> *&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert <em>c</em> in tx FIFO buffer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will switch out the calling process if the tx buffer is full. If the buffer is full and <em>port-&gt;txtimeout</em> is 0 return EOF immediatly.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EOF on error or timeout, <em>c</em> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00094">94</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="a484978acb82401b9b05d1290bf7a1b96"></a><!-- doxytag: member="ser.c::ser_read" ref="a484978acb82401b9b05d1290bf7a1b96" args="(struct KFile *fd, void *_buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t ser_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKFile.html">KFile</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read at most <em>size</em> bytes from <em>port</em> and put them in <em>buf</em>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes actually read. </dd></dl>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00199">199</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d90597ca4fa918d755f68f4863630d"></a><!-- doxytag: member="ser.c::ser_write" ref="ad8d90597ca4fa918d755f68f4863630d" args="(struct KFile *fd, const void *_buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t ser_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKFile.html">KFile</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a buffer to serial. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if OK, EOF in case of error.</dd></dl>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00224">224</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="af4bfb3489fcd1c04e4041741e2f72e95"></a><!-- doxytag: member="ser.c::spimaster_init" ref="af4bfb3489fcd1c04e4041741e2f72e95" args="(Serial *fds, unsigned int unit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spimaster_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSerial.html">Serial</a> *&#160;</td>
          <td class="paramname"><em>fds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Init SPI serial driver <em>unit</em> in master mode. </p>
<p>Use SER_SPIn for <em>unit</em> parameter.</p>
<p>This interface implements the SPI master protocol over a serial SPI driver. This is needed because normal serial driver send/receive data at the same time. SPI slaves like memories and other peripherals first receive and *then* send response back instead. To achieve this, when we are master and we are *sending*, we have to discard all incoming data. Then, when we want to receive, we must write fake data to SPI to trigger slave devices. </p>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00496">496</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4c8fa1f837109faf70636f10bebe5b32"></a><!-- doxytag: member="ser.c::spimaster_read" ref="a4c8fa1f837109faf70636f10bebe5b32" args="(struct KFile *fd, void *_buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t spimaster_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKFile.html">KFile</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from SPI bus. </p>
<p>Since we are master, we have to trigger slave by sending fake chars on the bus. </p>

<p>Definition at line <a class="el" href="ser_8c_source.html#l00442">442</a> of file <a class="el" href="ser_8c_source.html">ser.c</a>.</p>

</div>
</div>
</div>


