

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FIFO buffer</div>  </div>
<div class="ingroups"><a class="el" href="group__struct.html">Embedded optimized general purpose data types</a></div></div>
<div class="contents">

<p>General pourpose FIFO buffer implemented with a ring buffer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga0e994927c90f3db3a6df6877e948b77a">fifo_isempty</a> (const FIFOBuffer *fb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the fifo is empty.  <a href="#ga0e994927c90f3db3a6df6877e948b77a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga5dc5785260c19521eb0988068cfbc2ae">fifo_isfull</a> (const FIFOBuffer *fb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the fifo is full.  <a href="#ga5dc5785260c19521eb0988068cfbc2ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322">fifo_push</a> (FIFOBuffer *fb, unsigned char c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a character on the fifo buffer.  <a href="#gaa90a12236437f4c2c3205cd1f991a322"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga10b23a805dd320d7767e99087fa7df84">fifo_pop</a> (FIFOBuffer *fb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a character from the fifo buffer.  <a href="#ga10b23a805dd320d7767e99087fa7df84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1fe72631d7832d6eb42cfdf839f9e66b"></a><!-- doxytag: member="fifobuf::fifo_flush" ref="ga1fe72631d7832d6eb42cfdf839f9e66b" args="(FIFOBuffer *fb)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga1fe72631d7832d6eb42cfdf839f9e66b">fifo_flush</a> (FIFOBuffer *fb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the fifo empty, discarding all its current contents. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga954b94f30fe737840802ae0a88cc821a">fifo_isempty_locked</a> (const FIFOBuffer *fb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__fifobuf.html#ga0e994927c90f3db3a6df6877e948b77a" title="Check whether the fifo is empty.">fifo_isempty()</a>, but with stronger guarantees for concurrent access between user and interrupt code.  <a href="#ga954b94f30fe737840802ae0a88cc821a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga94060d3f5fbe5f5369486c61219b8c9b">fifo_push_locked</a> (FIFOBuffer *fb, unsigned char c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a>, but with stronger guarantees for concurrent access between user and interrupt code.  <a href="#ga94060d3f5fbe5f5369486c61219b8c9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga6d8e32b4bebce414254f65c342de9a10">fifo_flush_locked</a> (FIFOBuffer *fb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__fifobuf.html#ga1fe72631d7832d6eb42cfdf839f9e66b" title="Make the fifo empty, discarding all its current contents.">fifo_flush()</a>, but with stronger guarantees for concurrent access between user and interrupt code.  <a href="#ga6d8e32b4bebce414254f65c342de9a10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0bbd65192fb8c6f05f04505822ac81a2"></a><!-- doxytag: member="fifobuf::fifo_isfull_locked" ref="ga0bbd65192fb8c6f05f04505822ac81a2" args="(const FIFOBuffer *_fb)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga0bbd65192fb8c6f05f04505822ac81a2">fifo_isfull_locked</a> (const FIFOBuffer *_fb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread safe version of <a class="el" href="group__fifobuf.html#ga5dc5785260c19521eb0988068cfbc2ae" title="Check whether the fifo is full.">fifo_isfull()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8927528749a150700e4115289117bf8e"></a><!-- doxytag: member="fifobuf::fifo_init" ref="ga8927528749a150700e4115289117bf8e" args="(FIFOBuffer *fb, unsigned char *buf, size_t size)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#ga8927528749a150700e4115289117bf8e">fifo_init</a> (FIFOBuffer *fb, unsigned char *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">FIFO Initialization. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifobuf.html#gaabcf5735a34a1316715619dd5927e0b0">fifo_len</a> (FIFOBuffer *fb)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>General pourpose FIFO buffer implemented with a ring buffer. </p>
<ul>
<li><code>begin</code> points to the first buffer element; </li>
<li><code>end</code> points to the last buffer element (unlike the STL convention); </li>
<li><code>head</code> points to the element to be extracted next; </li>
<li><code>tail</code> points to the location following the last insertion; </li>
<li>when any of the pointers advances beyond <code>end</code>, it is reset back to <code>begin</code>.</li>
</ul>
<div class="fragment"><pre class="fragment">  +-----------------------------------+
  |  empty  |   valid data   |  empty |
  +-----------------------------------+
  ^         ^                ^        ^
  begin    head             tail     end
</pre></div><p>The buffer is EMPTY when <code>head</code> and <code>tail</code> point to the same location: </p>
<div class="fragment"><pre class="fragment"> head == tail 
</pre></div><p>The buffer is FULL when <code>tail</code> points to the location immediately after <code>head:</code> </p>
<div class="fragment"><pre class="fragment"> tail == head - 1 
</pre></div><p>The buffer is also FULL when <code>tail</code> points to the last buffer location and head points to the first one: </p>
<div class="fragment"><pre class="fragment"> head == begin &amp;&amp; tail == end 
</pre></div><dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6d8e32b4bebce414254f65c342de9a10"></a><!-- doxytag: member="fifobuf.h::fifo_flush_locked" ref="ga6d8e32b4bebce414254f65c342de9a10" args="(FIFOBuffer *fb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fifo_flush_locked </td>
          <td>(</td>
          <td class="paramtype">FIFOBuffer *&#160;</td>
          <td class="paramname"><em>fb</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="group__fifobuf.html#ga1fe72631d7832d6eb42cfdf839f9e66b" title="Make the fifo empty, discarding all its current contents.">fifo_flush()</a>, but with stronger guarantees for concurrent access between user and interrupt code. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is actually only needed for 8-bit processors.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fifobuf.html#ga1fe72631d7832d6eb42cfdf839f9e66b" title="Make the fifo empty, discarding all its current contents.">fifo_flush()</a> </dd></dl>

<p>Definition at line <a class="el" href="fifobuf_8h_source.html#l00264">264</a> of file <a class="el" href="fifobuf_8h_source.html">fifobuf.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e994927c90f3db3a6df6877e948b77a"></a><!-- doxytag: member="fifobuf.h::fifo_isempty" ref="ga0e994927c90f3db3a6df6877e948b77a" args="(const FIFOBuffer *fb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fifo_isempty </td>
          <td>(</td>
          <td class="paramtype">const FIFOBuffer *&#160;</td>
          <td class="paramname"><em>fb</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the fifo is empty. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Calling <a class="el" href="group__fifobuf.html#ga0e994927c90f3db3a6df6877e948b77a" title="Check whether the fifo is empty.">fifo_isempty()</a> is safe while a concurrent execution context is calling <a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a> or <a class="el" href="group__fifobuf.html#ga10b23a805dd320d7767e99087fa7df84" title="Pop a character from the fifo buffer.">fifo_pop()</a> only if the CPU can atomically update a pointer (which the AVR and other 8-bit processors can't do).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fifobuf.html#ga954b94f30fe737840802ae0a88cc821a" title="Similar to fifo_isempty(), but with stronger guarantees for concurrent access between user and interr...">fifo_isempty_locked</a> </dd></dl>

<p>Definition at line <a class="el" href="fifobuf_8h_source.html#l00105">105</a> of file <a class="el" href="fifobuf_8h_source.html">fifobuf.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga954b94f30fe737840802ae0a88cc821a"></a><!-- doxytag: member="fifobuf.h::fifo_isempty_locked" ref="ga954b94f30fe737840802ae0a88cc821a" args="(const FIFOBuffer *fb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fifo_isempty_locked </td>
          <td>(</td>
          <td class="paramtype">const FIFOBuffer *&#160;</td>
          <td class="paramname"><em>fb</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="group__fifobuf.html#ga0e994927c90f3db3a6df6877e948b77a" title="Check whether the fifo is empty.">fifo_isempty()</a>, but with stronger guarantees for concurrent access between user and interrupt code. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is actually only needed for 8-bit processors.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fifobuf.html#ga0e994927c90f3db3a6df6877e948b77a" title="Check whether the fifo is empty.">fifo_isempty()</a> </dd></dl>

<p>Definition at line <a class="el" href="fifobuf_8h_source.html#l00227">227</a> of file <a class="el" href="fifobuf_8h_source.html">fifobuf.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5dc5785260c19521eb0988068cfbc2ae"></a><!-- doxytag: member="fifobuf.h::fifo_isfull" ref="ga5dc5785260c19521eb0988068cfbc2ae" args="(const FIFOBuffer *fb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fifo_isfull </td>
          <td>(</td>
          <td class="paramtype">const FIFOBuffer *&#160;</td>
          <td class="paramname"><em>fb</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the fifo is full. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Calling <a class="el" href="group__fifobuf.html#ga5dc5785260c19521eb0988068cfbc2ae" title="Check whether the fifo is full.">fifo_isfull()</a> is safe while a concurrent execution context is calling <a class="el" href="group__fifobuf.html#ga10b23a805dd320d7767e99087fa7df84" title="Pop a character from the fifo buffer.">fifo_pop()</a> and the CPU can update a pointer atomically. It is NOT safe when the other context calls <a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a>. This limitation is not usually problematic in a consumer/producer scenario because the <a class="el" href="group__fifobuf.html#ga5dc5785260c19521eb0988068cfbc2ae" title="Check whether the fifo is full.">fifo_isfull()</a> and <a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a> are usually called in the producer context. </dd></dl>

<p>Definition at line <a class="el" href="fifobuf_8h_source.html#l00125">125</a> of file <a class="el" href="fifobuf_8h_source.html">fifobuf.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaabcf5735a34a1316715619dd5927e0b0"></a><!-- doxytag: member="fifobuf.h::fifo_len" ref="gaabcf5735a34a1316715619dd5927e0b0" args="(FIFOBuffer *fb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fifo_len </td>
          <td>(</td>
          <td class="paramtype">FIFOBuffer *&#160;</td>
          <td class="paramname"><em>fb</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Lenght of the FIFOBuffer <em>fb</em>. </dd></dl>

<p>Definition at line <a class="el" href="fifobuf_8h_source.html#l00298">298</a> of file <a class="el" href="fifobuf_8h_source.html">fifobuf.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga10b23a805dd320d7767e99087fa7df84"></a><!-- doxytag: member="fifobuf.h::fifo_pop" ref="ga10b23a805dd320d7767e99087fa7df84" args="(FIFOBuffer *fb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char fifo_pop </td>
          <td>(</td>
          <td class="paramtype">FIFOBuffer *&#160;</td>
          <td class="paramname"><em>fb</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pop a character from the fifo buffer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Calling <code><a class="el" href="group__fifobuf.html#ga10b23a805dd320d7767e99087fa7df84" title="Pop a character from the fifo buffer.">fifo_pop()</a></code> on an empty buffer is undefined. The caller must make sure the buffer contains at least one character before calling this function.</dd>
<dd>
It is safe to call <a class="el" href="group__fifobuf.html#ga10b23a805dd320d7767e99087fa7df84" title="Pop a character from the fifo buffer.">fifo_pop()</a> and <a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a> from concurrent contexts. </dd></dl>

<p>Definition at line <a class="el" href="fifobuf_8h_source.html#l00177">177</a> of file <a class="el" href="fifobuf_8h_source.html">fifobuf.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa90a12236437f4c2c3205cd1f991a322"></a><!-- doxytag: member="fifobuf.h::fifo_push" ref="gaa90a12236437f4c2c3205cd1f991a322" args="(FIFOBuffer *fb, unsigned char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fifo_push </td>
          <td>(</td>
          <td class="paramtype">FIFOBuffer *&#160;</td>
          <td class="paramname"><em>fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push a character on the fifo buffer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Calling <code><a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a></code> on a full buffer is undefined. The caller must make sure the buffer has at least one free slot before calling this function.</dd>
<dd>
It is safe to call <a class="el" href="group__fifobuf.html#ga10b23a805dd320d7767e99087fa7df84" title="Pop a character from the fifo buffer.">fifo_pop()</a> and <a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a> from concurrent contexts, unless the CPU can't update a pointer atomically (which the AVR and other 8-bit processors can't do).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fifobuf.html#ga94060d3f5fbe5f5369486c61219b8c9b" title="Similar to fifo_push(), but with stronger guarantees for concurrent access between user and interrupt...">fifo_push_locked</a> </dd></dl>

<p>Definition at line <a class="el" href="fifobuf_8h_source.html#l00148">148</a> of file <a class="el" href="fifobuf_8h_source.html">fifobuf.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga94060d3f5fbe5f5369486c61219b8c9b"></a><!-- doxytag: member="fifobuf.h::fifo_push_locked" ref="ga94060d3f5fbe5f5369486c61219b8c9b" args="(FIFOBuffer *fb, unsigned char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fifo_push_locked </td>
          <td>(</td>
          <td class="paramtype">FIFOBuffer *&#160;</td>
          <td class="paramname"><em>fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a>, but with stronger guarantees for concurrent access between user and interrupt code. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is actually only needed for 8-bit processors.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push()</a> </dd></dl>

<p>Definition at line <a class="el" href="fifobuf_8h_source.html#l00243">243</a> of file <a class="el" href="fifobuf_8h_source.html">fifobuf.h</a>.</p>

</div>
</div>
</div>


