

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_8751e12fe1becf196f093883e557854f.html">struct</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hashtable.c File Reference</div>  </div>
</div>
<div class="contents">

<p>Portable hash table implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="hashtable_8h_source.html">hashtable.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cfg__hashtable_8h_source.html">cfg/cfg_hashtable.h</a>&quot;</code><br/>
<code>#include &lt;<a class="el" href="debug_8h_source.html">cfg/debug.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="compiler_8h_source.html">cfg/compiler.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="macros_8h_source.html">cfg/macros.h</a>&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
</div>
<p><a href="hashtable_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtable_8c.html#a6b7e711b5ccf8e4c6dc39e9940d31009">key_internal_get_ptr</a> (struct <a class="el" href="structHashTable.html">HashTable</a> *ht, HashNodePtr node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For hash tables with internal keys, compute the pointer to the internal key for a given <em>node</em>.  <a href="#a6b7e711b5ccf8e4c6dc39e9940d31009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hashtable.html#ga642ef6e1807f57157197f92a3647ccff">ht_init</a> (struct <a class="el" href="structHashTable.html">HashTable</a> *ht)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize (and clear) a hash table in a memory buffer.  <a href="group__hashtable.html#ga642ef6e1807f57157197f92a3647ccff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hashtable.html#ga7fa7adf45770670438f205ec1f17e8f6">ht_insert_with_key</a> (struct <a class="el" href="structHashTable.html">HashTable</a> *ht, const void *key, uint8_t key_length, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into the hash table.  <a href="group__hashtable.html#ga7fa7adf45770670438f205ec1f17e8f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hashtable.html#ga40e43fc231256c2ea0593c044ed90736">ht_insert</a> (struct <a class="el" href="structHashTable.html">HashTable</a> *ht, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into the hash table.  <a href="group__hashtable.html#ga40e43fc231256c2ea0593c044ed90736"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hashtable.html#gaba057880cc98ec88e0fcd46b54bb5a71">ht_find</a> (struct <a class="el" href="structHashTable.html">HashTable</a> *ht, const void *key, uint8_t key_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element in the hash table.  <a href="group__hashtable.html#gaba057880cc98ec88e0fcd46b54bb5a71"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Portable hash table implementation. </p>
<p>Some rationales of our choices in implementation:</p>
<ul>
<li>For embedded systems, it is vital to allocate the table in static memory. To do so, it is necessary to expose the <code>HashNode</code> and <code><a class="el" href="structHashTable.html" title="Hash table description.">HashTable</a></code> structures in the header file. Nevertheless, they should be used as opaque types (that is, the users should not access the structure fields directly).</li>
</ul>
<ul>
<li>To statically allocate the structures, a macro is provided. With this macro, we are hiding completely <code>HashNode</code> to the user (who only manipulates <code><a class="el" href="structHashTable.html" title="Hash table description.">HashTable</a></code>). Without the macro, the user would have had to define both the <code>HashNode</code> and the <code><a class="el" href="structHashTable.html" title="Hash table description.">HashTable</a></code> manually, and pass both of them to <code><a class="el" href="group__hashtable.html#ga642ef6e1807f57157197f92a3647ccff" title="Initialize (and clear) a hash table in a memory buffer.">ht_init()</a></code> (which would have created the link between the two). Instead, the link is created with a literal initialization.</li>
</ul>
<ul>
<li>The hash table is created as power of two to remove the divisions from the code. Of course, hash functions work at their best when the table size is a prime number. When calculating the modulus to convert the hash value to an index, the actual operation becomes a bitwise AND: this is fast, but truncates the value losing bits. Thus, the higher bits are first "merged" with the lower bits through some XOR operations (see the last line of <code>calc_hash()</code>).</li>
</ul>
<ul>
<li>To minimize the memory occupation, there is no flag to set for the empty node. An empty node is recognized by its data pointer set to NULL. It is then invalid to store NULL as data pointer in the table.</li>
</ul>
<ul>
<li>The visiting interface through iterators is implemented with pass-by-value semantic. While this is overkill for medium-to-stupid compilers, it is the best designed from an user point of view. Moreover, being totally inlined (defined completely in the header), even a stupid compiler should be able to perform basic optimizations on it. We thought about using a pass-by-pointer semantic but it was much more awful to use, and the compiler is then forced to spill everything to the stack (unless it is *very* smart).</li>
</ul>
<ul>
<li>The current implementation allows to either store the key internally (that is, copy the key within the hash table) or keep it external (that is, a hook is used to extract the key from the data in the node). The former is more memory-hungry of course, as it allocated static space to store the key copies. The overhead to keep both methods at the same time is minimal: <ul>
<li>
There is a run-time check in node_get_key which is execute per each node visited. </li>
<li>
Theoretically, there is no memory overhead. In practice, there were no flags in <code>struct</code> <a class="el" href="structHashTable.html" title="Hash table description.">HashTable</a> till now, so we had to add a first bit flag, but the overhead will disappear if a second flag is added for a different reason later. </li>
<li>
There is a little interface overhead, since we have two different versions of <code><a class="el" href="group__hashtable.html#ga40e43fc231256c2ea0593c044ed90736" title="Insert an element into the hash table.">ht_insert()</a></code>, one with the key passed as parameter and one without, but in the common case (external keys) both can be used. </li>
</ul>
</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Giovanni Bajo &lt;<a href="mailto:rasky@develer.com">rasky@develer.com</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="hashtable_8c_source.html">hashtable.c</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6b7e711b5ccf8e4c6dc39e9940d31009"></a><!-- doxytag: member="hashtable.c::key_internal_get_ptr" ref="a6b7e711b5ccf8e4c6dc39e9940d31009" args="(struct HashTable *ht, HashNodePtr node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* key_internal_get_ptr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structHashTable.html">HashTable</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashNodePtr&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For hash tables with internal keys, compute the pointer to the internal key for a given <em>node</em>. </p>

<p>Definition at line <a class="el" href="hashtable_8c_source.html#l00099">99</a> of file <a class="el" href="hashtable_8c_source.html">hashtable.c</a>.</p>

</div>
</div>
</div>


