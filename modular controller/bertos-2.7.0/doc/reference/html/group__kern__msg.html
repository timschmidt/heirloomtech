

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Message box IPC</div>  </div>
<div class="ingroups"><a class="el" href="group__kern.html">Kernel facilities</a></div></div>
<div class="contents">

<p>Simple inter-process messaging system.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__msg.html#ga8435a3e489bca56f5b3a7090292e320d">msg_lockPort</a> (UNUSED_ARG(MsgPort *, port))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a message port.  <a href="#ga8435a3e489bca56f5b3a7090292e320d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__msg.html#ga4079e4c23f3cdd2d507c557d35c2653c">msg_unlockPort</a> (UNUSED_ARG(MsgPort *, port))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a message port.  <a href="#ga4079e4c23f3cdd2d507c557d35c2653c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1616b92bdd9e89a1e5c808fd4129b388"></a><!-- doxytag: member="kern_msg::msg_initPort" ref="ga1616b92bdd9e89a1e5c808fd4129b388" args="(MsgPort *port, Event event)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__msg.html#ga1616b92bdd9e89a1e5c808fd4129b388">msg_initPort</a> (MsgPort *port, Event event)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a message port. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a79553075b4fe784d01f06cebefbfbf"></a><!-- doxytag: member="kern_msg::msg_put" ref="ga6a79553075b4fe784d01f06cebefbfbf" args="(MsgPort *port, Msg *msg)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__msg.html#ga6a79553075b4fe784d01f06cebefbfbf">msg_put</a> (MsgPort *port, Msg *msg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue <em>msg</em> into <em>port</em>, triggering the associated event. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Msg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__msg.html#gab5a0fd945047f4836d96140df49498e9">msg_get</a> (MsgPort *port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first message from the queue of <em>port</em>.  <a href="#gab5a0fd945047f4836d96140df49498e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Msg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__msg.html#gab68f11964eea12902217abe3f4d48ae7">msg_peek</a> (MsgPort *port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the first message in the queue of <em>port</em>, or NULL if the port is empty.  <a href="#gab68f11964eea12902217abe3f4d48ae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__msg.html#ga140e112add506493b50b7aae7a45eed6">msg_reply</a> (Msg *msg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send back (reply) <em>msg</em> to its sender.  <a href="#ga140e112add506493b50b7aae7a45eed6"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Simple inter-process messaging system. </p>
<p>This module implements a common system for executing a user defined action calling a hook function.</p>
<p>A message port is an abstraction used to exchange information asynchronously between processes or other entities such as interrupts and call-back functions.</p>
<p>This form of IPC is higher-level than bare signals and semaphores, because it sets a policy for exchanging structured data with well-defined synchronization and ownership semantics.</p>
<p>Before using it, a message port must be initialized by calling <a class="el" href="group__kern__msg.html#ga1616b92bdd9e89a1e5c808fd4129b388" title="Initialize a message port.">msg_initPort()</a>, which associates the port with an Event object, which can be setup to signal a process or invoke a call-back hook.</p>
<p>A process or interrupt routine can deliver messages to any message port by calling <a class="el" href="group__kern__msg.html#ga6a79553075b4fe784d01f06cebefbfbf" title="Queue msg into port, triggering the associated event.">msg_put()</a>. By sending a message, the sender temporarly or permanently transfers ownership of its associated data to the receiver.</p>
<p>Queuing a message to a port automatically triggers the associated Event to notify the receiver. When the receiver wakes up, it usually invokes <a class="el" href="group__kern__msg.html#gab5a0fd945047f4836d96140df49498e9" title="Get the first message from the queue of port.">msg_get()</a> to pick the next message from the port.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>When you put a message into a port, such message becomes unavailable until you retrieve it using <a class="el" href="group__kern__msg.html#gab5a0fd945047f4836d96140df49498e9" title="Get the first message from the queue of port.">msg_get()</a>, eg. you must not delete it or put it into another port.</dd></dl>
<p>Message ports can hold any number of pending messages, and receivers usually process them in FIFO order. Other scheduling policies are possible, but not implemented in this API.</p>
<p>After the receiver has done processing a message, it replies it back to the sender with <a class="el" href="group__kern__msg.html#ga140e112add506493b50b7aae7a45eed6" title="Send back (reply) msg to its sender.">msg_reply()</a>, which transfer ownership back to the original sender. Replies are delivered to a reply port, which is nothing more than another MsgPort structure designated by the sender.</p>
<p>Returning messages to senders is not mandatory, but it provides a convenient way to provide some kind of result and simplify the resource allocation scheme at the same time.</p>
<p>When using signals to receive messages in a process, you call <a class="el" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait()</a> in an event-loop to wake up when messages are delivered to any of your ports. When your process wakes up with the port signal active, multiple messages may already have queued up at the message port, and the process must process them all before returning to sleep. Signals don't keep a nesting count.</p>
<p>A simple message loop works like this:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Our message port.</span>
    <span class="keyword">static</span> MsgPort test_port;

    <span class="comment">// A test message with two parameters and a result.</span>
    <span class="keyword">typedef</span> <span class="keyword">struct</span>
    {
        Msg msg;

        <span class="keywordtype">int</span> x, y;
        <span class="keywordtype">int</span> result;
    } TestMsg;


  <a class="code" href="group__kern__proc.html#gad78992529a7850e21738807c606482fb" title="Utility macro to allocate a stack of size size.">PROC_DEFINE_STACK</a>(sender_stack, <a class="code" href="group__kern__proc.html#gaecdaaed892f1308f96ad90bd3abebdcb" title="Default stack size for each thread, in bytes.">KERN_MINSTACKSIZE</a>);

    <span class="comment">// A process that sends two messages and waits for replies.</span>
    <span class="keyword">static</span> <span class="keywordtype">void</span> sender_proc(<span class="keywordtype">void</span>)
    {
        MsgPort test_reply_port;
        TestMsg msg1;
        TestMsg msg2;
        Msg *reply;

        <a class="code" href="group__kern__msg.html#ga1616b92bdd9e89a1e5c808fd4129b388" title="Initialize a message port.">msg_initPort</a>(&amp;test_reply_port,
            event_createSignal(<a class="code" href="group__kern__proc.html#gaaf85f02d7fa77e547dd2a770f2707b5f" title="Return the context structure of the currently running process.">proc_current</a>(), <a class="code" href="group__kern__signal.html#ga7601fe23b72cbb7eba5853e9f8a1ee98" title="Used to wait for a single event.">SIG_SINGLE</a>);

        <span class="comment">// Fill-in first message and send it out.</span>
        msg1.x = 3;
        msg1.y = 2;
        msg1.msg.replyPort = &amp;test_reply_port;
        <a class="code" href="group__kern__msg.html#ga6a79553075b4fe784d01f06cebefbfbf" title="Queue msg into port, triggering the associated event.">msg_put</a>(&amp;test_port, &amp;msg1.msg);

        <span class="comment">// Fill-in second message and send it out too.</span>
        msg2.x = 5;
        msg2.y = 4;
        msg2.msg.replyPort = &amp;test_reply_port;
        <a class="code" href="group__kern__msg.html#ga6a79553075b4fe784d01f06cebefbfbf" title="Queue msg into port, triggering the associated event.">msg_put</a>(&amp;test_port, &amp;msg2.msg);

        <span class="comment">// Wait for a reply...</span>
        <a class="code" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait</a>(<a class="code" href="group__kern__signal.html#ga7601fe23b72cbb7eba5853e9f8a1ee98" title="Used to wait for a single event.">SIG_SINGLE</a>);

        reply = <a class="code" href="compiler_8h.html#ad8a293330664172f7fb87c204bac34b3" title="Cast a member of a structure out to the containing structure.">containerof</a>(<a class="code" href="group__kern__msg.html#gab5a0fd945047f4836d96140df49498e9" title="Get the first message from the queue of port.">msg_get</a>(&amp;test_reply_port), TestMsg, msg);
        <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(reply != NULL);
        <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(reply-&gt;result == 5);

        <span class="comment">// Get reply to second message.</span>
        <span class="keywordflow">while</span> (!(reply = <a class="code" href="compiler_8h.html#ad8a293330664172f7fb87c204bac34b3" title="Cast a member of a structure out to the containing structure.">containerof</a>(<a class="code" href="group__kern__msg.html#gab5a0fd945047f4836d96140df49498e9" title="Get the first message from the queue of port.">msg_get</a>(&amp;test_reply_port), TestMsg, msg)))
        {
            <span class="comment">// Not yet, be patient and wait some more.</span>
            <a class="code" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait</a>(<a class="code" href="group__kern__signal.html#ga7601fe23b72cbb7eba5853e9f8a1ee98" title="Used to wait for a single event.">SIG_SINGLE</a>);
        }

        <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(reply-&gt;result == 9);
    }


    <span class="comment">// Receive messages and do something boring with them.</span>
    <span class="keyword">static</span> <span class="keywordtype">void</span> receiver_proc(<span class="keywordtype">void</span>)
    {
        <a class="code" href="group__kern__msg.html#ga1616b92bdd9e89a1e5c808fd4129b388" title="Initialize a message port.">msg_initPort</a>(&amp;test_port,
            event_createSignal(<a class="code" href="group__kern__proc.html#gaaf85f02d7fa77e547dd2a770f2707b5f" title="Return the context structure of the currently running process.">proc_current</a>(), SIG_EXAMPLE);

        <a class="code" href="group__kern__proc.html#gaca4f0091f2e3c8115a1be7aabc0866ef" title="Create a new named process and schedules it for execution.">proc_new</a>(sender_proc, NULL,<span class="keyword">sizeof</span>(sender_stack), sender_stack);

        <span class="keywordflow">for</span> (;;)
        {
            <a class="code" href="compiler_8h.html#a8eab9d9d79ff58f19a5a51e821d95330" title="Type for signal masks.">sigmask_t</a> sigs = <a class="code" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait</a>(SIG_EXAMPLE | more_signals);

            <span class="keywordflow">if</span> (sigs &amp; SIG_EXAMPLE)
            {
                TestMsg *emsg;
                <span class="keywordflow">while</span>((emsg = <a class="code" href="compiler_8h.html#ad8a293330664172f7fb87c204bac34b3" title="Cast a member of a structure out to the containing structure.">containerof</a>(<a class="code" href="group__kern__msg.html#gab5a0fd945047f4836d96140df49498e9" title="Get the first message from the queue of port.">msg_get</a>(&amp;test_port), TestMsg, msg)))
                {
                    <span class="comment">// Do something with the message</span>
                    emsg-&gt;result = emsg-&gt;x + emsg-&gt;y;
                    <a class="code" href="group__kern__msg.html#ga140e112add506493b50b7aae7a45eed6" title="Send back (reply) msg to its sender.">msg_reply</a>(emsg-&gt;msg);
                }
            }
        }
    }
</pre></div><dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab5a0fd945047f4836d96140df49498e9"></a><!-- doxytag: member="msg.h::msg_get" ref="gab5a0fd945047f4836d96140df49498e9" args="(MsgPort *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Msg* msg_get </td>
          <td>(</td>
          <td class="paramtype">MsgPort *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the first message from the queue of <em>port</em>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the message or NULL if the port was empty. </dd></dl>

<p>Definition at line <a class="el" href="msg_8h_source.html#l00263">263</a> of file <a class="el" href="msg_8h_source.html">msg.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8435a3e489bca56f5b3a7090292e320d"></a><!-- doxytag: member="msg.h::msg_lockPort" ref="ga8435a3e489bca56f5b3a7090292e320d" args="(UNUSED_ARG(MsgPort *, port))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msg_lockPort </td>
          <td>(</td>
          <td class="paramtype">UNUSED_ARG(MsgPort *, port)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock a message port. </p>
<p>This is required before reading or manipulating any field of the MsgPort structure.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Ports may be locked multiple times and each call to <a class="el" href="group__kern__msg.html#ga8435a3e489bca56f5b3a7090292e320d" title="Lock a message port.">msg_lockPort()</a> must be paired with a corresponding call to <a class="el" href="group__kern__msg.html#ga4079e4c23f3cdd2d507c557d35c2653c" title="Unlock a message port.">msg_unlockPort()</a>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__kern__msg.html#ga4079e4c23f3cdd2d507c557d35c2653c" title="Unlock a message port.">msg_unlockPort()</a> </dd></dl>

<p>Definition at line <a class="el" href="msg_8h_source.html#l00225">225</a> of file <a class="el" href="msg_8h_source.html">msg.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab68f11964eea12902217abe3f4d48ae7"></a><!-- doxytag: member="msg.h::msg_peek" ref="gab68f11964eea12902217abe3f4d48ae7" args="(MsgPort *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Msg* msg_peek </td>
          <td>(</td>
          <td class="paramtype">MsgPort *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek the first message in the queue of <em>port</em>, or NULL if the port is empty. </p>

<p>Definition at line <a class="el" href="msg_8h_source.html#l00275">275</a> of file <a class="el" href="msg_8h_source.html">msg.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga140e112add506493b50b7aae7a45eed6"></a><!-- doxytag: member="msg.h::msg_reply" ref="ga140e112add506493b50b7aae7a45eed6" args="(Msg *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msg_reply </td>
          <td>(</td>
          <td class="paramtype">Msg *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send back (reply) <em>msg</em> to its sender. </p>

<p>Definition at line <a class="el" href="msg_8h_source.html#l00289">289</a> of file <a class="el" href="msg_8h_source.html">msg.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4079e4c23f3cdd2d507c557d35c2653c"></a><!-- doxytag: member="msg.h::msg_unlockPort" ref="ga4079e4c23f3cdd2d507c557d35c2653c" args="(UNUSED_ARG(MsgPort *, port))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msg_unlockPort </td>
          <td>(</td>
          <td class="paramtype">UNUSED_ARG(MsgPort *, port)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock a message port. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__kern__msg.html#ga8435a3e489bca56f5b3a7090292e320d" title="Lock a message port.">msg_lockPort()</a> </dd></dl>

<p>Definition at line <a class="el" href="msg_8h_source.html#l00235">235</a> of file <a class="el" href="msg_8h_source.html">msg.h</a>.</p>

</div>
</div>
</div>


