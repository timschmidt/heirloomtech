

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Process (Threads) management</div>  </div>
<div class="ingroups"><a class="el" href="group__kern.html">Kernel facilities</a></div></div>
<div class="contents">

<p>BeRTOS Kernel core (Process scheduler).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#gaca4f0091f2e3c8115a1be7aabc0866ef">proc_new</a>(entry, data, size, stack)&#160;&#160;&#160;proc_new_with_name(NULL,(entry),(data),(size),(stack))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new named process and schedules it for execution.  <a href="#gaca4f0091f2e3c8115a1be7aabc0866ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga334095188ac17315a619a7dff54db037">proc_allowed</a>()&#160;&#160;&#160;proc_preemptAllowed()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, use the <a class="el" href="group__kern__proc.html#ga094e270e355ca3eb94de8a217cae452f">proc_preemptAllowed()</a> macro.  <a href="#ga334095188ac17315a619a7dff54db037"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b47fed0e4369c89b63b21c7f58975a8"></a><!-- doxytag: member="kern_proc::PROC_ATOMIC" ref="ga4b47fed0e4369c89b63b21c7f58975a8" args="(CODE)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga4b47fed0e4369c89b63b21c7f58975a8">PROC_ATOMIC</a>(CODE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a block of <em>CODE</em> atomically with respect to task scheduling. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#gaecdaaed892f1308f96ad90bd3abebdcb">KERN_MINSTACKSIZE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stack size for each thread, in bytes.  <a href="#gaecdaaed892f1308f96ad90bd3abebdcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#gad78992529a7850e21738807c606482fb">PROC_DEFINE_STACK</a>(name, size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility macro to allocate a stack of size <em>size</em>.  <a href="#gad78992529a7850e21738807c606482fb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#gafdd9e124a2e47f620d4165b86713c516">proc_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the process subsystem (kernel).  <a href="#gafdd9e124a2e47f620d4165b86713c516"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga801921eb02f65dca34d22259e3b0dc2f"></a><!-- doxytag: member="kern_proc::proc_exit" ref="ga801921eb02f65dca34d22259e3b0dc2f" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga801921eb02f65dca34d22259e3b0dc2f">proc_exit</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the execution of the current process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72082e8b84836feab2a91112d0652f51"></a><!-- doxytag: member="kern_proc::proc_yield" ref="ga72082e8b84836feab2a91112d0652f51" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga72082e8b84836feab2a91112d0652f51">proc_yield</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Voluntarily release the CPU. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f85de128c92d2071319ead0cf720183"></a><!-- doxytag: member="kern_proc::proc_needPreempt" ref="ga1f85de128c92d2071319ead0cf720183" args="(void)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga1f85de128c92d2071319ead0cf720183">proc_needPreempt</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we need to schedule another task. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga40de383d632d82694a5876d51449a362"></a><!-- doxytag: member="kern_proc::proc_preempt" ref="ga40de383d632d82694a5876d51449a362" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga40de383d632d82694a5876d51449a362">proc_preempt</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Preempt the current task. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga966377102c741fae0032bf5f8b3db457"></a><!-- doxytag: member="kern_proc::proc_rename" ref="ga966377102c741fae0032bf5f8b3db457" args="(struct Process *proc, const char *name)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga966377102c741fae0032bf5f8b3db457">proc_rename</a> (struct Process *proc, const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga1ecf78dbfdb29f213ce7c03342e0a929">proc_name</a> (struct Process *proc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the specified process.  <a href="#ga1ecf78dbfdb29f213ce7c03342e0a929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga350b8b97bc00c6912a7ed043aa3c30f3"></a><!-- doxytag: member="kern_proc::proc_currentName" ref="ga350b8b97bc00c6912a7ed043aa3c30f3" args="(void)" -->
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga350b8b97bc00c6912a7ed043aa3c30f3">proc_currentName</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the currently running process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler_8h.html#afebdfc027148249641ae51fb8c7914fc">iptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga99de73e446d3ff5f913227970ae0385e">proc_currentUserData</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the user data of the current process.  <a href="#ga99de73e446d3ff5f913227970ae0385e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct Process *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#gaaf85f02d7fa77e547dd2a770f2707b5f">proc_current</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context structure of the currently running process.  <a href="#gaaf85f02d7fa77e547dd2a770f2707b5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#gaab27aeaf1d2db5432406b4564e4bf63a">proc_setPri</a> (struct Process *proc, int pri)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the scheduling priority of a process.  <a href="#gaab27aeaf1d2db5432406b4564e4bf63a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga4161db7fa7a7302cd1cce624ac210ef4">proc_forbid</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable preemptive task switching.  <a href="#ga4161db7fa7a7302cd1cce624ac210ef4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga537a0dc1c882de1e2d1648e934327ce0">proc_permit</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enable preemptive task switching.  <a href="#ga537a0dc1c882de1e2d1648e934327ce0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kern__proc.html#ga094e270e355ca3eb94de8a217cae452f">proc_preemptAllowed</a> (void)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>BeRTOS Kernel core (Process scheduler). </p>
<p>This is the core kernel module. It allows you to create new processes (which are called <b>threads</b> in other systems) and set the priority of each process.</p>
<p>A process needs a work area (called <b>stack</b>) to run. To create a process, you need to declare a stack area, then create the process. You may also pass NULL for the stack area, if you have enabled kernel heap: in this case the stack will be automatically allocated.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__kern__proc.html#gad78992529a7850e21738807c606482fb" title="Utility macro to allocate a stack of size size.">PROC_DEFINE_STACK</a>(stack1, 200);

 <span class="keywordtype">void</span> NORETURN proc1_run(<span class="keywordtype">void</span>)
 {
    <span class="keywordflow">while</span> (1)
    {
       <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;I&#39;m alive!\n&quot;</span>);
       <a class="code" href="group__drv__timers.html#gace6fb3d382bd740f9cee1b139e12f7a6" title="Wait some time [ms].">timer_delay</a>(1000);
    }
 }


 <span class="keywordtype">int</span> main()
 {
    Process *p1 = <a class="code" href="group__kern__proc.html#gaca4f0091f2e3c8115a1be7aabc0866ef" title="Create a new named process and schedules it for execution.">proc_new</a>(proc1_run, NULL, stack1, <span class="keyword">sizeof</span>(stack1));
    <span class="comment">// here the process is already running</span>
    <a class="code" href="group__kern__proc.html#gaab27aeaf1d2db5432406b4564e4bf63a" title="Change the scheduling priority of a process.">proc_setPri</a>(p1, 2);
    <span class="comment">// ...</span>
 }
</pre></div><p>The Process struct must be regarded as an opaque data type, do not access any of its members directly.</p>
<p>The entry point function should be declared as NORETURN, because it will remove a warning and enable compiler optimizations.</p>
<p>You can temporarily disable preemption calling <a class="el" href="group__kern__proc.html#ga4161db7fa7a7302cd1cce624ac210ef4" title="Disable preemptive task switching.">proc_forbid()</a>; remember to enable it again calling <a class="el" href="group__kern__proc.html#ga537a0dc1c882de1e2d1648e934327ce0" title="Re-enable preemptive task switching.">proc_permit()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You should hardly need to manually release the CPU; however you can do it using the <a class="el" href="power_8h.html#aa0eaaa5f710ff7d97371d8053e73e692" title="Let the CPU rest in tight busy loops.">cpu_relax()</a> function. It is illegal to release the CPU with preemption disabled.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaecdaaed892f1308f96ad90bd3abebdcb"></a><!-- doxytag: member="proc.h::KERN_MINSTACKSIZE" ref="gaecdaaed892f1308f96ad90bd3abebdcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KERN_MINSTACKSIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<span class="keyword">sizeof</span>(Process) + CPU_SAVED_REGS_CNT * 2 * <span class="keyword">sizeof</span>(cpu_stack_t) \
            + 32 * <span class="keyword">sizeof</span>(int) * 2)
</pre></div>
<p>Default stack size for each thread, in bytes. </p>
<p>The goal here is to allow a minimal task to save all of its registers twice, plus push a maximum of 32 variables on the stack. We add also struct Process size since we save it into the process' stack.</p>
<p>The actual size computed by the default formula greatly depends on what options are active and on the architecture.</p>
<p>Note that on most 16bit architectures, interrupts will also run on the stack of the currently running process. Nested interrupts will greatly increases the amount of stack space required per process. Use irqmanager to minimize stack usage. </p>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00405">405</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga334095188ac17315a619a7dff54db037"></a><!-- doxytag: member="proc.h::proc_allowed" ref="ga334095188ac17315a619a7dff54db037" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define proc_allowed</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;proc_preemptAllowed()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deprecated, use the <a class="el" href="group__kern__proc.html#ga094e270e355ca3eb94de8a217cae452f">proc_preemptAllowed()</a> macro. </p>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00358">358</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad78992529a7850e21738807c606482fb"></a><!-- doxytag: member="proc.h::PROC_DEFINE_STACK" ref="gad78992529a7850e21738807c606482fb" args="(name, size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROC_DEFINE_STACK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">cpu_stack_t name[((size) + <span class="keyword">sizeof</span>(cpu_stack_t) - 1) / <span class="keyword">sizeof</span>(cpu_stack_t)]; \
    <a class="code" href="compiler_8h.html#a695e64485eb9535f5ddcfec01167bddc" title="Issue a compilation error if the condition is false.">STATIC_ASSERT</a>((size) &gt;= <a class="code" href="group__kern__proc.html#gaecdaaed892f1308f96ad90bd3abebdcb" title="Default stack size for each thread, in bytes.">KERN_MINSTACKSIZE</a>);
</pre></div>
<p>Utility macro to allocate a stack of size <em>size</em>. </p>
<p>This macro define a static stack for one process and do check if given stack size is enough to run process. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you plan to use kprintf() and similar functions, you will need at least KERN_MINSTACKSIZE * 2 bytes.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Variable name for the stack. </td></tr>
    <tr><td class="paramname">size</td><td>Stack size in bytes. It must be at least KERN_MINSTACKSIZE. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00434">434</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaca4f0091f2e3c8115a1be7aabc0866ef"></a><!-- doxytag: member="proc.h::proc_new" ref="gaca4f0091f2e3c8115a1be7aabc0866ef" args="(entry, data, size, stack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define proc_new</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stack&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;proc_new_with_name(NULL,(entry),(data),(size),(stack))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new named process and schedules it for execution. </p>
<p>When defining the stacksize take into account that you may want at least: </p>
<ul>
<li>save all the registers for each nested function call; </li>
<li>have memory for the struct Process, which is positioned at the bottom of the stack; </li>
<li>have some memory for temporary variables inside called functions.</li>
</ul>
<p>The value given by KERN_MINSTACKSIZE is rather safe to use in the first place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Function that the process will execute. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to user data. </td></tr>
    <tr><td class="paramname">size</td><td>Length of the stack. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the memory area to be used as a stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Process structure of new created process if successful, NULL otherwise. </dd></dl>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00192">192</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaaf85f02d7fa77e547dd2a770f2707b5f"></a><!-- doxytag: member="proc.h::proc_current" ref="gaaf85f02d7fa77e547dd2a770f2707b5f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Process* proc_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the context structure of the currently running process. </p>
<p>The details of the Process structure are private to the scheduler. The address returned by this function is an opaque pointer that can be passed as an argument to other process-related functions. </p>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00249">249</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga99de73e446d3ff5f913227970ae0385e"></a><!-- doxytag: member="proc.h::proc_currentUserData" ref="ga99de73e446d3ff5f913227970ae0385e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler_8h.html#afebdfc027148249641ae51fb8c7914fc">iptr_t</a> proc_currentUserData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to the user data of the current process. </p>
<p>To obtain user data, just call this function inside the process. Remember to cast the returned pointer to the correct type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the user data of the current process. </dd></dl>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00232">232</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4161db7fa7a7302cd1cce624ac210ef4"></a><!-- doxytag: member="proc.h::proc_forbid" ref="ga4161db7fa7a7302cd1cce624ac210ef4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_forbid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable preemptive task switching. </p>
<p>The scheduler maintains a global nesting counter. Task switching is effectively re-enabled only when the number of calls to <a class="el" href="group__kern__proc.html#ga537a0dc1c882de1e2d1648e934327ce0" title="Re-enable preemptive task switching.">proc_permit()</a> matches the number of calls to <a class="el" href="group__kern__proc.html#ga4161db7fa7a7302cd1cce624ac210ef4" title="Disable preemptive task switching.">proc_forbid()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Calling functions that could sleep while task switching is disabled is dangerous and unsupported.</dd>
<dd>
<a class="el" href="group__kern__proc.html#ga537a0dc1c882de1e2d1648e934327ce0" title="Re-enable preemptive task switching.">proc_permit()</a> expands inline to 1-2 asm instructions, so it's a very efficient locking primitive in simple but performance-critical situations. In all other cases, semaphores offer a more flexible and fine-grained locking primitive.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__kern__proc.html#ga537a0dc1c882de1e2d1648e934327ce0" title="Re-enable preemptive task switching.">proc_permit()</a> </dd></dl>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00282">282</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafdd9e124a2e47f620d4165b86713c516"></a><!-- doxytag: member="proc.h::proc_init" ref="gafdd9e124a2e47f620d4165b86713c516" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the process subsystem (kernel). </p>
<p>It must be called before using any process related function. </p>

<p>Definition at line <a class="el" href="proc_8c_source.html#l00207">207</a> of file <a class="el" href="proc_8c_source.html">proc.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ecf78dbfdb29f213ce7c03342e0a929"></a><!-- doxytag: member="proc.h::proc_name" ref="ga1ecf78dbfdb29f213ce7c03342e0a929" args="(struct Process *proc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* proc_name </td>
          <td>(</td>
          <td class="paramtype">struct Process *&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the name of the specified process. </p>
<p>NULL is a legal argument and will return the name "&lt;NULL&gt;". </p>

<p>Definition at line <a class="el" href="proc_8c_source.html#l00399">399</a> of file <a class="el" href="proc_8c_source.html">proc.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga537a0dc1c882de1e2d1648e934327ce0"></a><!-- doxytag: member="proc.h::proc_permit" ref="ga537a0dc1c882de1e2d1648e934327ce0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_permit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-enable preemptive task switching. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__kern__proc.html#ga4161db7fa7a7302cd1cce624ac210ef4" title="Disable preemptive task switching.">proc_forbid()</a> </dd></dl>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00322">322</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga094e270e355ca3eb94de8a217cae452f"></a><!-- doxytag: member="proc.h::proc_preemptAllowed" ref="ga094e270e355ca3eb94de8a217cae452f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool proc_preemptAllowed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if preemptive task switching is allowed. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This accessor is needed because preempt_count must be absoultely private. </dd></dl>

<p>Definition at line <a class="el" href="proc_8h_source.html#l00346">346</a> of file <a class="el" href="proc_8h_source.html">proc.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaab27aeaf1d2db5432406b4564e4bf63a"></a><!-- doxytag: member="proc.h::proc_setPri" ref="gaab27aeaf1d2db5432406b4564e4bf63a" args="(struct Process *proc, int pri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_setPri </td>
          <td>(</td>
          <td class="paramtype">struct Process *&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the scheduling priority of a process. </p>
<p>Process piorities are signed ints, whereas a larger integer value means higher scheduling priority. The default priority for new processes is 0. The idle process runs with the lowest possible priority: INT_MIN.</p>
<p>A process with a higher priority always preempts lower priority processes. Processes of equal priority share the CPU time according to a simple round-robin policy.</p>
<p>As a general rule to maximize responsiveness, compute-bound processes should be assigned negative priorities and tight, interactive processes should be assigned positive priorities.</p>
<p>To avoid interfering with system background activities such as input processing, application processes should remain within the range -10 and +10. </p>

<p>Definition at line <a class="el" href="proc_8c_source.html#l00446">446</a> of file <a class="el" href="proc_8c_source.html">proc.c</a>.</p>

</div>
</div>
</div>


