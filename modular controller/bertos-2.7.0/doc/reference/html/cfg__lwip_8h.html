

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_14d9385a2a2e35e16810522966ce41de.html">cfg</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<div class="title">cfg_lwip.h File Reference</div>  </div>
</div>
<div class="contents">

<p>Configuration file for the lwIP TCP/IP stack module.  
<a href="#details">More...</a></p>

<p><a href="cfg__lwip_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae85efb3a5fcf8585c94b3c2669978959"></a><!-- doxytag: member="cfg_lwip.h::SYS_LIGHTWEIGHT_PROT" ref="ae85efb3a5fcf8585c94b3c2669978959" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae85efb3a5fcf8585c94b3c2669978959">SYS_LIGHTWEIGHT_PROT</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain critical regions during buffer allocation, deallocation and memory allocation and deallocation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae00ba99de94a5bf84d832be8976df59b">NO_SYS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NO_SYS==1: Provides VERY minimal functionality.  <a href="#ae00ba99de94a5bf84d832be8976df59b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1dd57a66b6de8c0593e9e3e8d1411f6"></a><!-- doxytag: member="cfg_lwip.h::MEMCPY" ref="aa1dd57a66b6de8c0593e9e3e8d1411f6" args="(dst, src, len)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aa1dd57a66b6de8c0593e9e3e8d1411f6">MEMCPY</a>(dst, src, len)&#160;&#160;&#160;memcpy(dst,src,len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMCPY: override this if you have a faster implementation at hand than the one included in your C library. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8c6e3c1e4f74acb16376188dbf8909ec">SMEMCPY</a>(dst, src, len)&#160;&#160;&#160;memcpy(dst,src,len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SMEMCPY: override this with care! Some compilers (e.g.  <a href="#a8c6e3c1e4f74acb16376188dbf8909ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a4ef345cc270912bd2230b1c5ec51dfc8">MEM_LIBC_MALLOC</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library instead of the lwip internal allocator.  <a href="#a4ef345cc270912bd2230b1c5ec51dfc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93af697d27bbcefa6a28052d90f2f38"></a><!-- doxytag: member="cfg_lwip.h::MEMP_MEM_MALLOC" ref="ae93af697d27bbcefa6a28052d90f2f38" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae93af697d27bbcefa6a28052d90f2f38">MEMP_MEM_MALLOC</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use mem_malloc/mem_free instead of the lwip pool allocator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a97343214666ee6dcb18c0bd77b441ea7">MEM_ALIGNMENT</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEM_ALIGNMENT: should be set to the alignment of the CPU.  <a href="#a97343214666ee6dcb18c0bd77b441ea7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a2dcf8c45f945dd0c4301a94700f2112c">MEM_SIZE</a>&#160;&#160;&#160;1600</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the lwIP heap memory.  <a href="#a2dcf8c45f945dd0c4301a94700f2112c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a27fdd01194a42fc41a7716b72cdb49e3">MEMP_OVERFLOW_CHECK</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic pool memory overflow protection check level.  <a href="#a27fdd01194a42fc41a7716b72cdb49e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0838947193e222a9f46b582e01e5beff"></a><!-- doxytag: member="cfg_lwip.h::MEMP_SANITY_CHECK" ref="a0838947193e222a9f46b582e01e5beff" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a0838947193e222a9f46b582e01e5beff">MEMP_SANITY_CHECK</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a sanity check after each memp_free(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#addca3141bc7037241769eb152b6f89ba">MEM_USE_POOLS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set of memory pools of various sizes.  <a href="#addca3141bc7037241769eb152b6f89ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aba8be68e8fd0716b723ce4569ed89f82">MEM_USE_POOLS_TRY_BIGGER_POOL</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more reliable.  <a href="#aba8be68e8fd0716b723ce4569ed89f82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a69de593b8ffd4f1c249f03e48e11983b">MEMP_USE_CUSTOM_POOLS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h that defines additional pools beyond the "standard" ones required by lwIP.  <a href="#a69de593b8ffd4f1c249f03e48e11983b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a0a3ef6098813c103e5aba07da76e15e2">LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from interrupt context (or another context that doesn't allow waiting for a semaphore).  <a href="#a0a3ef6098813c103e5aba07da76e15e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a92b30aed958ec59334d936d4ca725418">MEMP_NUM_PBUF</a>&#160;&#160;&#160;16</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).  <a href="#a92b30aed958ec59334d936d4ca725418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a379bf92ed322cda54cb701337421e0d3"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_RAW_PCB" ref="a379bf92ed322cda54cb701337421e0d3" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a379bf92ed322cda54cb701337421e0d3">MEMP_NUM_RAW_PCB</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_RAW_PCB: Number of raw connection PCBs (requires the LWIP_RAW option) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a2c416da481ab09bd1ba257b75a0707eb">MEMP_NUM_UDP_PCB</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks.  <a href="#a2c416da481ab09bd1ba257b75a0707eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a73beecc19cfbc3114768f9b32b2cd70e">MEMP_NUM_TCP_PCB</a>&#160;&#160;&#160;5</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.  <a href="#a73beecc19cfbc3114768f9b32b2cd70e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a04fba6a249123513271dccb4ec26aa5a">MEMP_NUM_TCP_PCB_LISTEN</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.  <a href="#a04fba6a249123513271dccb4ec26aa5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aa35fb3a1a76661e3ffb9722a57092de3">MEMP_NUM_TCP_SEG</a>&#160;&#160;&#160;16</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.  <a href="#aa35fb3a1a76661e3ffb9722a57092de3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a169436c5860253b90e25bdba9fdcac86"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_REASSDATA" ref="a169436c5860253b90e25bdba9fdcac86" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a169436c5860253b90e25bdba9fdcac86">MEMP_NUM_REASSDATA</a>&#160;&#160;&#160;5</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_REASSDATA: the number of simultaneously IP packets queued for reassembly (whole packets, not fragments!) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a087b00ea20a7edebcad33a1a1353a5d7">MEMP_NUM_ARP_QUEUE</a>&#160;&#160;&#160;30</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing packets (pbufs) that are waiting for an ARP request (to resolve their destination address) to finish.  <a href="#a087b00ea20a7edebcad33a1a1353a5d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ab648ff95d8ffa4216b95f82a568a5d9a">MEMP_NUM_IGMP_GROUP</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces can be members et the same time (one per netif - allsystems group -, plus one per netif membership).  <a href="#ab648ff95d8ffa4216b95f82a568a5d9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a4afbdca581a58d57bc7a81118a95327e">MEMP_NUM_SYS_TIMEOUT</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.  <a href="#a4afbdca581a58d57bc7a81118a95327e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a5d99df65869ac101ed6a611fc85016be">MEMP_NUM_NETBUF</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_NETBUF: the number of struct netbufs.  <a href="#a5d99df65869ac101ed6a611fc85016be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#acb40bd726b7e15593b20a628d298f456">MEMP_NUM_NETCONN</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_NETCONN: the number of struct netconns.  <a href="#acb40bd726b7e15593b20a628d298f456"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#afbbfd6ce8536038cd00fa85bebae987c">MEMP_NUM_TCPIP_MSG_API</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used for callback/timeout API communication.  <a href="#afbbfd6ce8536038cd00fa85bebae987c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ab089a7088439e726c3801ba9e249d831">MEMP_NUM_TCPIP_MSG_INPKT</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used for incoming packets.  <a href="#ab089a7088439e726c3801ba9e249d831"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50eaadc4cad0716410332691e382c38a"></a><!-- doxytag: member="cfg_lwip.h::PBUF_POOL_SIZE" ref="a50eaadc4cad0716410332691e382c38a" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a50eaadc4cad0716410332691e382c38a">PBUF_POOL_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PBUF_POOL_SIZE: the number of buffers in the pbuf pool. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9609a014bba4638cc191d6a8f9556c87"></a><!-- doxytag: member="cfg_lwip.h::LWIP_ARP" ref="a9609a014bba4638cc191d6a8f9556c87" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a9609a014bba4638cc191d6a8f9556c87">LWIP_ARP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_ARP==1: Enable ARP functionality. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924936a814564dbdb0bc950d255a83b9"></a><!-- doxytag: member="cfg_lwip.h::ARP_TABLE_SIZE" ref="a924936a814564dbdb0bc950d255a83b9" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a924936a814564dbdb0bc950d255a83b9">ARP_TABLE_SIZE</a>&#160;&#160;&#160;10</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75837814536af29b6102508588d0ab58"></a><!-- doxytag: member="cfg_lwip.h::ARP_QUEUEING" ref="a75837814536af29b6102508588d0ab58" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a75837814536af29b6102508588d0ab58">ARP_QUEUEING</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ARP_QUEUEING==1: Outgoing packets are queued during hardware address resolution. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a5348b198e7e7b447cbe714913895e924">ETHARP_TRUST_IP_MAC</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be updated with the source MAC and IP addresses supplied in the packet.  <a href="#a5348b198e7e7b447cbe714913895e924"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a70ce0ecf56cf5fab000134e66d863f90">ETHARP_SUPPORT_VLAN</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header.  <a href="#a70ce0ecf56cf5fab000134e66d863f90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a881d32ff5ee02af01f758953f1b51d59">IP_FORWARD</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_FORWARD==1: Enables the ability to forward IP packets across network interfaces.  <a href="#a881d32ff5ee02af01f758953f1b51d59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aa956b0167c37a2265b55e2d0204a3933">IP_OPTIONS_ALLOWED</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_OPTIONS_ALLOWED: Defines the behavior for IP options.  <a href="#aa956b0167c37a2265b55e2d0204a3933"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a31ab0e0f37b17d40fa7c35bc2c4f69"></a><!-- doxytag: member="cfg_lwip.h::IP_REASSEMBLY" ref="a1a31ab0e0f37b17d40fa7c35bc2c4f69" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a1a31ab0e0f37b17d40fa7c35bc2c4f69">IP_REASSEMBLY</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassemble incoming fragmented IP packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af85c8bdd5035b6cada790b4cc2a209a4"></a><!-- doxytag: member="cfg_lwip.h::IP_FRAG" ref="af85c8bdd5035b6cada790b4cc2a209a4" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#af85c8bdd5035b6cada790b4cc2a209a4">IP_FRAG</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragment outgoing IP packets if their size exceeds MTU. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ad41122bd0b5485a18a4415c8f953727b">IP_REASS_MAXAGE</a>&#160;&#160;&#160;3</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally) a fragmented IP packet waits for all fragments to arrive.  <a href="#ad41122bd0b5485a18a4415c8f953727b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a29084a46d7d4be30e8029d356bca0394">IP_REASS_MAX_PBUFS</a>&#160;&#160;&#160;10</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.  <a href="#a29084a46d7d4be30e8029d356bca0394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#acf9edad9d50d86009044946e6db38c01">IP_FRAG_USES_STATIC_BUF</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP fragmentation.  <a href="#acf9edad9d50d86009044946e6db38c01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6466f88de7ed5d3113bd670cacb1676b"></a><!-- doxytag: member="cfg_lwip.h::IP_FRAG_MAX_MTU" ref="a6466f88de7ed5d3113bd670cacb1676b" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a6466f88de7ed5d3113bd670cacb1676b">IP_FRAG_MAX_MTU</a>&#160;&#160;&#160;1500</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer (requires IP_FRAG_USES_STATIC_BUF==1) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a556b9b58fd02c0fdd126791baef77411"></a><!-- doxytag: member="cfg_lwip.h::IP_DEFAULT_TTL" ref="a556b9b58fd02c0fdd126791baef77411" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a556b9b58fd02c0fdd126791baef77411">IP_DEFAULT_TTL</a>&#160;&#160;&#160;255</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a0b2c993fd940f5774108298933310384">IP_SOF_BROADCAST</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast filter per pcb on udp and raw send operations.  <a href="#a0b2c993fd940f5774108298933310384"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f1fbf42d3344bf87cd056d48ddca3db"></a><!-- doxytag: member="cfg_lwip.h::IP_SOF_BROADCAST_RECV" ref="a0f1fbf42d3344bf87cd056d48ddca3db" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a0f1fbf42d3344bf87cd056d48ddca3db">IP_SOF_BROADCAST_RECV</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast filter on recv operations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4d45345c3ab8e5a355fda1d8d24fca6"></a><!-- doxytag: member="cfg_lwip.h::LWIP_ICMP" ref="ae4d45345c3ab8e5a355fda1d8d24fca6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae4d45345c3ab8e5a355fda1d8d24fca6">LWIP_ICMP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable ICMP module inside the IP stack. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1533f2bc39a5843989909555f6ce0cf"></a><!-- doxytag: member="cfg_lwip.h::ICMP_TTL" ref="ae1533f2bc39a5843989909555f6ce0cf" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae1533f2bc39a5843989909555f6ce0cf">ICMP_TTL</a>&#160;&#160;&#160;(IP_DEFAULT_TTL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ICMP_TTL: Default value for Time-To-Live used by ICMP packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8088cb56d1a84fe554b11bc15d84b2b9"></a><!-- doxytag: member="cfg_lwip.h::LWIP_BROADCAST_PING" ref="a8088cb56d1a84fe554b11bc15d84b2b9" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8088cb56d1a84fe554b11bc15d84b2b9">LWIP_BROADCAST_PING</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af77baf0a83b04312eab4c006ef229661"></a><!-- doxytag: member="cfg_lwip.h::LWIP_MULTICAST_PING" ref="af77baf0a83b04312eab4c006ef229661" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#af77baf0a83b04312eab4c006ef229661">LWIP_MULTICAST_PING</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca452be5cb05d9666f8f57e582c39221"></a><!-- doxytag: member="cfg_lwip.h::LWIP_RAW" ref="aca452be5cb05d9666f8f57e582c39221" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aca452be5cb05d9666f8f57e582c39221">LWIP_RAW</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable application layer to hook into the IP layer itself. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36e3ffa66073ca0d27d11c422778249c"></a><!-- doxytag: member="cfg_lwip.h::RAW_TTL" ref="a36e3ffa66073ca0d27d11c422778249c" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a36e3ffa66073ca0d27d11c422778249c">RAW_TTL</a>&#160;&#160;&#160;(IP_DEFAULT_TTL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_RAW==1: Enable application layer to hook into the IP layer itself. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8a6ec62dc121064ac591b1fd8567bee9">LWIP_DHCP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable DHCP module.  <a href="#a8a6ec62dc121064ac591b1fd8567bee9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2d91de7b2fce879b0a213682e1b0b69"></a><!-- doxytag: member="cfg_lwip.h::DHCP_DOES_ARP_CHECK" ref="ab2d91de7b2fce879b0a213682e1b0b69" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ab2d91de7b2fce879b0a213682e1b0b69">DHCP_DOES_ARP_CHECK</a>&#160;&#160;&#160;((LWIP_DHCP) &amp;&amp; (LWIP_ARP))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf1b3a089827223589baf1b7f4f57069"></a><!-- doxytag: member="cfg_lwip.h::LWIP_AUTOIP" ref="aaf1b3a089827223589baf1b7f4f57069" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aaf1b3a089827223589baf1b7f4f57069">LWIP_AUTOIP</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_AUTOIP==1: Enable AUTOIP module. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a91e18dbb9777bc6e3963f52cb5f9fe"></a><!-- doxytag: member="cfg_lwip.h::LWIP_DHCP_AUTOIP_COOP" ref="a1a91e18dbb9777bc6e3963f52cb5f9fe" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a1a91e18dbb9777bc6e3963f52cb5f9fe">LWIP_DHCP_AUTOIP_COOP</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on the same interface at the same time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a4ff3f941b4c71a04b0c30fbee5b198c2">LWIP_DHCP_AUTOIP_COOP_TRIES</a>&#160;&#160;&#160;9</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes that should be sent before falling back on AUTOIP.  <a href="#a4ff3f941b4c71a04b0c30fbee5b198c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#af4900859dc53f19f5f67cc34e48ad68c">LWIP_SNMP</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on SNMP module.  <a href="#af4900859dc53f19f5f67cc34e48ad68c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aff91bbf0295767f430f32d82f5ff48a1">SNMP_CONCURRENT_REQUESTS</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will allow.  <a href="#aff91bbf0295767f430f32d82f5ff48a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a692343b0cc555c302fd713003d4f8a08">SNMP_TRAP_DESTINATIONS</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SNMP_TRAP_DESTINATIONS: Number of trap destinations.  <a href="#a692343b0cc555c302fd713003d4f8a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefb09da08c94a93e58e6a726a9c346d0"></a><!-- doxytag: member="cfg_lwip.h::SNMP_PRIVATE_MIB" ref="aefb09da08c94a93e58e6a726a9c346d0" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aefb09da08c94a93e58e6a726a9c346d0">SNMP_PRIVATE_MIB</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SNMP_PRIVATE_MIB: <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a95e39047b9bcb385780b06b35af49261">SNMP_SAFE_REQUESTS</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Only allow SNMP write actions that are 'safe' (e.g.  <a href="#a95e39047b9bcb385780b06b35af49261"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaf25915ae1fd69c0943ef68cbb38923"></a><!-- doxytag: member="cfg_lwip.h::LWIP_IGMP" ref="adaf25915ae1fd69c0943ef68cbb38923" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#adaf25915ae1fd69c0943ef68cbb38923">LWIP_IGMP</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on IGMP module. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a98710dd81446b7cb2daac736bae6f646">LWIP_DNS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on DNS module.  <a href="#a98710dd81446b7cb2daac736bae6f646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a2384e76c1acdf969d883f3de08d340f7">DNS_TABLE_SIZE</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS maximum number of entries to maintain locally.  <a href="#a2384e76c1acdf969d883f3de08d340f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a3b01c79902063c170ef57deb72f56124">DNS_MAX_NAME_LENGTH</a>&#160;&#160;&#160;256</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS maximum host name length supported in the name table.  <a href="#a3b01c79902063c170ef57deb72f56124"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f9881c887a8aceb9765820c2dbdf292"></a><!-- doxytag: member="cfg_lwip.h::DNS_MAX_SERVERS" ref="a9f9881c887a8aceb9765820c2dbdf292" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a9f9881c887a8aceb9765820c2dbdf292">DNS_MAX_SERVERS</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum of DNS servers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a07ffd8e9106dae3b65347bd03811a4b6">DNS_DOES_NAME_CHECK</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS do a name checking between the query and the response.  <a href="#a07ffd8e9106dae3b65347bd03811a4b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a60a549132d931208028403376918fc90">DNS_USES_STATIC_BUF</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS use a local buffer if DNS_USES_STATIC_BUF=0, a static one if DNS_USES_STATIC_BUF=1, or a dynamic one if DNS_USES_STATIC_BUF=2.  <a href="#a60a549132d931208028403376918fc90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#af489bec6d82ce1a8cfc08dfd0bd25767">DNS_MSG_SIZE</a>&#160;&#160;&#160;512</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS message max.  <a href="#af489bec6d82ce1a8cfc08dfd0bd25767"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#acba1ac491c1b47b98dfbd0d5c1662659">DNS_LOCAL_HOSTLIST</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS_LOCAL_HOSTLIST: Implements a local host-to-address list.  <a href="#acba1ac491c1b47b98dfbd0d5c1662659"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8235a5fb0a1c1cceeee670cf95612ba8">DNS_LOCAL_HOSTLIST_IS_DYNAMIC</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If this is turned on, the local host-list can be dynamically changed at runtime.  <a href="#a8235a5fb0a1c1cceeee670cf95612ba8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6030e96e72df649d2650fd32d7a67b3"></a><!-- doxytag: member="cfg_lwip.h::LWIP_UDP" ref="ab6030e96e72df649d2650fd32d7a67b3" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ab6030e96e72df649d2650fd32d7a67b3">LWIP_UDP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on UDP. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a35731bc5f337943e474a15c1cd538a61">LWIP_UDPLITE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_UDPLITE==1: Turn on UDP-Lite.  <a href="#a35731bc5f337943e474a15c1cd538a61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97908a317bcba89174b5d1ccbdca0096"></a><!-- doxytag: member="cfg_lwip.h::UDP_TTL" ref="a97908a317bcba89174b5d1ccbdca0096" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a97908a317bcba89174b5d1ccbdca0096">UDP_TTL</a>&#160;&#160;&#160;(IP_DEFAULT_TTL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">UDP_TTL: Default Time-To-Live value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72021505969c5ce29e972486d7794baa"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETBUF_RECVINFO" ref="a72021505969c5ce29e972486d7794baa" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a72021505969c5ce29e972486d7794baa">LWIP_NETBUF_RECVINFO</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4ed98deb97b77c633cb8870f34c71e9"></a><!-- doxytag: member="cfg_lwip.h::LWIP_TCP" ref="aa4ed98deb97b77c633cb8870f34c71e9" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aa4ed98deb97b77c633cb8870f34c71e9">LWIP_TCP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on TCP. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd5b25ea81d2894790d25da5393cdab4"></a><!-- doxytag: member="cfg_lwip.h::TCP_TTL" ref="acd5b25ea81d2894790d25da5393cdab4" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#acd5b25ea81d2894790d25da5393cdab4">TCP_TTL</a>&#160;&#160;&#160;(IP_DEFAULT_TTL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_TTL: Default Time-To-Live value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a7f535a6efb5cdf86c3210e35ece1d6a7">TCP_WND</a>&#160;&#160;&#160;(4 * TCP_MSS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_WND: The size of a TCP window.  <a href="#a7f535a6efb5cdf86c3210e35ece1d6a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dee0911197855bdf19ef79778c241a6"></a><!-- doxytag: member="cfg_lwip.h::TCP_MAXRTX" ref="a0dee0911197855bdf19ef79778c241a6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a0dee0911197855bdf19ef79778c241a6">TCP_MAXRTX</a>&#160;&#160;&#160;12</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_MAXRTX: Maximum number of retransmissions of data segments. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50b434a8541a4813f7b27f576c05d1b6"></a><!-- doxytag: member="cfg_lwip.h::TCP_SYNMAXRTX" ref="a50b434a8541a4813f7b27f576c05d1b6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a50b434a8541a4813f7b27f576c05d1b6">TCP_SYNMAXRTX</a>&#160;&#160;&#160;6</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a89ffd0d7d1529bdb26bfbad267d0ad75">TCP_QUEUE_OOSEQ</a>&#160;&#160;&#160;(LWIP_TCP)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.  <a href="#a89ffd0d7d1529bdb26bfbad267d0ad75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#af1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>&#160;&#160;&#160;536</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_MSS: TCP Maximum segment size.  <a href="#af1ab7bb27860aa3677c387a2f3ba317b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac04b84d32251ac558f0c3a8af85ba3a5"></a><!-- doxytag: member="cfg_lwip.h::TCP_CALCULATE_EFF_SEND_MSS" ref="ac04b84d32251ac558f0c3a8af85ba3a5" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ac04b84d32251ac558f0c3a8af85ba3a5">TCP_CALCULATE_EFF_SEND_MSS</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which reflects the available reassembly buffer size at the remote host) and the largest size permitted by the IP layer" (RFC 1122) Setting this to 1 enables code that checks TCP_MSS against the MTU of the netif used for a connection and limits the MSS if it would be too big otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a871d111968d8c6c7880ff36b93c5c4dd"></a><!-- doxytag: member="cfg_lwip.h::TCP_SND_BUF" ref="a871d111968d8c6c7880ff36b93c5c4dd" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a871d111968d8c6c7880ff36b93c5c4dd">TCP_SND_BUF</a>&#160;&#160;&#160;(2 * TCP_MSS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_SND_BUF: TCP sender buffer space (bytes). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>&#160;&#160;&#160;(4 * (TCP_SND_BUF)/(TCP_MSS))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_SND_QUEUELEN: TCP sender buffer space (pbufs).  <a href="#a9beaa47832ead4180981bfbf71074904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae5c9866d7cd463ac7b36792182145aec">TCP_SNDLOWAT</a>&#160;&#160;&#160;((TCP_SND_BUF)/2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_SNDLOWAT: TCP writable space (bytes).  <a href="#ae5c9866d7cd463ac7b36792182145aec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98b23e7cbd3281915c50a485cb61899d"></a><!-- doxytag: member="cfg_lwip.h::TCP_LISTEN_BACKLOG" ref="a98b23e7cbd3281915c50a485cb61899d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a98b23e7cbd3281915c50a485cb61899d">TCP_LISTEN_BACKLOG</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a93cce3f47e33df11248c908d1775bacf">TCP_DEFAULT_LISTEN_BACKLOG</a>&#160;&#160;&#160;0xff</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum allowed backlog for TCP listen netconns.  <a href="#a93cce3f47e33df11248c908d1775bacf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a249bc450bb818cf2ef3cf1472ff354fd"></a><!-- doxytag: member="cfg_lwip.h::LWIP_TCP_TIMESTAMPS" ref="a249bc450bb818cf2ef3cf1472ff354fd" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a249bc450bb818cf2ef3cf1472ff354fd">LWIP_TCP_TIMESTAMPS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d45732ba3a8438b141096d86e07ef8d"></a><!-- doxytag: member="cfg_lwip.h::TCP_WND_UPDATE_THRESHOLD" ref="a5d45732ba3a8438b141096d86e07ef8d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a5d45732ba3a8438b141096d86e07ef8d">TCP_WND_UPDATE_THRESHOLD</a>&#160;&#160;&#160;(TCP_WND / 4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an explicit window update. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a35998a3d56af9940e6a80bb372597685">PBUF_LINK_HLEN</a>&#160;&#160;&#160;14</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PBUF_LINK_HLEN: the number of bytes that should be allocated for a link level header.  <a href="#a35998a3d56af9940e6a80bb372597685"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae61f4491d56e805e79b79eb5d35a00e5">PBUF_POOL_BUFSIZE</a>&#160;&#160;&#160;LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool.  <a href="#ae61f4491d56e805e79b79eb5d35a00e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa714dbfa66822ec4c6111bdb8cf753c1"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETIF_HOSTNAME" ref="aa714dbfa66822ec4c6111bdb8cf753c1" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aa714dbfa66822ec4c6111bdb8cf753c1">LWIP_NETIF_HOSTNAME</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use DHCP_OPTION_HOSTNAME with netif's hostname field. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#add45fb65f2d0e6de5a0d14ff9e101b77">LWIP_NETIF_API</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Support netif api (in netifapi.c)  <a href="#add45fb65f2d0e6de5a0d14ff9e101b77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affb97d89516c38d3fcb9e44e5d707f36"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETIF_STATUS_CALLBACK" ref="affb97d89516c38d3fcb9e44e5d707f36" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#affb97d89516c38d3fcb9e44e5d707f36">LWIP_NETIF_STATUS_CALLBACK</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface changes its up/down status (i.e., due to DHCP IP acquistion) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a446932dd927cc4136ba654c13bb97b"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETIF_LINK_CALLBACK" ref="a1a446932dd927cc4136ba654c13bb97b" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a1a446932dd927cc4136ba654c13bb97b">LWIP_NETIF_LINK_CALLBACK</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface whenever the link changes (i.e., link down) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ad1d5e878d94b56ba687cef69be936ad9">LWIP_NETIF_HWADDRHINT</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g.  <a href="#ad1d5e878d94b56ba687cef69be936ad9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a724a0ea765d5a47d026d529725f31c01"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETIF_LOOPBACK" ref="a724a0ea765d5a47d026d529725f31c01" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a724a0ea765d5a47d026d529725f31c01">LWIP_NETIF_LOOPBACK</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP address equal to the netif IP address, looping them back up the stack. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacc3ad5d0a771d45fb0a3e3a09b1dbea"></a><!-- doxytag: member="cfg_lwip.h::LWIP_LOOPBACK_MAX_PBUFS" ref="aacc3ad5d0a771d45fb0a3e3a09b1dbea" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aacc3ad5d0a771d45fb0a3e3a09b1dbea">LWIP_LOOPBACK_MAX_PBUFS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback sending for each netif (0 = disabled) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aa28d13ddd5281b1912276991e7ea58c5">LWIP_NETIF_LOOPBACK_MULTITHREADING</a>&#160;&#160;&#160;(!NO_SYS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in the system, as netifs must change how they behave depending on this setting for the LWIP_NETIF_LOOPBACK option to work.  <a href="#aa28d13ddd5281b1912276991e7ea58c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#abafb9f64a80e51b56c0abbcfc1f7e04e">LWIP_NETIF_TX_SINGLE_PBUF</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data to be sent into one single pbuf.  <a href="#abafb9f64a80e51b56c0abbcfc1f7e04e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aa2b1f736373cd896e212644aa453fbaf">LWIP_HAVE_LOOPIF</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Support loop interface (127.0.0.1) and loopif.c.  <a href="#aa2b1f736373cd896e212644aa453fbaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a6138031a260945ca1ed17f81b8efe5c8">LWIP_HAVE_SLIPIF</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Support slip interface and slipif.c.  <a href="#a6138031a260945ca1ed17f81b8efe5c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a405e604e4328e1feb878c6fe1798a587"></a><!-- doxytag: member="cfg_lwip.h::TCPIP_THREAD_NAME" ref="a405e604e4328e1feb878c6fe1798a587" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a405e604e4328e1feb878c6fe1798a587">TCPIP_THREAD_NAME</a>&#160;&#160;&#160;&quot;tcpip_thread&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCPIP_THREAD_NAME: The name assigned to the main tcpip thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aa02b84eafa0c8b09b158b97c96d79db0">TCPIP_THREAD_STACKSIZE</a>&#160;&#160;&#160;(KERN_MINSTACKSIZE * 3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.  <a href="#aa02b84eafa0c8b09b158b97c96d79db0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a42b2c7a3042d7c3efd00f367f5837435">TCPIP_THREAD_PRIO</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.  <a href="#a42b2c7a3042d7c3efd00f367f5837435"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cf210ad4e4bf616860a45fbd140fd06"></a><!-- doxytag: member="cfg_lwip.h::TCPIP_MBOX_SIZE" ref="a8cf210ad4e4bf616860a45fbd140fd06" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8cf210ad4e4bf616860a45fbd140fd06">TCPIP_MBOX_SIZE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when tcpip_init is called. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9cd260c56472324a2f0ee5f9597a675"></a><!-- doxytag: member="cfg_lwip.h::SLIPIF_THREAD_NAME" ref="ae9cd260c56472324a2f0ee5f9597a675" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae9cd260c56472324a2f0ee5f9597a675">SLIPIF_THREAD_NAME</a>&#160;&#160;&#160;&quot;slipif_loop&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae8ab54a25007ce997bbab6289815e258">SLIPIF_THREAD_STACKSIZE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.  <a href="#ae8ab54a25007ce997bbab6289815e258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ab1b9fc2efcbf1f804bfd0191bc019c4e">SLIPIF_THREAD_PRIO</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.  <a href="#ab1b9fc2efcbf1f804bfd0191bc019c4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba2fb885e8a11ac9077ed07a76a73696"></a><!-- doxytag: member="cfg_lwip.h::PPP_THREAD_NAME" ref="aba2fb885e8a11ac9077ed07a76a73696" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aba2fb885e8a11ac9077ed07a76a73696">PPP_THREAD_NAME</a>&#160;&#160;&#160;&quot;pppMain&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PPP_THREAD_NAME: The name assigned to the pppMain thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aad646d19911779f154c22b74f5cac723">PPP_THREAD_STACKSIZE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PPP_THREAD_STACKSIZE: The stack size used by the pppMain thread.  <a href="#aad646d19911779f154c22b74f5cac723"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a4e4f66814257c3ee5a74abc67e5fd918">PPP_THREAD_PRIO</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PPP_THREAD_PRIO: The priority assigned to the pppMain thread.  <a href="#a4e4f66814257c3ee5a74abc67e5fd918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca13123a5c8271558353e04123957616"></a><!-- doxytag: member="cfg_lwip.h::DEFAULT_THREAD_NAME" ref="aca13123a5c8271558353e04123957616" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aca13123a5c8271558353e04123957616">DEFAULT_THREAD_NAME</a>&#160;&#160;&#160;&quot;lwIP&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a7f93dfeaed4021061959f822def602cb">DEFAULT_THREAD_STACKSIZE</a>&#160;&#160;&#160;(KERN_MINSTACKSIZE * 3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.  <a href="#a7f93dfeaed4021061959f822def602cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a3d8715b1fdd0449d6c214e4a40108456">DEFAULT_THREAD_PRIO</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.  <a href="#a3d8715b1fdd0449d6c214e4a40108456"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a4ef8f046c957750056131310a1580df7">DEFAULT_RAW_RECVMBOX_SIZE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_RAW.  <a href="#a4ef8f046c957750056131310a1580df7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a09fe785559b3f0cf108da4440489e335">DEFAULT_UDP_RECVMBOX_SIZE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_UDP.  <a href="#a09fe785559b3f0cf108da4440489e335"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a1bd172938b9c8ba63156fcafc87e83c7">DEFAULT_TCP_RECVMBOX_SIZE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_TCP.  <a href="#a1bd172938b9c8ba63156fcafc87e83c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a5d5a6e04abe2ec233c7acdb09f992461">DEFAULT_ACCEPTMBOX_SIZE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.  <a href="#a5d5a6e04abe2ec233c7acdb09f992461"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e46232794349c209e8ed4e9e7e4f011"></a><!-- doxytag: member="cfg_lwip.h::LWIP_TCPIP_CORE_LOCKING" ref="a8e46232794349c209e8ed4e9e7e4f011" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8e46232794349c209e8ed4e9e7e4f011">LWIP_TCPIP_CORE_LOCKING</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!) Don't use it if you're not an active lwIP project member. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a478041b8544461258f6961bf0f3c1a77">LWIP_NETCONN</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Netconn API (require to use api_lib.c)  <a href="#a478041b8544461258f6961bf0f3c1a77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a1cb62ce61ac39d7d6728ae5d3d3b927f">LWIP_SOCKET</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Socket API (require to use sockets.c)  <a href="#a1cb62ce61ac39d7d6728ae5d3d3b927f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#afed2811f031822ec5afa1ee211fb7447">LWIP_COMPAT_SOCKETS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable BSD-style sockets functions names.  <a href="#afed2811f031822ec5afa1ee211fb7447"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a484c38ab08f60d5b3335d23d31f9a402">LWIP_POSIX_SOCKETS_IO_NAMES</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.  <a href="#a484c38ab08f60d5b3335d23d31f9a402"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8b9369ab260f032686a81c77c5b4db77">LWIP_TCP_KEEPALIVE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT options processing.  <a href="#a8b9369ab260f032686a81c77c5b4db77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91af3ade95b20b9a60c65ed0380fa0ed"></a><!-- doxytag: member="cfg_lwip.h::LWIP_SO_RCVTIMEO" ref="a91af3ade95b20b9a60c65ed0380fa0ed" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a91af3ade95b20b9a60c65ed0380fa0ed">LWIP_SO_RCVTIMEO</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_SO_RCVTIMEO==1: Enable SO_RCVTIMEO processing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06390cebcf4d13d3d47a11365e5fcd28"></a><!-- doxytag: member="cfg_lwip.h::LWIP_SO_RCVBUF" ref="a06390cebcf4d13d3d47a11365e5fcd28" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a06390cebcf4d13d3d47a11365e5fcd28">LWIP_SO_RCVBUF</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dbd0a61f30ae6c6bfbda635095f138d"></a><!-- doxytag: member="cfg_lwip.h::RECV_BUFSIZE_DEFAULT" ref="a5dbd0a61f30ae6c6bfbda635095f138d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a5dbd0a61f30ae6c6bfbda635095f138d">RECV_BUFSIZE_DEFAULT</a>&#160;&#160;&#160;INT_MAX</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#af3822feed320cf8439b083ee525e4942">SO_REUSE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SO_REUSE==1: Enable SO_REUSEADDR and SO_REUSEPORT options.  <a href="#af3822feed320cf8439b083ee525e4942"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a542b58734cc01902c5e099f6efdc5f1b"></a><!-- doxytag: member="cfg_lwip.h::LWIP_STATS" ref="a542b58734cc01902c5e099f6efdc5f1b" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a542b58734cc01902c5e099f6efdc5f1b">LWIP_STATS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_STATS==1: Enable statistics collection in lwip_stats. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a746c0ebaef5399987d53a1426eba6273"></a><!-- doxytag: member="cfg_lwip.h::PPP_SUPPORT" ref="a746c0ebaef5399987d53a1426eba6273" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a746c0ebaef5399987d53a1426eba6273">PPP_SUPPORT</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable PPP. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71adab1a13b02856a922cf3edbda71b1"></a><!-- doxytag: member="cfg_lwip.h::PPPOE_SUPPORT" ref="a71adab1a13b02856a922cf3edbda71b1" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a71adab1a13b02856a922cf3edbda71b1">PPPOE_SUPPORT</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable PPP Over Ethernet. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade11e60136d3d55e35f917f155dc13b9"></a><!-- doxytag: member="cfg_lwip.h::PPPOS_SUPPORT" ref="ade11e60136d3d55e35f917f155dc13b9" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ade11e60136d3d55e35f917f155dc13b9">PPPOS_SUPPORT</a>&#160;&#160;&#160;PPP_SUPPORT</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PPPOS_SUPPORT==1: Enable PPP Over <a class="el" href="structSerial.html" title="Serial handle structure.">Serial</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ddad81fc26268a13b35091781da2265"></a><!-- doxytag: member="cfg_lwip.h::CHECKSUM_GEN_IP" ref="a8ddad81fc26268a13b35091781da2265" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8ddad81fc26268a13b35091781da2265">CHECKSUM_GEN_IP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98d460f8c2baed8bf62d5473831c0b2c"></a><!-- doxytag: member="cfg_lwip.h::CHECKSUM_GEN_UDP" ref="a98d460f8c2baed8bf62d5473831c0b2c" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a98d460f8c2baed8bf62d5473831c0b2c">CHECKSUM_GEN_UDP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a800069963cc4552b99235237c22f00bb"></a><!-- doxytag: member="cfg_lwip.h::CHECKSUM_GEN_TCP" ref="a800069963cc4552b99235237c22f00bb" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a800069963cc4552b99235237c22f00bb">CHECKSUM_GEN_TCP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a005b1b9988b84a2cb844144cef22c11e"></a><!-- doxytag: member="cfg_lwip.h::CHECKSUM_CHECK_IP" ref="a005b1b9988b84a2cb844144cef22c11e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a005b1b9988b84a2cb844144cef22c11e">CHECKSUM_CHECK_IP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6747f7b72abe544fd4dc184cc7fcad37"></a><!-- doxytag: member="cfg_lwip.h::CHECKSUM_CHECK_UDP" ref="a6747f7b72abe544fd4dc184cc7fcad37" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a6747f7b72abe544fd4dc184cc7fcad37">CHECKSUM_CHECK_UDP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab676cc29571b7ffda12336482ad97699"></a><!-- doxytag: member="cfg_lwip.h::CHECKSUM_CHECK_TCP" ref="ab676cc29571b7ffda12336482ad97699" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ab676cc29571b7ffda12336482ad97699">CHECKSUM_CHECK_TCP</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a2043f599515774f8e571ba185dbcb9e7">LWIP_DBG_MIN_LEVEL</a>&#160;&#160;&#160;LWIP_DBG_LEVEL_ALL</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is compared against this value.  <a href="#a2043f599515774f8e571ba185dbcb9e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac095d0e53f5eb5b326b2cccfd071d93d"></a><!-- doxytag: member="cfg_lwip.h::LWIP_DBG_TYPES_ON" ref="ac095d0e53f5eb5b326b2cccfd071d93d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ac095d0e53f5eb5b326b2cccfd071d93d">LWIP_DBG_TYPES_ON</a>&#160;&#160;&#160;LWIP_DBG_ON</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable debug messages of certain types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abff5d1e0b334f5b45bd2b8bbb675411e"></a><!-- doxytag: member="cfg_lwip.h::ETHARP_DEBUG" ref="abff5d1e0b334f5b45bd2b8bbb675411e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#abff5d1e0b334f5b45bd2b8bbb675411e">ETHARP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ETHARP_DEBUG: Enable debugging in etharp.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dfad02b075a7f9a8791a66fe40864a4"></a><!-- doxytag: member="cfg_lwip.h::NETIF_DEBUG" ref="a2dfad02b075a7f9a8791a66fe40864a4" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a2dfad02b075a7f9a8791a66fe40864a4">NETIF_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NETIF_DEBUG: Enable debugging in netif.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c3d44a0ec3bb8bd66f776c70d5c6a6c"></a><!-- doxytag: member="cfg_lwip.h::PBUF_DEBUG" ref="a5c3d44a0ec3bb8bd66f776c70d5c6a6c" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a5c3d44a0ec3bb8bd66f776c70d5c6a6c">PBUF_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PBUF_DEBUG: Enable debugging in pbuf.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a671009550216f7dc03e67ba5751e3160"></a><!-- doxytag: member="cfg_lwip.h::API_LIB_DEBUG" ref="a671009550216f7dc03e67ba5751e3160" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a671009550216f7dc03e67ba5751e3160">API_LIB_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">API_LIB_DEBUG: Enable debugging in api_lib.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4279d7ff9f986b2ff3eb068bb012b697"></a><!-- doxytag: member="cfg_lwip.h::API_MSG_DEBUG" ref="a4279d7ff9f986b2ff3eb068bb012b697" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a4279d7ff9f986b2ff3eb068bb012b697">API_MSG_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">API_MSG_DEBUG: Enable debugging in api_msg.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a509594f3ba7d8b1356628b50b55a0934"></a><!-- doxytag: member="cfg_lwip.h::SOCKETS_DEBUG" ref="a509594f3ba7d8b1356628b50b55a0934" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a509594f3ba7d8b1356628b50b55a0934">SOCKETS_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SOCKETS_DEBUG: Enable debugging in sockets.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9595904a1cb9bfe0b9b1d958abdc923a"></a><!-- doxytag: member="cfg_lwip.h::ICMP_DEBUG" ref="a9595904a1cb9bfe0b9b1d958abdc923a" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a9595904a1cb9bfe0b9b1d958abdc923a">ICMP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ICMP_DEBUG: Enable debugging in icmp.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8da07508ee75704362d45eee3eb857fa"></a><!-- doxytag: member="cfg_lwip.h::IGMP_DEBUG" ref="a8da07508ee75704362d45eee3eb857fa" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a8da07508ee75704362d45eee3eb857fa">IGMP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IGMP_DEBUG: Enable debugging in igmp.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78140cbe70258a65cb5c9e381843e4f3"></a><!-- doxytag: member="cfg_lwip.h::INET_DEBUG" ref="a78140cbe70258a65cb5c9e381843e4f3" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a78140cbe70258a65cb5c9e381843e4f3">INET_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">INET_DEBUG: Enable debugging in inet.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d3348778951e7bc5cd397c6575eef3a"></a><!-- doxytag: member="cfg_lwip.h::IP_DEBUG" ref="a5d3348778951e7bc5cd397c6575eef3a" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a5d3348778951e7bc5cd397c6575eef3a">IP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_DEBUG: Enable debugging for IP. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cdc3e9a4a1c01d1f7f0e723a1b2ec33"></a><!-- doxytag: member="cfg_lwip.h::IP_REASS_DEBUG" ref="a4cdc3e9a4a1c01d1f7f0e723a1b2ec33" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a4cdc3e9a4a1c01d1f7f0e723a1b2ec33">IP_REASS_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag &amp; reass. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0551bef83c0fc1baa57cf339d220e25"></a><!-- doxytag: member="cfg_lwip.h::RAW_DEBUG" ref="af0551bef83c0fc1baa57cf339d220e25" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#af0551bef83c0fc1baa57cf339d220e25">RAW_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RAW_DEBUG: Enable debugging in raw.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d7bc380695eeedb1af50c3808613afe"></a><!-- doxytag: member="cfg_lwip.h::MEM_DEBUG" ref="a2d7bc380695eeedb1af50c3808613afe" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a2d7bc380695eeedb1af50c3808613afe">MEM_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEM_DEBUG: Enable debugging in mem.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad80231923f7a808d49eba5ec57d63616"></a><!-- doxytag: member="cfg_lwip.h::MEMP_DEBUG" ref="ad80231923f7a808d49eba5ec57d63616" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ad80231923f7a808d49eba5ec57d63616">MEMP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MEMP_DEBUG: Enable debugging in memp.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2960ae20008f05da8cc0714f36365642"></a><!-- doxytag: member="cfg_lwip.h::SYS_DEBUG" ref="a2960ae20008f05da8cc0714f36365642" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a2960ae20008f05da8cc0714f36365642">SYS_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SYS_DEBUG: Enable debugging in sys.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f43bb8a430c7a52a1ad5086d3f2803c"></a><!-- doxytag: member="cfg_lwip.h::TCP_DEBUG" ref="a4f43bb8a430c7a52a1ad5086d3f2803c" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_DEBUG: Enable debugging for TCP. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af51dc2563536de56470146749f715ba8"></a><!-- doxytag: member="cfg_lwip.h::TCP_INPUT_DEBUG" ref="af51dc2563536de56470146749f715ba8" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#af51dc2563536de56470146749f715ba8">TCP_INPUT_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5895bee26e8e1a0b89d597e0f2580b23"></a><!-- doxytag: member="cfg_lwip.h::TCP_FR_DEBUG" ref="a5895bee26e8e1a0b89d597e0f2580b23" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a5895bee26e8e1a0b89d597e0f2580b23">TCP_FR_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6e52e37415d0d0cbe4931a28f5a9662"></a><!-- doxytag: member="cfg_lwip.h::TCP_RTO_DEBUG" ref="ad6e52e37415d0d0cbe4931a28f5a9662" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ad6e52e37415d0d0cbe4931a28f5a9662">TCP_RTO_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_RTO_DEBUG: Enable debugging in TCP for retransmit timeout. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66df03d8192cd978d3321a9d68bf5411"></a><!-- doxytag: member="cfg_lwip.h::TCP_CWND_DEBUG" ref="a66df03d8192cd978d3321a9d68bf5411" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a66df03d8192cd978d3321a9d68bf5411">TCP_CWND_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_CWND_DEBUG: Enable debugging for TCP congestion window. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3704f433e947d6342da77c74e33627e1"></a><!-- doxytag: member="cfg_lwip.h::TCP_WND_DEBUG" ref="a3704f433e947d6342da77c74e33627e1" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a3704f433e947d6342da77c74e33627e1">TCP_WND_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f70601fdc1feee490772bf7fcdb74fb"></a><!-- doxytag: member="cfg_lwip.h::TCP_OUTPUT_DEBUG" ref="a9f70601fdc1feee490772bf7fcdb74fb" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37596f7bbb9b7663826244ba54486679"></a><!-- doxytag: member="cfg_lwip.h::TCP_RST_DEBUG" ref="a37596f7bbb9b7663826244ba54486679" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a37596f7bbb9b7663826244ba54486679">TCP_RST_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_RST_DEBUG: Enable debugging for TCP with the RST message. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7980c7f8eb45cd411bf410ff0a3fc55"></a><!-- doxytag: member="cfg_lwip.h::TCP_QLEN_DEBUG" ref="ae7980c7f8eb45cd411bf410ff0a3fc55" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ae7980c7f8eb45cd411bf410ff0a3fc55">TCP_QLEN_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0393f312c5475a1c649b39ef9cfcaad4"></a><!-- doxytag: member="cfg_lwip.h::UDP_DEBUG" ref="a0393f312c5475a1c649b39ef9cfcaad4" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a0393f312c5475a1c649b39ef9cfcaad4">UDP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">UDP_DEBUG: Enable debugging in UDP. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52d6c83451936c3de3b0338d4a3f921f"></a><!-- doxytag: member="cfg_lwip.h::TCPIP_DEBUG" ref="a52d6c83451936c3de3b0338d4a3f921f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a52d6c83451936c3de3b0338d4a3f921f">TCPIP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCPIP_DEBUG: Enable debugging in tcpip.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a171a601fe1dedb676b3e7b11fb05ec72"></a><!-- doxytag: member="cfg_lwip.h::PPP_DEBUG" ref="a171a601fe1dedb676b3e7b11fb05ec72" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a171a601fe1dedb676b3e7b11fb05ec72">PPP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PPP_DEBUG: Enable debugging for PPP. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab986f95183559d8678c6d80969b01857"></a><!-- doxytag: member="cfg_lwip.h::SLIP_DEBUG" ref="ab986f95183559d8678c6d80969b01857" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ab986f95183559d8678c6d80969b01857">SLIP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SLIP_DEBUG: Enable debugging in slipif.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97927ceecabcdb5f41735bf372a05cee"></a><!-- doxytag: member="cfg_lwip.h::DHCP_DEBUG" ref="a97927ceecabcdb5f41735bf372a05cee" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a97927ceecabcdb5f41735bf372a05cee">DHCP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DHCP_DEBUG: Enable debugging in dhcp.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaee522e7f32d81022215e1805e303a5"></a><!-- doxytag: member="cfg_lwip.h::AUTOIP_DEBUG" ref="afaee522e7f32d81022215e1805e303a5" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#afaee522e7f32d81022215e1805e303a5">AUTOIP_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">AUTOIP_DEBUG: Enable debugging in autoip.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f7b7249593eb9c69ed206fe4e83fefd"></a><!-- doxytag: member="cfg_lwip.h::SNMP_MSG_DEBUG" ref="a9f7b7249593eb9c69ed206fe4e83fefd" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#a9f7b7249593eb9c69ed206fe4e83fefd">SNMP_MSG_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SNMP_MSG_DEBUG: Enable debugging for SNMP messages. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac12240265db443eaf9d31d187e586c16"></a><!-- doxytag: member="cfg_lwip.h::SNMP_MIB_DEBUG" ref="ac12240265db443eaf9d31d187e586c16" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#ac12240265db443eaf9d31d187e586c16">SNMP_MIB_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba55da2352c99d813767913e5e36be1f"></a><!-- doxytag: member="cfg_lwip.h::DNS_DEBUG" ref="aba55da2352c99d813767913e5e36be1f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cfg__lwip_8h.html#aba55da2352c99d813767913e5e36be1f">DNS_DEBUG</a>&#160;&#160;&#160;LWIP_DBG_OFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS_DEBUG: Enable debugging for DNS. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Configuration file for the lwIP TCP/IP stack module. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Andrea Righi &lt;<a href="mailto:arighi@develer.com">arighi@develer.com</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a5d5a6e04abe2ec233c7acdb09f992461"></a><!-- doxytag: member="cfg_lwip.h::DEFAULT_ACCEPTMBOX_SIZE" ref="a5d5a6e04abe2ec233c7acdb09f992461" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_ACCEPTMBOX_SIZE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections. </p>
<p>The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when the acceptmbox is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01175">1175</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4ef8f046c957750056131310a1580df7"></a><!-- doxytag: member="cfg_lwip.h::DEFAULT_RAW_RECVMBOX_SIZE" ref="a4ef8f046c957750056131310a1580df7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_RAW_RECVMBOX_SIZE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_RAW. </p>
<p>The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when the recvmbox is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01148">1148</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1bd172938b9c8ba63156fcafc87e83c7"></a><!-- doxytag: member="cfg_lwip.h::DEFAULT_TCP_RECVMBOX_SIZE" ref="a1bd172938b9c8ba63156fcafc87e83c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_TCP_RECVMBOX_SIZE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_TCP. </p>
<p>The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when the recvmbox is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01166">1166</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d8715b1fdd0449d6c214e4a40108456"></a><!-- doxytag: member="cfg_lwip.h::DEFAULT_THREAD_PRIO" ref="a3d8715b1fdd0449d6c214e4a40108456" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_THREAD_PRIO&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread. </p>
<p>The priority value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01139">1139</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f93dfeaed4021061959f822def602cb"></a><!-- doxytag: member="cfg_lwip.h::DEFAULT_THREAD_STACKSIZE" ref="a7f93dfeaed4021061959f822def602cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_THREAD_STACKSIZE&#160;&#160;&#160;(KERN_MINSTACKSIZE * 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread. </p>
<p>The stack size value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01130">1130</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a09fe785559b3f0cf108da4440489e335"></a><!-- doxytag: member="cfg_lwip.h::DEFAULT_UDP_RECVMBOX_SIZE" ref="a09fe785559b3f0cf108da4440489e335" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_UDP_RECVMBOX_SIZE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_UDP. </p>
<p>The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when the recvmbox is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01157">1157</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a07ffd8e9106dae3b65347bd03811a4b6"></a><!-- doxytag: member="cfg_lwip.h::DNS_DOES_NAME_CHECK" ref="a07ffd8e9106dae3b65347bd03811a4b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_DOES_NAME_CHECK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DNS do a name checking between the query and the response. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00689">689</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="acba1ac491c1b47b98dfbd0d5c1662659"></a><!-- doxytag: member="cfg_lwip.h::DNS_LOCAL_HOSTLIST" ref="acba1ac491c1b47b98dfbd0d5c1662659" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_LOCAL_HOSTLIST&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. </p>
<p>If enabled, you have to define </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #define DNS_LOCAL_HOSTLIST_INIT {{&quot;host1&quot;, 0x123}, {&quot;host2&quot;, 0x234}}</span>
</pre></div><p> (an array of structs name/address, where address is an u32_t in network byte order).</p>
<p>Instead, you can also use an external function: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)</span>
</pre></div><p> that returns the IP address or INADDR_NONE if not found. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00719">719</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8235a5fb0a1c1cceeee670cf95612ba8"></a><!-- doxytag: member="cfg_lwip.h::DNS_LOCAL_HOSTLIST_IS_DYNAMIC" ref="a8235a5fb0a1c1cceeee670cf95612ba8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this is turned on, the local host-list can be dynamically changed at runtime. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00725">725</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b01c79902063c170ef57deb72f56124"></a><!-- doxytag: member="cfg_lwip.h::DNS_MAX_NAME_LENGTH" ref="a3b01c79902063c170ef57deb72f56124" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_MAX_NAME_LENGTH&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DNS maximum host name length supported in the name table. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00679">679</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="af489bec6d82ce1a8cfc08dfd0bd25767"></a><!-- doxytag: member="cfg_lwip.h::DNS_MSG_SIZE" ref="af489bec6d82ce1a8cfc08dfd0bd25767" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_MSG_SIZE&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DNS message max. </p>
<p>size. Default value is RFC compliant. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00701">701</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2384e76c1acdf969d883f3de08d340f7"></a><!-- doxytag: member="cfg_lwip.h::DNS_TABLE_SIZE" ref="a2384e76c1acdf969d883f3de08d340f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_TABLE_SIZE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DNS maximum number of entries to maintain locally. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00674">674</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a60a549132d931208028403376918fc90"></a><!-- doxytag: member="cfg_lwip.h::DNS_USES_STATIC_BUF" ref="a60a549132d931208028403376918fc90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DNS_USES_STATIC_BUF&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DNS use a local buffer if DNS_USES_STATIC_BUF=0, a static one if DNS_USES_STATIC_BUF=1, or a dynamic one if DNS_USES_STATIC_BUF=2. </p>
<p>The buffer will be of size DNS_MSG_SIZE </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00696">696</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a70ce0ecf56cf5fab000134e66d863f90"></a><!-- doxytag: member="cfg_lwip.h::ETHARP_SUPPORT_VLAN" ref="a70ce0ecf56cf5fab000134e66d863f90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETHARP_SUPPORT_VLAN&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header. </p>
<p>Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check. If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted. If ETHARP_VLAN_CHECK is not defined, all traffic is accepted. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00402">402</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5348b198e7e7b447cbe714913895e924"></a><!-- doxytag: member="cfg_lwip.h::ETHARP_TRUST_IP_MAC" ref="a5348b198e7e7b447cbe714913895e924" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETHARP_TRUST_IP_MAC&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be updated with the source MAC and IP addresses supplied in the packet. </p>
<p>You may want to disable this if you do not trust LAN peers to have the correct addresses, or as a limited approach to attempt to handle spoofing. If disabled, lwIP will need to make a new ARP request if the peer is not already in the ARP table, adding a little latency. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00392">392</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a881d32ff5ee02af01f758953f1b51d59"></a><!-- doxytag: member="cfg_lwip.h::IP_FORWARD" ref="a881d32ff5ee02af01f758953f1b51d59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IP_FORWARD&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IP_FORWARD==1: Enables the ability to forward IP packets across network interfaces. </p>
<p>If you are going to run lwIP on a device with only one network interface, define this to 0. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00416">416</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf9edad9d50d86009044946e6db38c01"></a><!-- doxytag: member="cfg_lwip.h::IP_FRAG_USES_STATIC_BUF" ref="acf9edad9d50d86009044946e6db38c01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IP_FRAG_USES_STATIC_BUF&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP fragmentation. </p>
<p>Otherwise pbufs are allocated and reference the original packet data to be fragmented. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00467">467</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa956b0167c37a2265b55e2d0204a3933"></a><!-- doxytag: member="cfg_lwip.h::IP_OPTIONS_ALLOWED" ref="aa956b0167c37a2265b55e2d0204a3933" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IP_OPTIONS_ALLOWED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IP_OPTIONS_ALLOWED: Defines the behavior for IP options. </p>
<p>IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped. IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed). </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00425">425</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29084a46d7d4be30e8029d356bca0394"></a><!-- doxytag: member="cfg_lwip.h::IP_REASS_MAX_PBUFS" ref="a29084a46d7d4be30e8029d356bca0394" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IP_REASS_MAX_PBUFS&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled. </p>
<p>Since the received pbufs are enqueued, be sure to configure PBUF_POOL_SIZE &gt; IP_REASS_MAX_PBUFS so that the stack is still able to receive packets even if the maximum amount of fragments is enqueued for reassembly! </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00458">458</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad41122bd0b5485a18a4415c8f953727b"></a><!-- doxytag: member="cfg_lwip.h::IP_REASS_MAXAGE" ref="ad41122bd0b5485a18a4415c8f953727b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IP_REASS_MAXAGE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally) a fragmented IP packet waits for all fragments to arrive. </p>
<p>If not all fragments arrived in this time, the whole packet is discarded. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00448">448</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b2c993fd940f5774108298933310384"></a><!-- doxytag: member="cfg_lwip.h::IP_SOF_BROADCAST" ref="a0b2c993fd940f5774108298933310384" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IP_SOF_BROADCAST&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast filter per pcb on udp and raw send operations. </p>
<p>To enable broadcast filter on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00491">491</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0a3ef6098813c103e5aba07da76e15e2"></a><!-- doxytag: member="cfg_lwip.h::LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT" ref="a0a3ef6098813c103e5aba07da76e15e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from interrupt context (or another context that doesn't allow waiting for a semaphore). </p>
<p>If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT, while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs with each loop so that mem_free can run.</p>
<p>ATTENTION: As you can see from the above description, this leads to dis-/ enabling interrupts often, which can be slow! Also, on low memory, mem_malloc can need longer.</p>
<p>If you don't want that, at least for NO_SYS=0, you can still use the following functions to enqueue a deallocation call which then runs in the tcpip_thread context:</p>
<ul>
<li>pbuf_free_callback(p);</li>
<li>mem_free_callback(m); </li>
</ul>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00221">221</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="afed2811f031822ec5afa1ee211fb7447"></a><!-- doxytag: member="cfg_lwip.h::LWIP_COMPAT_SOCKETS" ref="afed2811f031822ec5afa1ee211fb7447" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_COMPAT_SOCKETS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable BSD-style sockets functions names. </p>
<p>NOTE: do not change this!!! </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01223">1223</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2043f599515774f8e571ba185dbcb9e7"></a><!-- doxytag: member="cfg_lwip.h::LWIP_DBG_MIN_LEVEL" ref="a2043f599515774f8e571ba185dbcb9e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_DBG_MIN_LEVEL&#160;&#160;&#160;LWIP_DBG_LEVEL_ALL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is compared against this value. </p>
<p>If it is smaller, then debugging messages are written. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01617">1617</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a6ec62dc121064ac591b1fd8567bee9"></a><!-- doxytag: member="cfg_lwip.h::LWIP_DHCP" ref="a8a6ec62dc121064ac591b1fd8567bee9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_DHCP&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable DHCP module. </p>
<p>UDP must be also available. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00564">564</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4ff3f941b4c71a04b0c30fbee5b198c2"></a><!-- doxytag: member="cfg_lwip.h::LWIP_DHCP_AUTOIP_COOP_TRIES" ref="a4ff3f941b4c71a04b0c30fbee5b198c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_DHCP_AUTOIP_COOP_TRIES&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes that should be sent before falling back on AUTOIP. </p>
<p>This can be set as low as 1 to get an AutoIP address very quickly, but you should be prepared to handle a changing IP address when DHCP overrides AutoIP. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00601">601</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a98710dd81446b7cb2daac736bae6f646"></a><!-- doxytag: member="cfg_lwip.h::LWIP_DNS" ref="a98710dd81446b7cb2daac736bae6f646" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_DNS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn on DNS module. </p>
<p>UDP must be available for DNS transport. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00670">670</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa2b1f736373cd896e212644aa453fbaf"></a><!-- doxytag: member="cfg_lwip.h::LWIP_HAVE_LOOPIF" ref="aa2b1f736373cd896e212644aa453fbaf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HAVE_LOOPIF&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Support loop interface (127.0.0.1) and loopif.c. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01014">1014</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6138031a260945ca1ed17f81b8efe5c8"></a><!-- doxytag: member="cfg_lwip.h::LWIP_HAVE_SLIPIF" ref="a6138031a260945ca1ed17f81b8efe5c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HAVE_SLIPIF&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Support slip interface and slipif.c. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01026">1026</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a478041b8544461258f6961bf0f3c1a77"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETCONN" ref="a478041b8544461258f6961bf0f3c1a77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_NETCONN&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable Netconn API (require to use api_lib.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01196">1196</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="add45fb65f2d0e6de5a0d14ff9e101b77"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETIF_API" ref="add45fb65f2d0e6de5a0d14ff9e101b77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_NETIF_API&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Support netif api (in netifapi.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00929">929</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad1d5e878d94b56ba687cef69be936ad9"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETIF_HWADDRHINT" ref="ad1d5e878d94b56ba687cef69be936ad9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_NETIF_HWADDRHINT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. </p>
<p>table indices) in struct netif. TCP and UDP can make use of this to prevent scanning the ARP table for every sent packet. While this is faster for big ARP tables or many concurrent connections, it might be counterproductive if you have a tiny ARP table or if there never are concurrent connections. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00955">955</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa28d13ddd5281b1912276991e7ea58c5"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETIF_LOOPBACK_MULTITHREADING" ref="aa28d13ddd5281b1912276991e7ea58c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_NETIF_LOOPBACK_MULTITHREADING&#160;&#160;&#160;(!NO_SYS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in the system, as netifs must change how they behave depending on this setting for the LWIP_NETIF_LOOPBACK option to work. </p>
<p>Setting this is needed to avoid reentering non-reentrant functions like tcp_input(). LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a multithreaded environment like tcpip.c. In this case, netif-&gt;input() is called directly. LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup. The packets are put on a list and netif_poll() must be called in the main application loop. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00988">988</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="abafb9f64a80e51b56c0abbcfc1f7e04e"></a><!-- doxytag: member="cfg_lwip.h::LWIP_NETIF_TX_SINGLE_PBUF" ref="abafb9f64a80e51b56c0abbcfc1f7e04e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_NETIF_TX_SINGLE_PBUF&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data to be sent into one single pbuf. </p>
<p>This is for compatibility with DMA-enabled MACs that do not support scatter-gather. Beware that this might involve CPU-memcpy before transmitting that would not be needed without this flag! Use this only if you need to!</p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01001">1001</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a484c38ab08f60d5b3335d23d31f9a402"></a><!-- doxytag: member="cfg_lwip.h::LWIP_POSIX_SOCKETS_IO_NAMES" ref="a484c38ab08f60d5b3335d23d31f9a402" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_POSIX_SOCKETS_IO_NAMES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names. </p>
<p>Disable this option if you use a POSIX operating system that uses the same names (read, write &amp; close). (only used if you use sockets.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01232">1232</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="af4900859dc53f19f5f67cc34e48ad68c"></a><!-- doxytag: member="cfg_lwip.h::LWIP_SNMP" ref="af4900859dc53f19f5f67cc34e48ad68c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_SNMP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn on SNMP module. </p>
<p>UDP must be also available. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00614">614</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1cb62ce61ac39d7d6728ae5d3d3b927f"></a><!-- doxytag: member="cfg_lwip.h::LWIP_SOCKET" ref="a1cb62ce61ac39d7d6728ae5d3d3b927f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_SOCKET&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable Socket API (require to use sockets.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01208">1208</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8b9369ab260f032686a81c77c5b4db77"></a><!-- doxytag: member="cfg_lwip.h::LWIP_TCP_KEEPALIVE" ref="a8b9369ab260f032686a81c77c5b4db77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_TCP_KEEPALIVE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT options processing. </p>
<p>Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set in seconds. (does not require sockets.c, and will affect tcp.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01241">1241</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a35731bc5f337943e474a15c1cd538a61"></a><!-- doxytag: member="cfg_lwip.h::LWIP_UDPLITE" ref="a35731bc5f337943e474a15c1cd538a61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_UDPLITE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LWIP_UDPLITE==1: Turn on UDP-Lite. </p>
<p>(Requires LWIP_UDP) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00744">744</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a97343214666ee6dcb18c0bd77b441ea7"></a><!-- doxytag: member="cfg_lwip.h::MEM_ALIGNMENT" ref="a97343214666ee6dcb18c0bd77b441ea7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_ALIGNMENT&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEM_ALIGNMENT: should be set to the alignment of the CPU. </p>
<div class="fragment"><pre class="fragment">
 *    4 byte alignment -&gt; #define MEM_ALIGNMENT 4
 *    2 byte alignment -&gt; #define MEM_ALIGNMENT 2
 * </pre></div> 
<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00142">142</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4ef345cc270912bd2230b1c5ec51dfc8"></a><!-- doxytag: member="cfg_lwip.h::MEM_LIBC_MALLOC" ref="a4ef345cc270912bd2230b1c5ec51dfc8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_LIBC_MALLOC&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library instead of the lwip internal allocator. </p>
<p>Can save code size if you already use it. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00122">122</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2dcf8c45f945dd0c4301a94700f2112c"></a><!-- doxytag: member="cfg_lwip.h::MEM_SIZE" ref="a2dcf8c45f945dd0c4301a94700f2112c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_SIZE&#160;&#160;&#160;1600</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size of the lwIP heap memory. </p>
<p>If the application will send a lot of data that needs to be copied, this should be set high. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00153">153</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="addca3141bc7037241769eb152b6f89ba"></a><!-- doxytag: member="cfg_lwip.h::MEM_USE_POOLS" ref="addca3141bc7037241769eb152b6f89ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_USE_POOLS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set of memory pools of various sizes. </p>
<p>When mem_malloc is called, an element of the smallest pool that can provide the length needed is returned. To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00181">181</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba8be68e8fd0716b723ce4569ed89f82"></a><!-- doxytag: member="cfg_lwip.h::MEM_USE_POOLS_TRY_BIGGER_POOL" ref="aba8be68e8fd0716b723ce4569ed89f82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_USE_POOLS_TRY_BIGGER_POOL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more reliable. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00189">189</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a087b00ea20a7edebcad33a1a1353a5d7"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_ARP_QUEUE" ref="a087b00ea20a7edebcad33a1a1353a5d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_ARP_QUEUE&#160;&#160;&#160;30</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing packets (pbufs) that are waiting for an ARP request (to resolve their destination address) to finish. </p>
<p>(requires the ARP_QUEUEING option) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00294">294</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab648ff95d8ffa4216b95f82a568a5d9a"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_IGMP_GROUP" ref="ab648ff95d8ffa4216b95f82a568a5d9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_IGMP_GROUP&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces can be members et the same time (one per netif - allsystems group -, plus one per netif membership). </p>
<p>(requires the LWIP_IGMP option) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00304">304</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d99df65869ac101ed6a611fc85016be"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_NETBUF" ref="a5d99df65869ac101ed6a611fc85016be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_NETBUF&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_NETBUF: the number of struct netbufs. </p>
<p>(only needed if you use the sequential API, like api_lib.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00320">320</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb40bd726b7e15593b20a628d298f456"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_NETCONN" ref="acb40bd726b7e15593b20a628d298f456" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_NETCONN&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_NETCONN: the number of struct netconns. </p>
<p>(only needed if you use the sequential API, like api_lib.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00328">328</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a92b30aed958ec59334d936d4ca725418"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_PBUF" ref="a92b30aed958ec59334d936d4ca725418" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_PBUF&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF). </p>
<p>If the application sends a lot of data out of ROM (or other static memory), this should be set high. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00235">235</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4afbdca581a58d57bc7a81118a95327e"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_SYS_TIMEOUT" ref="a4afbdca581a58d57bc7a81118a95327e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_SYS_TIMEOUT&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts. </p>
<p>(requires NO_SYS==0) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00312">312</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a73beecc19cfbc3114768f9b32b2cd70e"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_TCP_PCB" ref="a73beecc19cfbc3114768f9b32b2cd70e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_TCP_PCB&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections. </p>
<p>(requires the LWIP_TCP option) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00260">260</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a04fba6a249123513271dccb4ec26aa5a"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_TCP_PCB_LISTEN" ref="a04fba6a249123513271dccb4ec26aa5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_TCP_PCB_LISTEN&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections. </p>
<p>(requires the LWIP_TCP option) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00268">268</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa35fb3a1a76661e3ffb9722a57092de3"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_TCP_SEG" ref="aa35fb3a1a76661e3ffb9722a57092de3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_TCP_SEG&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments. </p>
<p>(requires the LWIP_TCP option) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00276">276</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="afbbfd6ce8536038cd00fa85bebae987c"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_TCPIP_MSG_API" ref="afbbfd6ce8536038cd00fa85bebae987c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_TCPIP_MSG_API&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used for callback/timeout API communication. </p>
<p>(only needed if you use tcpip.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00337">337</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab089a7088439e726c3801ba9e249d831"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_TCPIP_MSG_INPKT" ref="ab089a7088439e726c3801ba9e249d831" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_TCPIP_MSG_INPKT&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used for incoming packets. </p>
<p>(only needed if you use tcpip.c) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00346">346</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c416da481ab09bd1ba257b75a0707eb"></a><!-- doxytag: member="cfg_lwip.h::MEMP_NUM_UDP_PCB" ref="a2c416da481ab09bd1ba257b75a0707eb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_NUM_UDP_PCB&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. </p>
<p>One per active UDP "connection". (requires the LWIP_UDP option) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00252">252</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27fdd01194a42fc41a7716b72cdb49e3"></a><!-- doxytag: member="cfg_lwip.h::MEMP_OVERFLOW_CHECK" ref="a27fdd01194a42fc41a7716b72cdb49e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_OVERFLOW_CHECK&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dynamic pool memory overflow protection check level. </p>
<p>MEMP_OVERFLOW_CHECK == 0 no checking MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed MEMP_OVERFLOW_CHECK &gt;= 2 checks each element in every pool every time memp_malloc() or memp_free() is called (useful but slow!) </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00165">165</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a69de593b8ffd4f1c249f03e48e11983b"></a><!-- doxytag: member="cfg_lwip.h::MEMP_USE_CUSTOM_POOLS" ref="a69de593b8ffd4f1c249f03e48e11983b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMP_USE_CUSTOM_POOLS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h that defines additional pools beyond the "standard" ones required by lwIP. </p>
<p>If you set this to 1, you must have lwippools.h in your inlude path somewhere. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00199">199</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae00ba99de94a5bf84d832be8976df59b"></a><!-- doxytag: member="cfg_lwip.h::NO_SYS" ref="ae00ba99de94a5bf84d832be8976df59b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NO_SYS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NO_SYS==1: Provides VERY minimal functionality. </p>
<p>Otherwise, use lwIP facilities. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00092">92</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a35998a3d56af9940e6a80bb372597685"></a><!-- doxytag: member="cfg_lwip.h::PBUF_LINK_HLEN" ref="a35998a3d56af9940e6a80bb372597685" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_LINK_HLEN&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PBUF_LINK_HLEN: the number of bytes that should be allocated for a link level header. </p>
<p>The default is 14, the standard value for Ethernet. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00900">900</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae61f4491d56e805e79b79eb5d35a00e5"></a><!-- doxytag: member="cfg_lwip.h::PBUF_POOL_BUFSIZE" ref="ae61f4491d56e805e79b79eb5d35a00e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_POOL_BUFSIZE&#160;&#160;&#160;LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. </p>
<p>The default is designed to accomodate single full size TCP frame in one pbuf, including TCP_MSS, IP header, and link header. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00909">909</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4e4f66814257c3ee5a74abc67e5fd918"></a><!-- doxytag: member="cfg_lwip.h::PPP_THREAD_PRIO" ref="a4e4f66814257c3ee5a74abc67e5fd918" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PPP_THREAD_PRIO&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PPP_THREAD_PRIO: The priority assigned to the pppMain thread. </p>
<p>The priority value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01114">1114</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad646d19911779f154c22b74f5cac723"></a><!-- doxytag: member="cfg_lwip.h::PPP_THREAD_STACKSIZE" ref="aad646d19911779f154c22b74f5cac723" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PPP_THREAD_STACKSIZE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PPP_THREAD_STACKSIZE: The stack size used by the pppMain thread. </p>
<p>The stack size value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01105">1105</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1b9fc2efcbf1f804bfd0191bc019c4e"></a><!-- doxytag: member="cfg_lwip.h::SLIPIF_THREAD_PRIO" ref="ab1b9fc2efcbf1f804bfd0191bc019c4e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLIPIF_THREAD_PRIO&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread. </p>
<p>The priority value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01089">1089</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae8ab54a25007ce997bbab6289815e258"></a><!-- doxytag: member="cfg_lwip.h::SLIPIF_THREAD_STACKSIZE" ref="ae8ab54a25007ce997bbab6289815e258" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLIPIF_THREAD_STACKSIZE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread. </p>
<p>The stack size value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01080">1080</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8c6e3c1e4f74acb16376188dbf8909ec"></a><!-- doxytag: member="cfg_lwip.h::SMEMCPY" ref="a8c6e3c1e4f74acb16376188dbf8909ec" args="(dst, src, len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SMEMCPY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;memcpy(dst,src,len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SMEMCPY: override this with care! Some compilers (e.g. </p>
<p>gcc) can inline a call to memcpy() if the length is known at compile time and is small. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00108">108</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff91bbf0295767f430f32d82f5ff48a1"></a><!-- doxytag: member="cfg_lwip.h::SNMP_CONCURRENT_REQUESTS" ref="aff91bbf0295767f430f32d82f5ff48a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_CONCURRENT_REQUESTS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will allow. </p>
<p>At least one request buffer is required. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00621">621</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95e39047b9bcb385780b06b35af49261"></a><!-- doxytag: member="cfg_lwip.h::SNMP_SAFE_REQUESTS" ref="a95e39047b9bcb385780b06b35af49261" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_SAFE_REQUESTS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Only allow SNMP write actions that are 'safe' (e.g. </p>
<p>disabeling netifs is not a safe action and disabled when SNMP_SAFE_REQUESTS = 1). Unsafe requests are disabled by default! </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00645">645</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a692343b0cc555c302fd713003d4f8a08"></a><!-- doxytag: member="cfg_lwip.h::SNMP_TRAP_DESTINATIONS" ref="a692343b0cc555c302fd713003d4f8a08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_TRAP_DESTINATIONS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SNMP_TRAP_DESTINATIONS: Number of trap destinations. </p>
<p>At least one trap destination is required </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00629">629</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3822feed320cf8439b083ee525e4942"></a><!-- doxytag: member="cfg_lwip.h::SO_REUSE" ref="af3822feed320cf8439b083ee525e4942" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SO_REUSE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SO_REUSE==1: Enable SO_REUSEADDR and SO_REUSEPORT options. </p>
<p>DO NOT USE! </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01269">1269</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93cce3f47e33df11248c908d1775bacf"></a><!-- doxytag: member="cfg_lwip.h::TCP_DEFAULT_LISTEN_BACKLOG" ref="a93cce3f47e33df11248c908d1775bacf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_DEFAULT_LISTEN_BACKLOG&#160;&#160;&#160;0xff</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum allowed backlog for TCP listen netconns. </p>
<p>This backlog is used unless another is explicitly specified. 0xff is the maximum (u8_t). </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00871">871</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1ab7bb27860aa3677c387a2f3ba317b"></a><!-- doxytag: member="cfg_lwip.h::TCP_MSS" ref="af1ab7bb27860aa3677c387a2f3ba317b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_MSS&#160;&#160;&#160;536</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCP_MSS: TCP Maximum segment size. </p>
<p>(default is 536, a conservative default, you might want to increase this.) For the receive side, this MSS is advertised to the remote side when opening a connection. For the transmit size, this MSS sets an upper limit on the MSS advertised by the remote host. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00818">818</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a89ffd0d7d1529bdb26bfbad267d0ad75"></a><!-- doxytag: member="cfg_lwip.h::TCP_QUEUE_OOSEQ" ref="a89ffd0d7d1529bdb26bfbad267d0ad75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_QUEUE_OOSEQ&#160;&#160;&#160;(LWIP_TCP)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order. </p>
<p>Define to 0 if your device is low on memory. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00807">807</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9beaa47832ead4180981bfbf71074904"></a><!-- doxytag: member="cfg_lwip.h::TCP_SND_QUEUELEN" ref="a9beaa47832ead4180981bfbf71074904" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_SND_QUEUELEN&#160;&#160;&#160;(4 * (TCP_SND_BUF)/(TCP_MSS))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). </p>
<p>This must be at least as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00846">846</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae5c9866d7cd463ac7b36792182145aec"></a><!-- doxytag: member="cfg_lwip.h::TCP_SNDLOWAT" ref="ae5c9866d7cd463ac7b36792182145aec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_SNDLOWAT&#160;&#160;&#160;((TCP_SND_BUF)/2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCP_SNDLOWAT: TCP writable space (bytes). </p>
<p>This must be less than or equal to TCP_SND_BUF. It is the amount of space which must be available in the TCP snd_buf for select to return writable. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00855">855</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f535a6efb5cdf86c3210e35ece1d6a7"></a><!-- doxytag: member="cfg_lwip.h::TCP_WND" ref="a7f535a6efb5cdf86c3210e35ece1d6a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_WND&#160;&#160;&#160;(4 * TCP_MSS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCP_WND: The size of a TCP window. </p>
<p>This must be at least (2 * TCP_MSS) for things to work well </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l00785">785</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="a42b2c7a3042d7c3efd00f367f5837435"></a><!-- doxytag: member="cfg_lwip.h::TCPIP_THREAD_PRIO" ref="a42b2c7a3042d7c3efd00f367f5837435" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCPIP_THREAD_PRIO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread. </p>
<p>The priority value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01055">1055</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa02b84eafa0c8b09b158b97c96d79db0"></a><!-- doxytag: member="cfg_lwip.h::TCPIP_THREAD_STACKSIZE" ref="aa02b84eafa0c8b09b158b97c96d79db0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCPIP_THREAD_STACKSIZE&#160;&#160;&#160;(KERN_MINSTACKSIZE * 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread. </p>
<p>The stack size value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created. </p>

<p>Definition at line <a class="el" href="cfg__lwip_8h_source.html#l01046">1046</a> of file <a class="el" href="cfg__lwip_8h_source.html">cfg_lwip.h</a>.</p>

</div>
</div>
</div>


