

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">General purpose lists</div>  </div>
<div class="ingroups"><a class="el" href="group__struct.html">Embedded optimized general purpose data types</a></div></div>
<div class="contents">

<p>General pourpose double-linked lists.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNode.html">Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure represents a node for bidirectional lists.  <a href="structNode.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structList.html">List</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Head of a doubly-linked list of <code><a class="el" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a></code> structs.  <a href="structList.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPriNode.html">PriNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended node for priority queues.  <a href="structPriNode.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga457576b88a161e8bf3b752072f08e5f0">DECLARE_NODE_ANON</a>(T)&#160;&#160;&#160;T *succ; T *pred;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for a naked node in a list of <em>T</em> structures.  <a href="#ga457576b88a161e8bf3b752072f08e5f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga7232a35644f133020dc7866437101d0c">DECLARE_NODE_TYPE</a>(T)&#160;&#160;&#160;typedef struct T##<a class="el" href="structNode.html">Node</a> { T *succ; T *pred; } T##<a class="el" href="structNode.html">Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a typesafe node for structures of type <em>T</em>.  <a href="#ga7232a35644f133020dc7866437101d0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#gad2f7456281b9005a13f5a06d87941dc3">DECLARE_LIST_TYPE</a>(T)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for a list of <em>T</em> structures.  <a href="#gad2f7456281b9005a13f5a06d87941dc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga90b9534a14fbd57ef7e1f2135df31e36">LIST_HEAD</a>(l)&#160;&#160;&#160;((l)-&gt;head.succ)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the first node in a list.  <a href="#ga90b9534a14fbd57ef7e1f2135df31e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga1636a2445b7b59b39873f7acb9f402ce">LIST_TAIL</a>(l)&#160;&#160;&#160;((l)-&gt;tail.pred)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the last node in a list.  <a href="#ga1636a2445b7b59b39873f7acb9f402ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga91a9735c8acba8592b8b6872b1fbf2dd">FOREACH_NODE</a>(n, l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in a list.  <a href="#ga91a9735c8acba8592b8b6872b1fbf2dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga7045a3b6d378ff0c4269626c5a22d8e0">REVERSE_FOREACH_NODE</a>(n, l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate backwards over all nodes in a list.  <a href="#ga7045a3b6d378ff0c4269626c5a22d8e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#gaf9dad35fa40c96453b1ed2df0adb18eb">FOREACH_NODE_SAFE</a>(n, p, l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate on the list safely against node removal.  <a href="#gaf9dad35fa40c96453b1ed2df0adb18eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga005c60e8bdd32530e0ccd2374ba3289b">LIST_INIT</a>(l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a list.  <a href="#ga005c60e8bdd32530e0ccd2374ba3289b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#gabe702a1410b6db9be3128d538bc458e7">LIST_ASSERT_VALID</a>(l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure that a list is valid (it was initialized and is not corrupted).  <a href="#gabe702a1410b6db9be3128d538bc458e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27bdfeae068a25b8193bb7fb9296e3a8"></a><!-- doxytag: member="list::LIST_ASSERT_NOT_CONTAINS" ref="ga27bdfeae068a25b8193bb7fb9296e3a8" args="(list, node)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga27bdfeae068a25b8193bb7fb9296e3a8">LIST_ASSERT_NOT_CONTAINS</a>(list, node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a node isn't part of a given list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga3930d96e717edf8f2cda41eda774cf16">LIST_EMPTY</a>(l)&#160;&#160;&#160;( (void *)((l)-&gt;head.succ) == (void *)(&amp;(l)-&gt;tail) )</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether a list is empty.  <a href="#ga3930d96e717edf8f2cda41eda774cf16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga66a42b084e8291d28a5e39edb2346d5c">ADDHEAD</a>(l, n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add node to list head.  <a href="#ga66a42b084e8291d28a5e39edb2346d5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga0ba6587a8f112952627f8bba78fd8611">ADDTAIL</a>(l, n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add node to list tail.  <a href="#ga0ba6587a8f112952627f8bba78fd8611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga20a8012133533f871557feca959e7516">INSERT_BEFORE</a>(n, ln)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node <em>n</em> before node <em>ln</em>.  <a href="#ga20a8012133533f871557feca959e7516"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga849a0f1c77918e5845588373178ee4ca">REMOVE</a>(n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>n</em> from whatever list it is in.  <a href="#ga849a0f1c77918e5845588373178ee4ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga092cd6c5d0ed5bbea1f3d885747b62e8">LIST_ENQUEUE_HEAD</a>(list, node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a priority node in a priority queue.  <a href="#ga092cd6c5d0ed5bbea1f3d885747b62e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#gafce5b0341c2b60e46398240b0eebd467">LIST_ENQUEUE</a>(list, node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a priority node in a priority queue.  <a href="#gafce5b0341c2b60e46398240b0eebd467"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga711eeee335e5022e1d50b7a5085cb611">list_remHead</a> (<a class="el" href="structList.html">List</a> *l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a node from the head of the list <em>l</em>.  <a href="#ga711eeee335e5022e1d50b7a5085cb611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__list.html#ga14be6c71a00bf070696abe4ce5018436">list_remTail</a> (<a class="el" href="structList.html">List</a> *l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a node from the tail of the list <em>l</em>.  <a href="#ga14be6c71a00bf070696abe4ce5018436"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>General pourpose double-linked lists. </p>
<p>Lists contain nodes. You can put any custom struct into any list as long as it has a <a class="el" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> struct inside it. If you make the <a class="el" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> struct the first member of your data type, you can simply cast it to (<a class="el" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *) when passing it to list functions.</p>
<p>Lists must be initialized before use with <a class="el" href="group__list.html#ga005c60e8bdd32530e0ccd2374ba3289b" title="Initialize a list.">LIST_INIT()</a>. You can then add objects using <a class="el" href="group__list.html#ga66a42b084e8291d28a5e39edb2346d5c" title="Add node to list head.">ADDHEAD()</a> and <a class="el" href="group__list.html#ga0ba6587a8f112952627f8bba78fd8611" title="Add node to list tail.">ADDTAIL()</a> macros, and remove them with <a class="el" href="group__list.html#ga711eeee335e5022e1d50b7a5085cb611" title="Unlink a node from the head of the list l.">list_remHead()</a> and <a class="el" href="group__list.html#ga14be6c71a00bf070696abe4ce5018436" title="Unlink a node from the tail of the list l.">list_remTail()</a>.</p>
<p>You can create lists with priorities by using <a class="el" href="structPriNode.html" title="Extended node for priority queues.">PriNode</a> instead of <a class="el" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> as the base member struct. Use <a class="el" href="group__list.html#gafce5b0341c2b60e46398240b0eebd467" title="Insert a priority node in a priority queue.">LIST_ENQUEUE()</a> and <a class="el" href="group__list.html#ga092cd6c5d0ed5bbea1f3d885747b62e8" title="Insert a priority node in a priority queue.">LIST_ENQUEUE_HEAD()</a> to insert a priority node into a list.</p>
<p>To iterate over a list, use the macros <a class="el" href="group__list.html#ga91a9735c8acba8592b8b6872b1fbf2dd" title="Iterate over all nodes in a list.">FOREACH_NODE()</a> and <a class="el" href="group__list.html#ga7045a3b6d378ff0c4269626c5a22d8e0" title="Iterate backwards over all nodes in a list.">REVERSE_FOREACH_NODE()</a> in this way: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>Foo
 {
     <a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> n;
     <span class="keywordtype">int</span> a;
 }

 <span class="keywordtype">int</span> main()
 {
        <a class="code" href="structList.html" title="Head of a doubly-linked list of Node structs.">List</a> foo_list;
        <span class="keyword">static</span> Foo foo1, foo2;
        Foo *fp;

        <a class="code" href="group__list.html#ga005c60e8bdd32530e0ccd2374ba3289b" title="Initialize a list.">LIST_INIT</a>(&amp;foo_list);
        <a class="code" href="group__list.html#ga66a42b084e8291d28a5e39edb2346d5c" title="Add node to list head.">ADDHEAD</a>(&amp;foo_list, (<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)&amp;foo1);
        <a class="code" href="group__list.html#ga20a8012133533f871557feca959e7516" title="Insert node n before node ln.">INSERT_BEFORE</a>(&amp;foo_list, (<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)&amp;foo2);
        <a class="code" href="group__list.html#ga91a9735c8acba8592b8b6872b1fbf2dd" title="Iterate over all nodes in a list.">FOREACH_NODE</a>(fp, &amp;foo_list)
            fp-&gt;a = 10;
 }
</pre></div><dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga66a42b084e8291d28a5e39edb2346d5c"></a><!-- doxytag: member="list.h::ADDHEAD" ref="ga66a42b084e8291d28a5e39edb2346d5c" args="(l, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADDHEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        <a class="code" href="group__list.html#ga27bdfeae068a25b8193bb7fb9296e3a8" title="Checks that a node isn&#39;t part of a given list.">LIST_ASSERT_NOT_CONTAINS</a>((l),(n)); \
        (n)-&gt;succ = (l)-&gt;head.succ; \
        (n)-&gt;pred = (l)-&gt;head.succ-&gt;pred; \
        (n)-&gt;succ-&gt;pred = (n); \
        (n)-&gt;pred-&gt;succ = (n); \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Add node to list head. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00282">282</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ba6587a8f112952627f8bba78fd8611"></a><!-- doxytag: member="list.h::ADDTAIL" ref="ga0ba6587a8f112952627f8bba78fd8611" args="(l, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADDTAIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        <a class="code" href="group__list.html#ga27bdfeae068a25b8193bb7fb9296e3a8" title="Checks that a node isn&#39;t part of a given list.">LIST_ASSERT_NOT_CONTAINS</a>((l),(n)); \
        (n)-&gt;succ = &amp;(l)-&gt;tail; \
        (n)-&gt;pred = (l)-&gt;tail.pred; \
        (n)-&gt;pred-&gt;succ = (n); \
        (l)-&gt;tail.pred = (n); \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Add node to list tail. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00292">292</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad2f7456281b9005a13f5a06d87941dc3"></a><!-- doxytag: member="list.h::DECLARE_LIST_TYPE" ref="gad2f7456281b9005a13f5a06d87941dc3" args="(T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_LIST_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="group__list.html#ga7232a35644f133020dc7866437101d0c" title="Declare a typesafe node for structures of type T.">DECLARE_NODE_TYPE</a>(T); \
    <span class="keyword">typedef</span> <span class="keyword">struct </span>T##<a class="code" href="structList.html" title="Head of a doubly-linked list of Node structs.">List</a> { \
         T##<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> head; \
         T##<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> tail; \
    } T##<a class="code" href="structList.html" title="Head of a doubly-linked list of Node structs.">List</a>
</pre></div>
<p>Template for a list of <em>T</em> structures. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00160">160</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga457576b88a161e8bf3b752072f08e5f0"></a><!-- doxytag: member="list.h::DECLARE_NODE_ANON" ref="ga457576b88a161e8bf3b752072f08e5f0" args="(T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_NODE_ANON</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;T *succ; T *pred;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Template for a naked node in a list of <em>T</em> structures. </p>
<p>To be used as data member in other structures:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>Foo
    {
        <a class="code" href="group__list.html#ga457576b88a161e8bf3b752072f08e5f0" title="Template for a naked node in a list of T structures.">DECLARE_NODE_ANON</a>(<span class="keyword">struct</span> Foo)
        int a;
        <span class="keywordtype">float</span> b;
    }

    <a class="code" href="group__list.html#gad2f7456281b9005a13f5a06d87941dc3" title="Template for a list of T structures.">DECLARE_LIST_TYPE</a>(Foo);

    <span class="keywordtype">void</span> foo(<span class="keywordtype">void</span>)
    {
        <span class="keyword">static</span> LIST_TYPE(Foo) foo_list;
        static Foo foo1, foo2;
        Foo *fp;

        <a class="code" href="group__list.html#ga005c60e8bdd32530e0ccd2374ba3289b" title="Initialize a list.">LIST_INIT</a>(&amp;foo_list);
        <a class="code" href="group__list.html#ga66a42b084e8291d28a5e39edb2346d5c" title="Add node to list head.">ADDHEAD</a>(&amp;foo_list, &amp;foo1);
        <a class="code" href="group__list.html#ga20a8012133533f871557feca959e7516" title="Insert node n before node ln.">INSERT_BEFORE</a>(&amp;foo_list, &amp;foo2);
        <a class="code" href="group__list.html#ga91a9735c8acba8592b8b6872b1fbf2dd" title="Iterate over all nodes in a list.">FOREACH_NODE</a>(fp, &amp;foo_list)
            fp-&gt;a = 10;
    }
</pre></div> 
<p>Definition at line <a class="el" href="list_8h_source.html#l00152">152</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7232a35644f133020dc7866437101d0c"></a><!-- doxytag: member="list.h::DECLARE_NODE_TYPE" ref="ga7232a35644f133020dc7866437101d0c" args="(T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_NODE_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;typedef struct T##<a class="el" href="structNode.html">Node</a> { T *succ; T *pred; } T##<a class="el" href="structNode.html">Node</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare a typesafe node for structures of type <em>T</em>. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00156">156</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga91a9735c8acba8592b8b6872b1fbf2dd"></a><!-- doxytag: member="list.h::FOREACH_NODE" ref="ga91a9735c8acba8592b8b6872b1fbf2dd" args="(n, l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOREACH_NODE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>( \
        (n) = (TYPEOF_OR_VOIDPTR(n))<a class="code" href="group__list.html#ga90b9534a14fbd57ef7e1f2135df31e36" title="Get a pointer to the first node in a list.">LIST_HEAD</a>(l); \
        ((<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)(n))-&gt;succ; \
        (n) = (TYPEOF_OR_VOIDPTR(n))(((<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)(n))-&gt;succ) \
    )
</pre></div>
<p>Iterate over all nodes in a list. </p>
<p>This macro generates a "for" statement using the following parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> pointer to be used in each iteration. </td></tr>
    <tr><td class="paramname">l</td><td>Pointer to list. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="list_8h_source.html#l00198">198</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9dad35fa40c96453b1ed2df0adb18eb"></a><!-- doxytag: member="list.h::FOREACH_NODE_SAFE" ref="gaf9dad35fa40c96453b1ed2df0adb18eb" args="(n, p, l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOREACH_NODE_SAFE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>( \
        (n) = (TYPEOF_OR_VOIDPTR(n))<a class="code" href="group__list.html#ga90b9534a14fbd57ef7e1f2135df31e36" title="Get a pointer to the first node in a list.">LIST_HEAD</a>(l), (p) = ((<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)(n))-&gt;succ; \
        ((<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)(n))-&gt;succ; \
        (n) = (p), (p) = (TYPEOF_OR_VOIDPTR(n))(((<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)(n))-&gt;succ) \
    )
</pre></div>
<p>Iterate on the list safely against node removal. </p>
<p>This macro generates a "for" statement using the following parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> pointer to be used in each iteration. </td></tr>
    <tr><td class="paramname">p</td><td>Temporal storage for the iterator. </td></tr>
    <tr><td class="paramname">l</td><td>Pointer to list. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="list_8h_source.html#l00227">227</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga20a8012133533f871557feca959e7516"></a><!-- doxytag: member="list.h::INSERT_BEFORE" ref="ga20a8012133533f871557feca959e7516" args="(n, ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSERT_BEFORE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ln&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        <a class="code" href="group__debug.html#gaa362f3d4474997c5a98fcb2193dd3809" title="Check that the given pointer is either NULL or pointing to valid memory.">ASSERT_VALID_PTR</a>(n); \
        <a class="code" href="group__debug.html#gaa362f3d4474997c5a98fcb2193dd3809" title="Check that the given pointer is either NULL or pointing to valid memory.">ASSERT_VALID_PTR</a>(ln); \
        (n)-&gt;succ = (ln); \
        (n)-&gt;pred = (ln)-&gt;pred; \
        (ln)-&gt;pred-&gt;succ = (n); \
        (ln)-&gt;pred = (n); \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Insert node <em>n</em> before node <em>ln</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>You can't pass in a list header as <em>ln</em>, but it is safe to pass list-&gt;head of an empty list. </dd></dl>

<p>Definition at line <a class="el" href="list_8h_source.html#l00307">307</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabe702a1410b6db9be3128d538bc458e7"></a><!-- doxytag: member="list.h::LIST_ASSERT_VALID" ref="gabe702a1410b6db9be3128d538bc458e7" args="(l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIST_ASSERT_VALID</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
            <a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *n, *pred; \
            <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>((l)-&gt;head.succ != NULL); \
            <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>((l)-&gt;head.pred == NULL); \
            <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>((l)-&gt;tail.succ == NULL); \
            <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>((l)-&gt;tail.pred != NULL); \
            pred = &amp;(l)-&gt;head; \
            <a class="code" href="group__list.html#ga91a9735c8acba8592b8b6872b1fbf2dd" title="Iterate over all nodes in a list.">FOREACH_NODE</a>(n, l) \
            { \
                <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(n-&gt;pred == pred); \
                pred = n; \
            } \
            <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(n == &amp;(l)-&gt;tail); \
        } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Make sure that a list is valid (it was initialized and is not corrupted). </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00245">245</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3930d96e717edf8f2cda41eda774cf16"></a><!-- doxytag: member="list.h::LIST_EMPTY" ref="ga3930d96e717edf8f2cda41eda774cf16" args="(l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIST_EMPTY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l</td><td>)</td>
          <td>&#160;&#160;&#160;( (void *)((l)-&gt;head.succ) == (void *)(&amp;(l)-&gt;tail) )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell whether a list is empty. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00279">279</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafce5b0341c2b60e46398240b0eebd467"></a><!-- doxytag: member="list.h::LIST_ENQUEUE" ref="gafce5b0341c2b60e46398240b0eebd467" args="(list, node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIST_ENQUEUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        <a class="code" href="structPriNode.html" title="Extended node for priority queues.">PriNode</a> *ln; \
        <a class="code" href="group__list.html#ga27bdfeae068a25b8193bb7fb9296e3a8" title="Checks that a node isn&#39;t part of a given list.">LIST_ASSERT_NOT_CONTAINS</a>((list),(node)); \
        <a class="code" href="group__list.html#ga91a9735c8acba8592b8b6872b1fbf2dd" title="Iterate over all nodes in a list.">FOREACH_NODE</a>(ln, (list)) \
            <span class="keywordflow">if</span> (ln-&gt;pri &lt; (node)-&gt;pri) \
                <span class="keywordflow">break</span>; \
        <a class="code" href="group__list.html#ga20a8012133533f871557feca959e7516" title="Insert node n before node ln.">INSERT_BEFORE</a>(&amp;(node)-&gt;link, &amp;ln-&gt;link); \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Insert a priority node in a priority queue. </p>
<p>The new node is inserted immediately before the first node with lower priority or appended to the tail if no such node exists. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00353">353</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga092cd6c5d0ed5bbea1f3d885747b62e8"></a><!-- doxytag: member="list.h::LIST_ENQUEUE_HEAD" ref="ga092cd6c5d0ed5bbea1f3d885747b62e8" args="(list, node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIST_ENQUEUE_HEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        <a class="code" href="structPriNode.html" title="Extended node for priority queues.">PriNode</a> *ln; \
        <a class="code" href="group__list.html#ga27bdfeae068a25b8193bb7fb9296e3a8" title="Checks that a node isn&#39;t part of a given list.">LIST_ASSERT_NOT_CONTAINS</a>((list),(node)); \
        <a class="code" href="group__list.html#ga91a9735c8acba8592b8b6872b1fbf2dd" title="Iterate over all nodes in a list.">FOREACH_NODE</a>(ln, (list)) \
            <span class="keywordflow">if</span> (ln-&gt;pri &lt;= (node)-&gt;pri) \
                <span class="keywordflow">break</span>; \
        <a class="code" href="group__list.html#ga20a8012133533f871557feca959e7516" title="Insert node n before node ln.">INSERT_BEFORE</a>(&amp;(node)-&gt;link, &amp;ln-&gt;link); \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Insert a priority node in a priority queue. </p>
<p>The new node is inserted immediately before the first node with the same priority or appended to the tail if no such node exists. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00337">337</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga90b9534a14fbd57ef7e1f2135df31e36"></a><!-- doxytag: member="list.h::LIST_HEAD" ref="ga90b9534a14fbd57ef7e1f2135df31e36" args="(l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIST_HEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l</td><td>)</td>
          <td>&#160;&#160;&#160;((l)-&gt;head.succ)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the first node in a list. </p>
<p>If <em>l</em> is empty, result points to l-&gt;tail. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00175">175</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga005c60e8bdd32530e0ccd2374ba3289b"></a><!-- doxytag: member="list.h::LIST_INIT" ref="ga005c60e8bdd32530e0ccd2374ba3289b" args="(l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIST_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        (l)-&gt;head.succ = (TYPEOF_OR_VOIDPTR((l)-&gt;head.succ)) &amp;(l)-&gt;tail; \
        (l)-&gt;head.pred = NULL; \
        (l)-&gt;tail.succ = NULL; \
        (l)-&gt;tail.pred = (TYPEOF_OR_VOIDPTR((l)-&gt;tail.pred)) &amp;(l)-&gt;head; \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Initialize a list. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00235">235</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1636a2445b7b59b39873f7acb9f402ce"></a><!-- doxytag: member="list.h::LIST_TAIL" ref="ga1636a2445b7b59b39873f7acb9f402ce" args="(l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIST_TAIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l</td><td>)</td>
          <td>&#160;&#160;&#160;((l)-&gt;tail.pred)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the last node in a list. </p>
<p>If <em>l</em> is empty, result points to l-&gt;head. </p>

<p>Definition at line <a class="el" href="list_8h_source.html#l00182">182</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga849a0f1c77918e5845588373178ee4ca"></a><!-- doxytag: member="list.h::REMOVE" ref="ga849a0f1c77918e5845588373178ee4ca" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REMOVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        <a class="code" href="group__debug.html#gaa362f3d4474997c5a98fcb2193dd3809" title="Check that the given pointer is either NULL or pointing to valid memory.">ASSERT_VALID_PTR</a>(n); \
        (n)-&gt;pred-&gt;succ = (n)-&gt;succ; \
        (n)-&gt;succ-&gt;pred = (n)-&gt;pred; \
        INVALIDATE_NODE(n); \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Remove <em>n</em> from whatever list it is in. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Removing a node that has not previously been inserted into a list invokes undefined behavior. </dd></dl>

<p>Definition at line <a class="el" href="list_8h_source.html#l00323">323</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7045a3b6d378ff0c4269626c5a22d8e0"></a><!-- doxytag: member="list.h::REVERSE_FOREACH_NODE" ref="ga7045a3b6d378ff0c4269626c5a22d8e0" args="(n, l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REVERSE_FOREACH_NODE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>( \
        (n) = (TYPEOF_OR_VOIDPTR(n))<a class="code" href="group__list.html#ga1636a2445b7b59b39873f7acb9f402ce" title="Get a pointer to the last node in a list.">LIST_TAIL</a>(l); \
        ((<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)(n))-&gt;pred; \
        (n) = (TYPEOF_OR_VOIDPTR(n))(((<a class="code" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> *)(n))-&gt;pred) \
    )
</pre></div>
<p>Iterate backwards over all nodes in a list. </p>
<p>This macro generates a "for" statement using the following parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="structNode.html" title="This structure represents a node for bidirectional lists.">Node</a> pointer to be used in each iteration. </td></tr>
    <tr><td class="paramname">l</td><td>Pointer to list. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="list_8h_source.html#l00212">212</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga711eeee335e5022e1d50b7a5085cb611"></a><!-- doxytag: member="list.h::list_remHead" ref="ga711eeee335e5022e1d50b7a5085cb611" args="(List *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNode.html">Node</a>* list_remHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structList.html">List</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlink a node from the head of the list <em>l</em>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to node, or NULL if the list was empty. </dd></dl>

<p>Definition at line <a class="el" href="list_8h_source.html#l00369">369</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga14be6c71a00bf070696abe4ce5018436"></a><!-- doxytag: member="list.h::list_remTail" ref="ga14be6c71a00bf070696abe4ce5018436" args="(List *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNode.html">Node</a>* list_remTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structList.html">List</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlink a node from the tail of the list <em>l</em>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to node, or NULL if the list was empty. </dd></dl>

<p>Definition at line <a class="el" href="list_8h_source.html#l00391">391</a> of file <a class="el" href="list_8h_source.html">list.h</a>.</p>

</div>
</div>
</div>


