

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_8751e12fe1becf196f093883e557854f.html">struct</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">hashtable.c</div>  </div>
</div>
<div class="contents">
<a href="hashtable_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00084"></a>00084 <span class="preprocessor">#include &quot;<a class="code" href="hashtable_8h.html">hashtable.h</a>&quot;</span>
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="preprocessor">#include &quot;<a class="code" href="cfg__hashtable_8h.html" title="Configuration file for hashtable module.">cfg/cfg_hashtable.h</a>&quot;</span>
<a name="l00087"></a>00087 <span class="preprocessor">#include &lt;<a class="code" href="debug_8h.html">cfg/debug.h</a>&gt;</span>
<a name="l00088"></a>00088 <span class="preprocessor">#include &lt;<a class="code" href="compiler_8h.html" title="Additional support macros for compiler independance.">cfg/compiler.h</a>&gt;</span>
<a name="l00089"></a>00089 <span class="preprocessor">#include &lt;<a class="code" href="macros_8h.html">cfg/macros.h</a>&gt;</span> <span class="comment">//ROTL(), ROTR();</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">void</span>** HashNodePtr;
<a name="l00095"></a>00095 <span class="preprocessor">#define NODE_EMPTY(node)               (!*(node))</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#define HT_HAS_INTERNAL_KEY(ht)        (CONFIG_HT_OPTIONAL_INTERNAL_KEY &amp;&amp; ht-&gt;flags.key_internal)</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span>
<a name="l00099"></a><a class="code" href="hashtable_8c.html#a6b7e711b5ccf8e4c6dc39e9940d31009">00099</a> INLINE uint8_t *<a class="code" href="hashtable_8c.html#a6b7e711b5ccf8e4c6dc39e9940d31009" title="For hash tables with internal keys, compute the pointer to the internal key for a given node...">key_internal_get_ptr</a>(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a> *ht, HashNodePtr node)
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101     uint8_t* key_buf = ht-&gt;key_data.<a class="code" href="structHashTable.html#aec11db08aa9ca4a28b464319f6eb6329" title="Buckets of data.">mem</a>;
<a name="l00102"></a>00102     <span class="keywordtype">size_t</span> index;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104     <span class="comment">// Compute the index of the node and use it to move within the whole key buffer</span>
<a name="l00105"></a>00105     index = node - &amp;ht-&gt;<a class="code" href="structHashTable.html#aec11db08aa9ca4a28b464319f6eb6329" title="Buckets of data.">mem</a>[0];
<a name="l00106"></a>00106     <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(index &lt; (<span class="keywordtype">size_t</span>)(1 &lt;&lt; ht-&gt;<a class="code" href="structHashTable.html#a42ceb98f88dfb7d3c5a17a090189e7b8" title="Log2 of the size of the table.">max_elts_log2</a>));
<a name="l00107"></a>00107     key_buf += index * (<a class="code" href="group__hashtable.html#ga0b33ec1bf27aefc1fc52211218048ef4" title="Maximum length of the internal key (use (2^n)-1 for slight speedup)">INTERNAL_KEY_MAX_LENGTH</a> + 1);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     <span class="keywordflow">return</span> key_buf;
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 INLINE <span class="keywordtype">void</span> node_get_key(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a>* ht, HashNodePtr node, <span class="keyword">const</span> <span class="keywordtype">void</span>** key, uint8_t* key_length)
<a name="l00114"></a>00114 {
<a name="l00115"></a>00115     <span class="keywordflow">if</span> (HT_HAS_INTERNAL_KEY(ht))
<a name="l00116"></a>00116     {
<a name="l00117"></a>00117         uint8_t* k = <a class="code" href="hashtable_8c.html#a6b7e711b5ccf8e4c6dc39e9940d31009" title="For hash tables with internal keys, compute the pointer to the internal key for a given node...">key_internal_get_ptr</a>(ht, node);
<a name="l00118"></a>00118 
<a name="l00119"></a>00119         <span class="comment">// Key has its length stored in the first byte</span>
<a name="l00120"></a>00120         *key_length = *k++;
<a name="l00121"></a>00121         *key = k;
<a name="l00122"></a>00122     }
<a name="l00123"></a>00123     <span class="keywordflow">else</span>
<a name="l00124"></a>00124         *key = ht-&gt;key_data.<a class="code" href="structHashTable.html#a14795472b31b31fc933e1b57b9737d75" title="Hook to get the key.">hook</a>(*node, key_length);
<a name="l00125"></a>00125 }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 INLINE <span class="keywordtype">bool</span> node_key_match(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a>* ht, HashNodePtr node, <span class="keyword">const</span> <span class="keywordtype">void</span>* key, uint8_t key_length)
<a name="l00129"></a>00129 {
<a name="l00130"></a>00130     <span class="keyword">const</span> <span class="keywordtype">void</span>* key2;
<a name="l00131"></a>00131     uint8_t key2_length;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     node_get_key(ht, node, &amp;key2, &amp;key2_length);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="keywordflow">return</span> (key_length == key2_length &amp;&amp; memcmp(key, key2, key_length) == 0);
<a name="l00136"></a>00136 }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">static</span> uint16_t calc_hash(<span class="keyword">const</span> <span class="keywordtype">void</span>* _key, uint8_t key_length)
<a name="l00140"></a>00140 {
<a name="l00141"></a>00141     <span class="keyword">const</span> <span class="keywordtype">char</span>* key = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)_key;
<a name="l00142"></a>00142     uint16_t hash = key_length;
<a name="l00143"></a>00143     <span class="keywordtype">int</span> i;
<a name="l00144"></a>00144     <span class="keywordtype">int</span> len = (int)key_length;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <span class="keywordflow">for</span> (i = 0; i &lt; len; ++i)
<a name="l00147"></a>00147         hash = <a class="code" href="group__macros.html#ga6048cbe6fa55af3dd748a1bb208b556e" title="Macro for rotating bit left or right.">ROTL</a>(hash, 4) ^ key[i];
<a name="l00148"></a>00148 
<a name="l00149"></a>00149     <span class="keywordflow">return</span> hash ^ (hash &gt;&gt; 6) ^ (hash &gt;&gt; 13);
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="keyword">static</span> HashNodePtr perform_lookup(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a>* ht,
<a name="l00154"></a>00154                                   <span class="keyword">const</span> <span class="keywordtype">void</span>* key, uint8_t key_length)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156     uint16_t hash = calc_hash(key, key_length);
<a name="l00157"></a>00157     uint16_t mask = ((1 &lt;&lt; ht-&gt;<a class="code" href="structHashTable.html#a42ceb98f88dfb7d3c5a17a090189e7b8" title="Log2 of the size of the table.">max_elts_log2</a>) - 1);
<a name="l00158"></a>00158     uint16_t index = hash &amp; mask;
<a name="l00159"></a>00159     uint16_t first_index = index;
<a name="l00160"></a>00160     uint16_t step;
<a name="l00161"></a>00161     HashNodePtr node;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="comment">// Fast-path optimization: we check immediately if the current node</span>
<a name="l00164"></a>00164     <span class="comment">//  is the one we were looking for, so we save the computation of the</span>
<a name="l00165"></a>00165     <span class="comment">//  increment step in the common case.</span>
<a name="l00166"></a>00166     node = &amp;ht-&gt;<a class="code" href="structHashTable.html#aec11db08aa9ca4a28b464319f6eb6329" title="Buckets of data.">mem</a>[index];
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (NODE_EMPTY(node)
<a name="l00168"></a>00168         || node_key_match(ht, node, key, key_length))
<a name="l00169"></a>00169         <span class="keywordflow">return</span> node;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="comment">// Increment while going through the hash table in case of collision.</span>
<a name="l00172"></a>00172     <span class="comment">//  This implements the double-hash technique: we use the higher part</span>
<a name="l00173"></a>00173     <span class="comment">//  of the hash as a step increment instead of just going to the next</span>
<a name="l00174"></a>00174     <span class="comment">//  element, to minimize the collisions.</span>
<a name="l00175"></a>00175     <span class="comment">// Notice that the number must be odd to be sure that the whole table</span>
<a name="l00176"></a>00176     <span class="comment">//  is traversed. Actually MCD(table_size, step) must be 1, but</span>
<a name="l00177"></a>00177     <span class="comment">//  table_size is always a power of 2, so we just ensure that step is</span>
<a name="l00178"></a>00178     <span class="comment">//  never a multiple of 2.</span>
<a name="l00179"></a>00179     step = (<a class="code" href="group__macros.html#gad14c19eb02ca88957d5dca2d84681cc6" title="Macro for rotating bit left or right.">ROTR</a>(hash, ht-&gt;<a class="code" href="structHashTable.html#a42ceb98f88dfb7d3c5a17a090189e7b8" title="Log2 of the size of the table.">max_elts_log2</a>) &amp; mask) | 1;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     <span class="keywordflow">do</span>
<a name="l00182"></a>00182     {
<a name="l00183"></a>00183         index += step;
<a name="l00184"></a>00184         index &amp;= mask;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186         node = &amp;ht-&gt;<a class="code" href="structHashTable.html#aec11db08aa9ca4a28b464319f6eb6329" title="Buckets of data.">mem</a>[index];
<a name="l00187"></a>00187         <span class="keywordflow">if</span> (NODE_EMPTY(node)
<a name="l00188"></a>00188             || node_key_match(ht, node, key, key_length))
<a name="l00189"></a>00189             <span class="keywordflow">return</span> node;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         <span class="comment">// The check is done after the key compare. This actually causes</span>
<a name="l00192"></a>00192         <span class="comment">//  one more compare in the case the table is full (since the first</span>
<a name="l00193"></a>00193         <span class="comment">//  element was compared at the very start, and then at the end),</span>
<a name="l00194"></a>00194         <span class="comment">//  but it makes faster the common path where we enter this loop</span>
<a name="l00195"></a>00195         <span class="comment">//  for the first time, and index will not match first_index for</span>
<a name="l00196"></a>00196         <span class="comment">//  sure.</span>
<a name="l00197"></a>00197     } <span class="keywordflow">while</span> (index != first_index);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     <span class="keywordflow">return</span> NULL;
<a name="l00200"></a>00200 }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 
<a name="l00203"></a><a class="code" href="group__hashtable.html#ga642ef6e1807f57157197f92a3647ccff">00203</a> <span class="keywordtype">void</span> <a class="code" href="group__hashtable.html#ga642ef6e1807f57157197f92a3647ccff" title="Initialize (and clear) a hash table in a memory buffer.">ht_init</a>(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a>* ht)
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205     memset(ht-&gt;<a class="code" href="structHashTable.html#aec11db08aa9ca4a28b464319f6eb6329" title="Buckets of data.">mem</a>, 0, <span class="keyword">sizeof</span>(ht-&gt;<a class="code" href="structHashTable.html#aec11db08aa9ca4a28b464319f6eb6329" title="Buckets of data.">mem</a>[0]) * (1 &lt;&lt; ht-&gt;<a class="code" href="structHashTable.html#a42ceb98f88dfb7d3c5a17a090189e7b8" title="Log2 of the size of the table.">max_elts_log2</a>));
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keyword">static</span> <span class="keywordtype">bool</span> insert(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a>* ht, <span class="keyword">const</span> <span class="keywordtype">void</span>* key, uint8_t key_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* data)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211     HashNodePtr node;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     <span class="keywordflow">if</span> (!data)
<a name="l00214"></a>00214         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <span class="keywordflow">if</span> (HT_HAS_INTERNAL_KEY(ht))
<a name="l00217"></a>00217         key_length = MIN(key_length, (uint8_t)<a class="code" href="group__hashtable.html#ga0b33ec1bf27aefc1fc52211218048ef4" title="Maximum length of the internal key (use (2^n)-1 for slight speedup)">INTERNAL_KEY_MAX_LENGTH</a>);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     node = perform_lookup(ht, key, key_length);
<a name="l00220"></a>00220     <span class="keywordflow">if</span> (!node)
<a name="l00221"></a>00221         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="keywordflow">if</span> (HT_HAS_INTERNAL_KEY(ht))
<a name="l00224"></a>00224     {
<a name="l00225"></a>00225         uint8_t* k = <a class="code" href="hashtable_8c.html#a6b7e711b5ccf8e4c6dc39e9940d31009" title="For hash tables with internal keys, compute the pointer to the internal key for a given node...">key_internal_get_ptr</a>(ht, node);
<a name="l00226"></a>00226         *k++ = key_length;
<a name="l00227"></a>00227         memcpy(k, key, key_length);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     *node = data;
<a name="l00231"></a>00231     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00232"></a>00232 }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 
<a name="l00235"></a><a class="code" href="group__hashtable.html#ga7fa7adf45770670438f205ec1f17e8f6">00235</a> <span class="keywordtype">bool</span> <a class="code" href="group__hashtable.html#ga7fa7adf45770670438f205ec1f17e8f6" title="Insert an element into the hash table.">ht_insert_with_key</a>(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a>* ht, <span class="keyword">const</span> <span class="keywordtype">void</span>* key, uint8_t key_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* data)
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237 <span class="preprocessor">#ifdef _DEBUG</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!HT_HAS_INTERNAL_KEY(ht))
<a name="l00239"></a>00239     {
<a name="l00240"></a>00240         <span class="comment">// Construct a fake node and use it to match the key</span>
<a name="l00241"></a>00241         HashNodePtr node = &amp;data;
<a name="l00242"></a>00242         <span class="keywordflow">if</span> (!node_key_match(ht, node, key, key_length))
<a name="l00243"></a>00243         {
<a name="l00244"></a>00244             <a class="code" href="group__debug.html#ga954b4ed06e69edc987d7aeefc30e717e" title="Assert a pre-condition and give explanation message when assert fails.">ASSERT2</a>(0, <span class="stringliteral">&quot;parameter key is different from the external key&quot;</span>);
<a name="l00245"></a>00245             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248 <span class="preprocessor">#endif</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span>
<a name="l00250"></a>00250     <span class="keywordflow">return</span> insert(ht, key, key_length, data);
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 
<a name="l00254"></a><a class="code" href="group__hashtable.html#ga40e43fc231256c2ea0593c044ed90736">00254</a> <span class="keywordtype">bool</span> <a class="code" href="group__hashtable.html#ga40e43fc231256c2ea0593c044ed90736" title="Insert an element into the hash table.">ht_insert</a>(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a>* ht, <span class="keyword">const</span> <span class="keywordtype">void</span>* data)
<a name="l00255"></a>00255 {
<a name="l00256"></a>00256     <span class="keyword">const</span> <span class="keywordtype">void</span>* key;
<a name="l00257"></a>00257     uint8_t key_length;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="preprocessor">#ifdef _DEBUG</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (HT_HAS_INTERNAL_KEY(ht))
<a name="l00261"></a>00261     {
<a name="l00262"></a>00262         <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(<span class="stringliteral">&quot;parameter cannot be a hash table with internal keys - use ht_insert_with_key()&quot;</span>
<a name="l00263"></a>00263                &amp;&amp; 0);
<a name="l00264"></a>00264         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00265"></a>00265     }
<a name="l00266"></a>00266 <span class="preprocessor">#endif</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span>
<a name="l00268"></a>00268     key = ht-&gt;key_data.<a class="code" href="structHashTable.html#a14795472b31b31fc933e1b57b9737d75" title="Hook to get the key.">hook</a>(data, &amp;key_length);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     <span class="keywordflow">return</span> insert(ht, key, key_length, data);
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 
<a name="l00274"></a><a class="code" href="group__hashtable.html#gaba057880cc98ec88e0fcd46b54bb5a71">00274</a> <span class="keyword">const</span> <span class="keywordtype">void</span>* <a class="code" href="group__hashtable.html#gaba057880cc98ec88e0fcd46b54bb5a71" title="Find an element in the hash table.">ht_find</a>(<span class="keyword">struct</span> <a class="code" href="structHashTable.html" title="Hash table description.">HashTable</a>* ht, <span class="keyword">const</span> <span class="keywordtype">void</span>* key, uint8_t key_length)
<a name="l00275"></a>00275 {
<a name="l00276"></a>00276     HashNodePtr node;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     <span class="keywordflow">if</span> (HT_HAS_INTERNAL_KEY(ht))
<a name="l00279"></a>00279         key_length = MIN(key_length, (uint8_t)<a class="code" href="group__hashtable.html#ga0b33ec1bf27aefc1fc52211218048ef4" title="Maximum length of the internal key (use (2^n)-1 for slight speedup)">INTERNAL_KEY_MAX_LENGTH</a>);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     node = perform_lookup(ht, key, key_length);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="keywordflow">if</span> (!node || NODE_EMPTY(node))
<a name="l00284"></a>00284         <span class="keywordflow">return</span> NULL;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="keywordflow">return</span> *node;
<a name="l00287"></a>00287 }
</pre></div></div>
</div>


