

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_121029064a25b6c8df3db8e9bf5fc73a.html">kern</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">signal.c File Reference</div>  </div>
</div>
<div class="contents">

<p>IPC signals implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="signal_8h_source.html">signal.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cfg__timer_8h_source.html">cfg/cfg_timer.h</a>&quot;</code><br/>
<code>#include &lt;<a class="el" href="debug_8h_source.html">cfg/debug.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="depend_8h_source.html">cfg/depend.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="cpu_2irq_8h_source.html">cpu/irq.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="proc_8h_source.html">kern/proc.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="proc__p_8h_source.html">kern/proc_p.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="timer_8h_source.html">drv/timer.h</a>&gt;</code><br/>
</div>
<p><a href="signal_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>IPC signals implementation. </p>
<p>Signals are a low-level IPC primitive. A process receives a signal when some external event has happened. Like interrupt requests, signals do not carry any additional information. If processing a specific event requires additional data, the process must obtain it through some other mechanism.</p>
<p>Despite the name, one shouldn't confuse these signals with POSIX signals. POSIX signals are usually executed synchronously, like software interrupts.</p>
<p>Signals are very low overhead. Using them exclusively to wait for multiple asynchronous events results in very simple dispatch logic with low processor and resource usage.</p>
<p>The "event" module is a higher-level interface that can optionally deliver signals to processes. Messages provide even higher-level IPC services built on signals. Semaphore arbitration is also implemented using signals.</p>
<p>In this implementation, each process has a limited set of signal bits (usually 32) and can wait for multiple signals at the same time using <a class="el" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait()</a>. Signals can also be polled using <a class="el" href="group__kern__signal.html#ga493434e7efb03991eb6c73152207dc35" title="Check if any of the signals in sigs has occurred and clear them.">sig_check()</a>, but a process spinning on its signals usually defeats their purpose of providing a multitasking-friendly infrastructure for event-driven applications.</p>
<p>Signals are like flags: they are either active or inactive. After an external event has delivered a particular signal, it remains raised until the process acknowledges it using either <a class="el" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait()</a> or <a class="el" href="group__kern__signal.html#ga493434e7efb03991eb6c73152207dc35" title="Check if any of the signals in sigs has occurred and clear them.">sig_check()</a>. Counting signals is not a reliable way to count how many times a particular event has occurred, because the same signal may be delivered twice before the process can notice.</p>
<p>Signals can be delivered synchronously via <a class="el" href="group__kern__signal.html#ga9532c2e6c4894d567f648530b9500e8c" title="Send the signals sigs to the process proc and immeditaly dispatch it for execution.">sig_send()</a> or asynchronously via <a class="el" href="group__kern__signal.html#ga5348234f4750db67796ad17d82bb30fc" title="Send the signals sigs to the process proc.">sig_post()</a>.</p>
<p>In the synchronous case the process is awakened if it was waiting for any signal and immediately dispatched for execution via a direct context switch, if its priority is greater than the running process.</p>
<pre><ul>
<li>Synchronous-signal delivery:</li>
</ul>
</pre><pre>     [P1]____sig_send()____proc_wakeup()____[P2]
 </pre><p>In the asynchronous case, the process is scheduled for execution as a consequence of the delivery, but it will be dispatched by the scheduler as usual, according to the scheduling policy.</p>
<pre><ul>
<li>Asynchronous-signal delivery:</li>
</ul>
</pre><pre>     [P1]____sig_post()____[P1]____proc_schedule()____[P2]
 </pre><p>In this way, any execution context, including an interrupt handler, can deliver a signal to a process. However, synchronous signal delivery from a non-sleepable context (like an interrupt handler) is forbidden in order to avoid potential deadlock conditions. Instead, <a class="el" href="group__kern__signal.html#ga5348234f4750db67796ad17d82bb30fc" title="Send the signals sigs to the process proc.">sig_post()</a> can be used from any context, expecially from interrupt context or when the preemption is disabled.</p>
<p>Multiple independent signals may be delivered at once with a single invocation of <a class="el" href="group__kern__signal.html#ga9532c2e6c4894d567f648530b9500e8c" title="Send the signals sigs to the process proc and immeditaly dispatch it for execution.">sig_send()</a> or <a class="el" href="group__kern__signal.html#ga5348234f4750db67796ad17d82bb30fc" title="Send the signals sigs to the process proc.">sig_post()</a>, although this is rarely useful.</p>
<h2><a class="anchor" id="signal_allocation"></a>
Signal Allocation</h2>
<p>There's no hardcoded mapping of specific events to signal bits. The meaning of a particular signal bit is defined by an agreement between the delivering entity and the receiving process. For instance, a terminal driver may be designed to deliver a signal bit called SIG_INT when it reads the CTRL-C sequence from the keyboard, and a process may react to it by quitting.</p>
<h2><a class="anchor" id="sig_single"></a>
SIG_SINGLE</h2>
<p>The SIG_SINGLE bit is reserved as a convenient shortcut in those simple scenarios where a process needs to wait on just one event synchronously. By using SIG_SINGLE, there's no need to allocate a specific signal from the free pool. The constraints for safely accessing SIG_SINGLE are:</p>
<ul>
<li>The process MUST <a class="el" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait()</a> exclusively on SIG_SINGLE</li>
<li>SIG_SIGNAL MUST NOT be left pending after use (<a class="el" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait()</a> will reset it automatically)</li>
<li>Do not sleep between starting the asynchronous task that will fire SIG_SINGLE, and the call to <a class="el" href="group__kern__signal.html#ga83accf7cc9eb33c748b2670b8f272060" title="Sleep until any of the signals in sigs occurs.">sig_wait()</a>.</li>
<li>Do not call system functions that may implicitly sleep, such as <a class="el" href="group__drv__timers.html#gac497fa7bd2e2ee77b4dcf765b1e24894" title="Wait for the specified amount of timer ticks.">timer_delayTicks()</a>.</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="signal_8c_source.html">signal.c</a>.</p>
</div></div>


