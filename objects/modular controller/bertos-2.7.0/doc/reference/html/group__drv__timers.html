

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Timer module</div>  </div>
<div class="ingroups"><a class="el" href="group__core.html">BeRTOS core functionality</a></div></div>
<div class="contents">

<p>Hardware independent timer driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTimer.html">Timer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The timer driver supports multiple synchronous timers that can trigger an event when they expire.  <a href="structTimer.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga40ea9215551098e4d4e1f58cc687e69b">synctimer_abort</a>(t)&#160;&#160;&#160;timer_abort(t)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gadc48ccae1f609e329b7bcb153622b8c4">timer_clock</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system tick counter (expressed in ticks)  <a href="#gadc48ccae1f609e329b7bcb153622b8c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga91dc8903e46f81c8490adaec8f2b5069">timer_clock_unlocked</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Faster version of <a class="el" href="group__drv__timers.html#gadc48ccae1f609e329b7bcb153622b8c4" title="Return the system tick counter (expressed in ticks)">timer_clock()</a>, to be called only when the timer interrupt is disabled (DISABLE_INTS) or overridden by a higher-priority or non-nesting interrupt.  <a href="#ga91dc8903e46f81c8490adaec8f2b5069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga1058ec50197d9ff9483be09612022929">ms_to_ticks</a> (<a class="el" href="compiler_8h.html#ac6f57181b1edf6b9b510c8a1a66201c1">mtime_t</a> ms)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>ms</em> [ms] to ticks.  <a href="#ga1058ec50197d9ff9483be09612022929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gafacb3940d04dceeabb9fe405fdfc69d9">us_to_ticks</a> (<a class="el" href="compiler_8h.html#ac439914e9bd78be702b64d8dbc8816aa">utime_t</a> us)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>us</em> [us] to ticks.  <a href="#gafacb3940d04dceeabb9fe405fdfc69d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler_8h.html#ac6f57181b1edf6b9b510c8a1a66201c1">mtime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gadf5cdcf8fd13e7b4c55a4050de5e603c">ticks_to_ms</a> (<a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> ticks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>ticks</em> [ticks] to ms.  <a href="#gadf5cdcf8fd13e7b4c55a4050de5e603c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler_8h.html#ac439914e9bd78be702b64d8dbc8816aa">utime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga4e220e6a96836ebf697dd5a09181f69f">ticks_to_us</a> (<a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> ticks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>ticks</em> [ticks] to us.  <a href="#ga4e220e6a96836ebf697dd5a09181f69f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70225249121c80ec37dd84f1ad3c3aeb"></a><!-- doxytag: member="drv_timers::us_to_hptime" ref="ga70225249121c80ec37dd84f1ad3c3aeb" args="(utime_t us)" -->
<a class="el" href="timer__lpc2_8h.html#a39ca00de3e892de8f389dd23dc6f1053">hptime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga70225249121c80ec37dd84f1ad3c3aeb">us_to_hptime</a> (<a class="el" href="compiler_8h.html#ac439914e9bd78be702b64d8dbc8816aa">utime_t</a> us)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>us</em> [us] to hpticks. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9a389338d010ad77bf863d4fcef26d4"></a><!-- doxytag: member="drv_timers::hptime_to_us" ref="gaf9a389338d010ad77bf863d4fcef26d4" args="(hptime_t hpticks)" -->
<a class="el" href="compiler_8h.html#ac439914e9bd78be702b64d8dbc8816aa">utime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gaf9a389338d010ad77bf863d4fcef26d4">hptime_to_us</a> (<a class="el" href="timer__lpc2_8h.html#a39ca00de3e892de8f389dd23dc6f1053">hptime_t</a> hpticks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>hpticks</em> [hptime] to usec. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gac497fa7bd2e2ee77b4dcf765b1e24894">timer_delayTicks</a> (<a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> delay)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the specified amount of timer ticks.  <a href="#gac497fa7bd2e2ee77b4dcf765b1e24894"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gace6fb3d382bd740f9cee1b139e12f7a6">timer_delay</a> (<a class="el" href="compiler_8h.html#ac6f57181b1edf6b9b510c8a1a66201c1">mtime_t</a> delay)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait some time [ms].  <a href="#gace6fb3d382bd740f9cee1b139e12f7a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga1243060e36ef4739b9d5cc50e8e4f27a">timer_busyWait</a> (<a class="el" href="timer__lpc2_8h.html#a39ca00de3e892de8f389dd23dc6f1053">hptime_t</a> delay)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy wait until the specified amount of high-precision ticks have elapsed.  <a href="#ga1243060e36ef4739b9d5cc50e8e4f27a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga3407c46c6b439217c694ed4372336330">timer_delayHp</a> (<a class="el" href="timer__lpc2_8h.html#a39ca00de3e892de8f389dd23dc6f1053">hptime_t</a> delay)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the specified amount of time (expressed in microseconds).  <a href="#ga3407c46c6b439217c694ed4372336330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga31b280936e453dff724b326c0309af4c">timer_add</a> (<a class="el" href="structTimer.html">Timer</a> *timer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified timer to the software timer service queue.  <a href="#ga31b280936e453dff724b326c0309af4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTimer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga083b16dd889741b74ca1142fd6498ae9">timer_abort</a> (<a class="el" href="structTimer.html">Timer</a> *timer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a timer from the timers queue before it has expired.  <a href="#ga083b16dd889741b74ca1142fd6498ae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga05183713aaa5b341bcda25af3837a111">timer_setSoftint</a> (<a class="el" href="structTimer.html">Timer</a> *timer, <a class="el" href="compiler_8h.html#a29da6a2c5167c69f4e05da8466f2b339">Hook</a> func, <a class="el" href="compiler_8h.html#afebdfc027148249641ae51fb8c7914fc">iptr_t</a> user_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timer so that it calls an user hook when it expires.  <a href="#ga05183713aaa5b341bcda25af3837a111"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga74311fd08b3bfdecb496f16b7465715b">timer_setDelay</a> (<a class="el" href="structTimer.html">Timer</a> *timer, <a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> delay)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timer delay (the time before the event will be triggered)  <a href="#ga74311fd08b3bfdecb496f16b7465715b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gaceda10d0921ceb0e991744fd6760b454">synctimer_add</a> (<a class="el" href="structTimer.html">Timer</a> *timer, <a class="el" href="structList.html">List</a> *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <em>timer</em> to <em>queue</em>.  <a href="#gaceda10d0921ceb0e991744fd6760b454"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga8ef6c10d089728296204e5e03cf39863">synctimer_poll</a> (<a class="el" href="structList.html">List</a> *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous timer based scheduler polling routine.  <a href="#ga8ef6c10d089728296204e5e03cf39863"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0b325030f6245240487f9ff4e885f88"></a><!-- doxytag: member="drv_timers::timer_setEvent" ref="gab0b325030f6245240487f9ff4e885f88" args="(Timer *timer)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gab0b325030f6245240487f9ff4e885f88">timer_setEvent</a> (<a class="el" href="structTimer.html">Timer</a> *timer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timer so that it sends a event notification when it expires. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9265c1b69b3c4fcd509e227b56bc3e45"></a><!-- doxytag: member="drv_timers::timer_waitEvent" ref="ga9265c1b69b3c4fcd509e227b56bc3e45" args="(Timer *timer)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga9265c1b69b3c4fcd509e227b56bc3e45">timer_waitEvent</a> (<a class="el" href="structTimer.html">Timer</a> *timer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the timer expires. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa68dbdace6460cd22586a63f6da31290"></a><!-- doxytag: member="drv_timers::timer_setSignal" ref="gaa68dbdace6460cd22586a63f6da31290" args="(Timer *timer, struct Process *proc, sigmask_t sigs)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#gaa68dbdace6460cd22586a63f6da31290">timer_setSignal</a> (<a class="el" href="structTimer.html">Timer</a> *timer, struct Process *proc, <a class="el" href="compiler_8h.html#a8eab9d9d79ff58f19a5a51e821d95330">sigmask_t</a> sigs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timer so that it sends a signal when it expires. <br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b50915a13f7782dff7fb06333b1aae8"></a><!-- doxytag: member="drv_timers::_clock" ref="ga4b50915a13f7782dff7fb06333b1aae8" args="" -->
volatile <a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drv__timers.html#ga4b50915a13f7782dff7fb06333b1aae8">_clock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Master system clock (1 tick accuracy) <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Hardware independent timer driver. </p>
<p>All timer related functions are implemented in this module. You have several options to use timers: </p>
<ul>
<li>simple delay: just use <a class="el" href="group__drv__timers.html#gace6fb3d382bd740f9cee1b139e12f7a6" title="Wait some time [ms].">timer_delay()</a> if you want to wait for a few milliseconds; </li>
<li>delay with callback: create a timer structure and use <a class="el" href="group__drv__timers.html#ga74311fd08b3bfdecb496f16b7465715b" title="Set the timer delay (the time before the event will be triggered)">timer_setDelay()</a> and <a class="el" href="group__drv__timers.html#ga05183713aaa5b341bcda25af3837a111" title="Set the timer so that it calls an user hook when it expires.">timer_setSoftint()</a> to set the callback; </li>
<li>delay with signal: same as above but use <a class="el" href="group__drv__timers.html#gaa68dbdace6460cd22586a63f6da31290" title="Set the timer so that it sends a signal when it expires.">timer_setSignal()</a> to set specify which signal to send. </li>
<li>simple synchronous timer based scheduler: use <a class="el" href="group__drv__timers.html#gaceda10d0921ceb0e991744fd6760b454" title="Add timer to queue.">synctimer_add()</a> to schedule an event in a user provided queue.</li>
</ul>
<p>Whenever a timer expires you need to explicitly arm it again with <a class="el" href="group__drv__timers.html#ga31b280936e453dff724b326c0309af4c" title="Add the specified timer to the software timer service queue.">timer_add()</a>. If you want to abort a timer, use <a class="el" href="group__drv__timers.html#ga083b16dd889741b74ca1142fd6498ae9" title="Remove a timer from the timers queue before it has expired.">timer_abort()</a>. You can use conversion macros when using msecs to specify the delay.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga40ea9215551098e4d4e1f58cc687e69b"></a><!-- doxytag: member="timer.h::synctimer_abort" ref="ga40ea9215551098e4d4e1f58cc687e69b" args="(t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define synctimer_abort</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t</td><td>)</td>
          <td>&#160;&#160;&#160;timer_abort(t)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__drv__timers.html#ga083b16dd889741b74ca1142fd6498ae9" title="Remove a timer from the timers queue before it has expired.">timer_abort</a> </dd></dl>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00309">309</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga1058ec50197d9ff9483be09612022929"></a><!-- doxytag: member="timer.h::ms_to_ticks" ref="ga1058ec50197d9ff9483be09612022929" args="(mtime_t ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> ms_to_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#ac6f57181b1edf6b9b510c8a1a66201c1">mtime_t</a>&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert <em>ms</em> [ms] to ticks. </p>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00157">157</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaceda10d0921ceb0e991744fd6760b454"></a><!-- doxytag: member="timer.h::synctimer_add" ref="gaceda10d0921ceb0e991744fd6760b454" args="(Timer *timer, List *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synctimer_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTimer.html">Timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structList.html">List</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add <em>timer</em> to <em>queue</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__drv__timers.html#ga8ef6c10d089728296204e5e03cf39863" title="Simple synchronous timer based scheduler polling routine.">synctimer_poll()</a> for details. </dd></dl>

<p>Definition at line <a class="el" href="timer_8c_source.html#l00215">215</a> of file <a class="el" href="timer_8c_source.html">timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ef6c10d089728296204e5e03cf39863"></a><!-- doxytag: member="timer.h::synctimer_poll" ref="ga8ef6c10d089728296204e5e03cf39863" args="(List *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synctimer_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structList.html">List</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simple synchronous timer based scheduler polling routine. </p>
<p>Sometimes you would like to have a proper scheduler, but you can't afford it due to memory constraints.</p>
<p>This is a simple replacement: you can create events and call them periodically at specific time intervals. All you have to do is to set up normal timers, and call <a class="el" href="group__drv__timers.html#gaceda10d0921ceb0e991744fd6760b454" title="Add timer to queue.">synctimer_add()</a> instead of <a class="el" href="group__drv__timers.html#ga31b280936e453dff724b326c0309af4c" title="Add the specified timer to the software timer service queue.">timer_add()</a> to add the events to your specific queue. Then, in the main loop or wherever you want, you can call <a class="el" href="group__drv__timers.html#ga8ef6c10d089728296204e5e03cf39863" title="Simple synchronous timer based scheduler polling routine.">synctimer_poll()</a> to process expired events. The associated callbacks will be executed. As this is done synchronously you don't have to worry about race conditions. You can kill an event by simply calling <a class="el" href="group__drv__timers.html#ga40ea9215551098e4d4e1f58cc687e69b">synctimer_abort()</a>. </p>

<p>Definition at line <a class="el" href="timer_8c_source.html#l00237">237</a> of file <a class="el" href="timer_8c_source.html">timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gadf5cdcf8fd13e7b4c55a4050de5e603c"></a><!-- doxytag: member="timer.h::ticks_to_ms" ref="gadf5cdcf8fd13e7b4c55a4050de5e603c" args="(ticks_t ticks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler_8h.html#ac6f57181b1edf6b9b510c8a1a66201c1">mtime_t</a> ticks_to_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td>
          <td class="paramname"><em>ticks</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert <em>ticks</em> [ticks] to ms. </p>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00181">181</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e220e6a96836ebf697dd5a09181f69f"></a><!-- doxytag: member="timer.h::ticks_to_us" ref="ga4e220e6a96836ebf697dd5a09181f69f" args="(ticks_t ticks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler_8h.html#ac439914e9bd78be702b64d8dbc8816aa">utime_t</a> ticks_to_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td>
          <td class="paramname"><em>ticks</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert <em>ticks</em> [ticks] to us. </p>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00193">193</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga083b16dd889741b74ca1142fd6498ae9"></a><!-- doxytag: member="timer.h::timer_abort" ref="ga083b16dd889741b74ca1142fd6498ae9" args="(Timer *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTimer.html">Timer</a>* timer_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTimer.html">Timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a timer from the timers queue before it has expired. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Attempting to remove a timer already expired cause undefined behaviour. </dd></dl>

<p>Definition at line <a class="el" href="timer_8c_source.html#l00176">176</a> of file <a class="el" href="timer_8c_source.html">timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga31b280936e453dff724b326c0309af4c"></a><!-- doxytag: member="timer.h::timer_add" ref="ga31b280936e453dff724b326c0309af4c" args="(Timer *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTimer.html">Timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add the specified timer to the software timer service queue. </p>
<p>When the delay indicated by the timer expires, the timer device will execute the event associated with it.</p>
<p>You should not call this function on an already running timer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Interrupt safe </dd></dl>

<p>Definition at line <a class="el" href="timer_8c_source.html#l00165">165</a> of file <a class="el" href="timer_8c_source.html">timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1243060e36ef4739b9d5cc50e8e4f27a"></a><!-- doxytag: member="timer.h::timer_busyWait" ref="ga1243060e36ef4739b9d5cc50e8e4f27a" args="(hptime_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_busyWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="timer__lpc2_8h.html#a39ca00de3e892de8f389dd23dc6f1053">hptime_t</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Busy wait until the specified amount of high-precision ticks have elapsed. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is interrupt safe, the only requirement is a running hardware timer. </dd></dl>

<p>Definition at line <a class="el" href="timer_8c_source.html#l00285">285</a> of file <a class="el" href="timer_8c_source.html">timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gadc48ccae1f609e329b7bcb153622b8c4"></a><!-- doxytag: member="timer.h::timer_clock" ref="gadc48ccae1f609e329b7bcb153622b8c4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> timer_clock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the system tick counter (expressed in ticks) </p>
<p>The result is guaranteed to increment monotonically, but client code must be tolerant with respect to overflows.</p>
<p>The following code is safe:</p>
<div class="fragment"><pre class="fragment">   drop_teabag();
   <a class="code" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88" title="Type for time expressed in ticks.">ticks_t</a> tea_start_time = <a class="code" href="group__drv__timers.html#gadc48ccae1f609e329b7bcb153622b8c4" title="Return the system tick counter (expressed in ticks)">timer_clock</a>();

   <span class="keywordflow">for</span> (;;)
   {
       <span class="keywordflow">if</span> (<a class="code" href="group__drv__timers.html#gadc48ccae1f609e329b7bcb153622b8c4" title="Return the system tick counter (expressed in ticks)">timer_clock</a>() - tea_start_time &gt; TEAPOT_DELAY)
       {
           printf(<span class="stringliteral">&quot;Your tea, Sir.\n&quot;</span>);
           <span class="keywordflow">break</span>;
       }
       patience();
   }
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>This function must disable interrupts on 8/16bit CPUs because the clock variable is larger than the processor word size and can't be copied atomically. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__drv__timers.html#gace6fb3d382bd740f9cee1b139e12f7a6" title="Wait some time [ms].">timer_delay()</a> </dd></dl>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00134">134</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga91dc8903e46f81c8490adaec8f2b5069"></a><!-- doxytag: member="timer.h::timer_clock_unlocked" ref="ga91dc8903e46f81c8490adaec8f2b5069" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> timer_clock_unlocked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Faster version of <a class="el" href="group__drv__timers.html#gadc48ccae1f609e329b7bcb153622b8c4" title="Return the system tick counter (expressed in ticks)">timer_clock()</a>, to be called only when the timer interrupt is disabled (DISABLE_INTS) or overridden by a higher-priority or non-nesting interrupt. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__drv__timers.html#gadc48ccae1f609e329b7bcb153622b8c4" title="Return the system tick counter (expressed in ticks)">timer_clock</a> </dd></dl>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00150">150</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="gace6fb3d382bd740f9cee1b139e12f7a6"></a><!-- doxytag: member="timer.h::timer_delay" ref="gace6fb3d382bd740f9cee1b139e12f7a6" args="(mtime_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#ac6f57181b1edf6b9b510c8a1a66201c1">mtime_t</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait some time [ms]. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>CPU is released while waiting so you don't have to call <a class="el" href="power_8h.html#aa0eaaa5f710ff7d97371d8053e73e692" title="Let the CPU rest in tight busy loops.">cpu_relax()</a> explicitly. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Time to wait [ms]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00231">231</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3407c46c6b439217c694ed4372336330"></a><!-- doxytag: member="timer.h::timer_delayHp" ref="ga3407c46c6b439217c694ed4372336330" args="(hptime_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_delayHp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="timer__lpc2_8h.html#a39ca00de3e892de8f389dd23dc6f1053">hptime_t</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the specified amount of time (expressed in microseconds). </p>

<p>Definition at line <a class="el" href="timer_8c_source.html#l00328">328</a> of file <a class="el" href="timer_8c_source.html">timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac497fa7bd2e2ee77b4dcf765b1e24894"></a><!-- doxytag: member="timer.h::timer_delayTicks" ref="gac497fa7bd2e2ee77b4dcf765b1e24894" args="(ticks_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_delayTicks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the specified amount of timer ticks. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Sleeping while preemption is disabled fallbacks to a busy wait sleep. </dd></dl>

<p>Definition at line <a class="el" href="timer_8c_source.html#l00250">250</a> of file <a class="el" href="timer_8c_source.html">timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga74311fd08b3bfdecb496f16b7465715b"></a><!-- doxytag: member="timer.h::timer_setDelay" ref="ga74311fd08b3bfdecb496f16b7465715b" args="(Timer *timer, ticks_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_setDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTimer.html">Timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the timer delay (the time before the event will be triggered) </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It's illegal to change the delay of the timer when it's still running. </dd></dl>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00300">300</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga05183713aaa5b341bcda25af3837a111"></a><!-- doxytag: member="timer.h::timer_setSoftint" ref="ga05183713aaa5b341bcda25af3837a111" args="(Timer *timer, Hook func, iptr_t user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_setSoftint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTimer.html">Timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#a29da6a2c5167c69f4e05da8466f2b339">Hook</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#afebdfc027148249641ae51fb8c7914fc">iptr_t</a>&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the timer so that it calls an user hook when it expires. </p>
<p>Sometimes you may want to use the same callback for different events, so you must have different data to operate on. The user_data parameter is such data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td><a class="el" href="structTimer.html" title="The timer driver supports multiple synchronous timers that can trigger an event when they expire...">Timer</a> struct to set the callback to </td></tr>
    <tr><td class="paramname">func</td><td>Function that will be called when the timer expires </td></tr>
    <tr><td class="paramname">user_data</td><td>Additional data you may want to pass to the callback </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00289">289</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafacb3940d04dceeabb9fe405fdfc69d9"></a><!-- doxytag: member="timer.h::us_to_ticks" ref="gafacb3940d04dceeabb9fe405fdfc69d9" args="(utime_t us)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> us_to_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#ac439914e9bd78be702b64d8dbc8816aa">utime_t</a>&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert <em>us</em> [us] to ticks. </p>

<p>Definition at line <a class="el" href="timer_8h_source.html#l00169">169</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
</div>


