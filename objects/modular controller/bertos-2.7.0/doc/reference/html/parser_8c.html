

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_5b85ff6a72c79a71106598e13514bf0c.html">mware</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parser.c File Reference</div>  </div>
</div>
<div class="contents">

<p>Channel protocol parser and commands.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="parser_8h_source.html">parser.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cfg__parser_8h_source.html">cfg/cfg_parser.h</a>&quot;</code><br/>
<code>#include &lt;<a class="el" href="io_2kfile_8h_source.html">io/kfile.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="hashtable_8h_source.html">struct/hashtable.h</a>&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
</div>
<p><a href="parser_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4586a6acbce0fb5c2784256b2e894663"></a><!-- doxytag: member="parser.c::get_key_from_command" ref="a4586a6acbce0fb5c2784256b2e894663" args="(const void *cmd, uint8_t *length)" -->
static const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a4586a6acbce0fb5c2784256b2e894663">get_key_from_command</a> (const void *cmd, uint8_t *length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashtable hook to extract the key from a command. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95f7ef289ab5c2469ae4dd61fd3dc8e7"></a><!-- doxytag: member="parser.c::DECLARE_HASHTABLE_STATIC" ref="a95f7ef289ab5c2469ae4dd61fd3dc8e7" args="(commands, CONFIG_MAX_COMMANDS_NUMBER, get_key_from_command)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a95f7ef289ab5c2469ae4dd61fd3dc8e7">DECLARE_HASHTABLE_STATIC</a> (commands, CONFIG_MAX_COMMANDS_NUMBER, get_key_from_command)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashtable that handles the commands that can be executed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#ac7c644189d2470dc97c2730b2b49abe8">get_word</a> (const char **begin, const char **end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenize one word at a time from a text.  <a href="#ac7c644189d2470dc97c2730b2b49abe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a9769ddcd7dc55cae2a43b8513ee01f26">parseArgs</a> (const char *fmt, const char *input, <a class="el" href="unionparms.html">parms</a> argv[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Command arguments parser.  <a href="#a9769ddcd7dc55cae2a43b8513ee01f26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a756e545c00b74d876d560e806423bb99"></a><!-- doxytag: member="parser.c::parser_rl_match" ref="a756e545c00b74d876d560e806423bb99" args="(UNUSED_ARG(void *, dummy), const char *word, int word_len)" -->
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a756e545c00b74d876d560e806423bb99">parser_rl_match</a> (UNUSED_ARG(void *, dummy), const char *word, int word_len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook provided by the parser for matching of command names (TAB completion) for readline. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gac607092de13a1f01e3c9c34d5cfb8ad2">parser_get_cmd_template</a> (const char *input)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the template for the command contained in the text line.  <a href="group__parser.html#gac607092de13a1f01e3c9c34d5cfb8ad2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gaef65813364192b283dc9dbbf7915eaaf">parser_get_cmd_arguments</a> (const char *input, const struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *cmdp, <a class="el" href="unionparms.html">parms</a> args[CONFIG_PARSER_MAX_ARGS])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the arguments for the command contained in the text line.  <a href="group__parser.html#gaef65813364192b283dc9dbbf7915eaaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gaea5ddc7bf6470ada78b70f24c369b16d">parser_process_line</a> (const char *input)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Command input handler.  <a href="group__parser.html#gaea5ddc7bf6470ada78b70f24c369b16d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gad5eec249e05ec5cadcde55382291773d">parser_register_cmd</a> (const struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *cmd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new command into the parser.  <a href="group__parser.html#gad5eec249e05ec5cadcde55382291773d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#ga412e2a44f5de56422d2c62bbae3685d0">parser_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the parser module.  <a href="group__parser.html#ga412e2a44f5de56422d2c62bbae3685d0"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Channel protocol parser and commands. </p>
<p>This file contains the channel protocol parser and the definition of the protocol commands. Commands are defined in a "CmdTemplate" type array, containing:</p>
<ul>
<li>the name of the command,</li>
<li>the arguments it expects to receive,</li>
<li>the output values,</li>
<li>the name of the function implementing the command.</li>
</ul>
<p>The arguments and results are passed to command function using an union: the element of the union to use for each argument is determined by format strings present in the <a class="el" href="structCmdTemplate.html" title="Define a command that can be tokenized by the parser.">CmdTemplate</a> table.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd>
<dd>
Stefano Fedrigo &lt;<a href="mailto:aleph@develer.com">aleph@develer.com</a>&gt; </dd>
<dd>
Giovanni Bajo &lt;<a href="mailto:rasky@develer.com">rasky@develer.com</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="parser_8c_source.html">parser.c</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac7c644189d2470dc97c2730b2b49abe8"></a><!-- doxytag: member="parser.c::get_word" ref="ac7c644189d2470dc97c2730b2b49abe8" args="(const char **begin, const char **end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool get_word </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tokenize one word at a time from a text. </p>
<p>This function is similar to strtok, but does not use any implicit context, nor it does modify the input buffer in any form. The word is returned as a STL-like [begin,end) range.</p>
<p>To extract the first word, make both begin and end point at the start of the text, and call the function. Then, subsequent calls will return the following words (assuming the begin/end variable are not modified between calls).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Will contain the index of the first character of the word </td></tr>
    <tr><td class="paramname">end</td><td>Will contain the index of the character after the last character of the word</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if a word was extracted, false if we got to the end of the string without extracting any word. </dd></dl>

<p>Definition at line <a class="el" href="parser_8c_source.html#l00092">92</a> of file <a class="el" href="parser_8c_source.html">parser.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9769ddcd7dc55cae2a43b8513ee01f26"></a><!-- doxytag: member="parser.c::parseArgs" ref="a9769ddcd7dc55cae2a43b8513ee01f26" args="(const char *fmt, const char *input, parms argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool parseArgs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionparms.html">parms</a>&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Command arguments parser. </p>
<p>Using the format pointed by the argument fmt parses the input string filling the array argv with input parameters of the correct type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>Parameters format string. </td></tr>
    <tr><td class="paramname">input</td><td>Input string. </td></tr>
    <tr><td class="paramname">argv</td><td>Array filled with parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False in case of errors, otherwise true. </dd></dl>

<p>Definition at line <a class="el" href="parser_8c_source.html#l00123">123</a> of file <a class="el" href="parser_8c_source.html">parser.c</a>.</p>

</div>
</div>
</div>


