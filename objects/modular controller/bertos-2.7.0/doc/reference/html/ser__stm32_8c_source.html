

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_a5de7543e32a5f073daa04f8834eb5fd.html">cpu</a>      </li>
      <li class="navelem"><a class="el" href="dir_b85b1b77342b0233aa6bdb4655adc5e9.html">cortex-m3</a>      </li>
      <li class="navelem"><a class="el" href="dir_67d33e4ffe4ff938d746541f95b62a0f.html">drv</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ser_stm32.c</div>  </div>
</div>
<div class="contents">
<a href="ser__stm32_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="ser__stm32_8h.html" title="STM32F10xx UART interface driver.">ser_stm32.h</a>&quot;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="cfg__ser_8h.html" title="Configuration file for serial module.">cfg/cfg_ser.h</a>&quot;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;<a class="code" href="macros_8h.html">cfg/macros.h</a>&gt;</span> <span class="comment">/* for BV() */</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="debug_8h.html">cfg/debug.h</a>&gt;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;<a class="code" href="gpio__stm32_8h.html" title="STM32 GPIO control interface.">drv/gpio_stm32.h</a>&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;<a class="code" href="irq__cm3_8h.html" title="IRQ management for the Cortex-M3 processor.">drv/irq_cm3.h</a>&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;<a class="code" href="clock__stm32_8h.html" title="Low-level clocking driver for Cortex-M3 STM32.">drv/clock_stm32.h</a>&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;<a class="code" href="ser__p_8h.html" title="Hardware dependent serial driver (interface)">drv/ser_p.h</a>&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;<a class="code" href="ser_8h.html" title="High level serial I/O API.">drv/ser.h</a>&gt;</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/* From the high-level serial driver */</span>
<a name="l00053"></a>00053 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structSerial.html" title="Serial handle structure.">Serial</a> *ser_handles[<a class="code" href="ser__at91_8h.html#a99fb83031ce9923c84392b4e92f956b5af417190a4a3042cd6e1d96883873457e" title="Number of serial ports.">SER_CNT</a>];
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="keyword">struct </span>CM3Serial
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057     <span class="keyword">struct </span>SerialHardware hw;
<a name="l00058"></a>00058     <span class="keyword">volatile</span> <span class="keywordtype">bool</span> sending;
<a name="l00059"></a>00059     uint32_t base;
<a name="l00060"></a>00060     <a class="code" href="sysirq__at91_8h.html#a4c3f180f298a68eafe5b5cc39ea6ec20" title="System IRQ ID list.">sysirq_t</a> irq;
<a name="l00061"></a>00061 };
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">/* Forward declaration */</span>
<a name="l00064"></a>00064 <span class="keyword">static</span> <span class="keyword">struct </span>CM3Serial UARTDesc[<a class="code" href="ser__at91_8h.html#a99fb83031ce9923c84392b4e92f956b5af417190a4a3042cd6e1d96883873457e" title="Number of serial ports.">SER_CNT</a>];
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">/* GPIO descriptor for UART pins */</span>
<a name="l00067"></a>00067 <span class="keyword">struct </span>gpio_uart_info
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069     <span class="comment">/* GPIO base address register */</span>
<a name="l00070"></a>00070     uint32_t base;
<a name="l00071"></a>00071     <span class="comment">/* Pin(s) bitmask */</span>
<a name="l00072"></a>00072     uint32_t rx_pin;
<a name="l00073"></a>00073     uint32_t tx_pin;
<a name="l00074"></a>00074     <span class="comment">/* Sysctl */</span>
<a name="l00075"></a>00075     uint32_t sysctl_gpio;
<a name="l00076"></a>00076     uint32_t sysctl_usart;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 };
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="comment">/* Table to retrieve GPIO pins configuration to work as UART pins */</span>
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>gpio_uart_info gpio_uart[<a class="code" href="ser__at91_8h.html#a99fb83031ce9923c84392b4e92f956b5af417190a4a3042cd6e1d96883873457e" title="Number of serial ports.">SER_CNT</a>] =
<a name="l00082"></a>00082 {
<a name="l00083"></a>00083     <span class="comment">/* UART1 */</span>
<a name="l00084"></a>00084     {
<a name="l00085"></a>00085         .base = GPIOA_BASE,
<a name="l00086"></a>00086         .rx_pin = GPIO_USART1_RX_PIN,
<a name="l00087"></a>00087         .tx_pin = GPIO_USART1_TX_PIN,
<a name="l00088"></a>00088         .sysctl_gpio = <a class="code" href="clock__stm32_8h.html#a90c442661bc0d218917911fbad0887a7" title="RCC register: APB2 peripheral.">RCC_APB2_GPIOA</a>,
<a name="l00089"></a>00089         .sysctl_usart = <a class="code" href="clock__stm32_8h.html#adbcd63c0139efd7b531ed283c35dbacf" title="RCC register: APB2 peripheral.">RCC_APB2_USART1</a>,
<a name="l00090"></a>00090     },
<a name="l00091"></a>00091     <span class="comment">/* UART2 */</span>
<a name="l00092"></a>00092     {
<a name="l00093"></a>00093         .base = GPIOA_BASE,
<a name="l00094"></a>00094         .rx_pin = GPIO_USART2_RX_PIN,
<a name="l00095"></a>00095         .tx_pin = GPIO_USART2_TX_PIN,
<a name="l00096"></a>00096         .sysctl_gpio = <a class="code" href="clock__stm32_8h.html#a90c442661bc0d218917911fbad0887a7" title="RCC register: APB2 peripheral.">RCC_APB2_GPIOA</a>,
<a name="l00097"></a>00097         .sysctl_usart = <a class="code" href="clock__stm32_8h.html#aa77ed4a407112786cba17dc4e226a196" title="RCC register: APB1 peripheral.">RCC_APB1_USART2</a>,
<a name="l00098"></a>00098     },
<a name="l00099"></a>00099 <span class="preprocessor">#if CPU_CM3_STM32F103RB || CPU_CM3_STM32F103RE</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>    <span class="comment">/* UART3 */</span>
<a name="l00101"></a>00101     {
<a name="l00102"></a>00102         .base = GPIOB_BASE,
<a name="l00103"></a>00103         .rx_pin = GPIO_USART3_RX_PIN,
<a name="l00104"></a>00104         .tx_pin = GPIO_USART3_TX_PIN,
<a name="l00105"></a>00105         .sysctl_gpio = <a class="code" href="clock__stm32_8h.html#a1989fc4860bc2b24f3b923458d1f113a" title="RCC register: APB2 peripheral.">RCC_APB2_GPIOB</a>,
<a name="l00106"></a>00106         .sysctl_usart = <a class="code" href="clock__stm32_8h.html#ab65350e32b5510ecb233ef01635105bb" title="RCC register: APB1 peripheral.">RCC_APB1_USART3</a>,
<a name="l00107"></a>00107     },
<a name="l00108"></a>00108 <span class="preprocessor">#endif</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>};
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="preprocessor">#define USART1_PORT                0</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="preprocessor">#define USART2_PORT                1</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#define USART3_PORT                2</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>
<a name="l00115"></a>00115 <span class="keywordtype">void</span> stm32_uartSetBaudRate(uint32_t base, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> baud)
<a name="l00116"></a>00116 {
<a name="l00117"></a>00117     <span class="keyword">struct </span>stm32_usart *_base = (<span class="keyword">struct </span>stm32_usart *)base;
<a name="l00118"></a>00118     _base-&gt;BRR = evaluate_brr(_base, CPU_FREQ, baud);
<a name="l00119"></a>00119 }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="keywordtype">void</span> stm32_uartSetParity(uint32_t base, <span class="keywordtype">int</span> parity)
<a name="l00122"></a>00122 {
<a name="l00123"></a>00123     <span class="keyword">struct </span>stm32_usart *_base = (<span class="keyword">struct </span>stm32_usart *)base;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     <span class="comment">/*  USART_WORD_LEN_8B */</span>
<a name="l00126"></a>00126     _base-&gt;CR1 &amp;= ~<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_M);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128     <span class="keywordflow">switch</span>(parity)
<a name="l00129"></a>00129     {
<a name="l00130"></a>00130     <span class="keywordflow">case</span> SER_PARITY_NONE:
<a name="l00131"></a>00131         _base-&gt;CR1 &amp;= ~<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_PCE);
<a name="l00132"></a>00132         <span class="keywordflow">break</span>;
<a name="l00133"></a>00133     <span class="keywordflow">case</span> SER_PARITY_ODD:
<a name="l00134"></a>00134         _base-&gt;CR1 |= (<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_PCE) | <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_PS));
<a name="l00135"></a>00135         <span class="keywordflow">break</span>;
<a name="l00136"></a>00136     <span class="keywordflow">case</span> SER_PARITY_EVEN:
<a name="l00137"></a>00137         _base-&gt;CR1 |= <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_PCE);
<a name="l00138"></a>00138         _base-&gt;CR1 &amp;= ~<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_PS);
<a name="l00139"></a>00139         <span class="keywordflow">break</span>;
<a name="l00140"></a>00140     <span class="keywordflow">default</span>:
<a name="l00141"></a>00141         <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(0);
<a name="l00142"></a>00142         <span class="keywordflow">return</span>;
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144 }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="keywordtype">void</span> stm32_uartInit(<span class="keywordtype">int</span> port)
<a name="l00147"></a>00147 {
<a name="l00148"></a>00148     <span class="keyword">struct </span>stm32_usart *base = (<span class="keyword">struct </span>stm32_usart *)UARTDesc[port].base;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(port &gt;= 0 &amp;&amp; port &lt; <a class="code" href="ser__at91_8h.html#a99fb83031ce9923c84392b4e92f956b5af417190a4a3042cd6e1d96883873457e" title="Number of serial ports.">SER_CNT</a>);
<a name="l00151"></a>00151 
<a name="l00152"></a>00152     <span class="comment">/* Enable clocking on AFIO */</span>
<a name="l00153"></a>00153     RCC-&gt;APB2ENR |= <a class="code" href="clock__stm32_8h.html#a4815dd8cca8dc02f2ea478163a0986e1" title="RCC register: APB2 peripheral.">RCC_APB2_AFIO</a>;
<a name="l00154"></a>00154     RCC-&gt;APB2ENR |= gpio_uart[port].sysctl_gpio;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     <span class="comment">/* Configure USART pins */</span>
<a name="l00157"></a>00157     <span class="keywordflow">if</span> (port == USART1_PORT)
<a name="l00158"></a>00158     {
<a name="l00159"></a>00159         RCC-&gt;APB2ENR |=  gpio_uart[port].sysctl_usart;
<a name="l00160"></a>00160     }
<a name="l00161"></a>00161     <span class="keywordflow">else</span>
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163         RCC-&gt;APB1ENR |=  gpio_uart[port].sysctl_usart;
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     <a class="code" href="gpio__stm32_8c.html#a13ea8b88a2c1dc167d788845a13469e2" title="Configure a GPIO pin.">stm32_gpioPinConfig</a>((<span class="keyword">struct</span> <a class="code" href="structstm32__gpio.html" title="GPIO configuration registers structure.">stm32_gpio</a> *)gpio_uart[port].base,  gpio_uart[port].tx_pin,
<a name="l00167"></a>00167                 GPIO_MODE_AF_PP, GPIO_SPEED_50MHZ);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <a class="code" href="gpio__stm32_8c.html#a13ea8b88a2c1dc167d788845a13469e2" title="Configure a GPIO pin.">stm32_gpioPinConfig</a>((<span class="keyword">struct</span> <a class="code" href="structstm32__gpio.html" title="GPIO configuration registers structure.">stm32_gpio</a> *)gpio_uart[port].base,  gpio_uart[port].rx_pin,
<a name="l00170"></a>00170                 GPIO_MODE_IN_FLOATING, GPIO_SPEED_50MHZ);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172     <span class="comment">/* Clear control registry */</span>
<a name="l00173"></a>00173     base-&gt;CR2 = 0;
<a name="l00174"></a>00174     base-&gt;CR1 = 0;
<a name="l00175"></a>00175     base-&gt;CR3 = 0;
<a name="l00176"></a>00176     base-&gt;SR = 0;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="comment">/* Set serial param: 115.200 bps, no parity */</span>
<a name="l00179"></a>00179     stm32_uartSetBaudRate(UARTDesc[port].base, 115200);
<a name="l00180"></a>00180     stm32_uartSetParity(UARTDesc[port].base, SER_PARITY_NONE);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     <span class="comment">/* Enable trasmision and receiver */</span>
<a name="l00184"></a>00184     base-&gt;CR1 |= (<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_TE) | <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_RE));
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">static</span> <span class="keywordtype">bool</span> tx_sending(<span class="keyword">struct</span> SerialHardware *_hw)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190     <span class="keyword">struct </span>CM3Serial *hw = (<span class="keyword">struct </span>CM3Serial *)_hw;
<a name="l00191"></a>00191     <span class="keywordflow">return</span> hw-&gt;sending;
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">static</span> <span class="keywordtype">void</span> uart_irq_rx(<span class="keywordtype">int</span> port)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196     <span class="keyword">struct </span>FIFOBuffer *rxfifo = &amp;ser_handles[port]-&gt;rxfifo;
<a name="l00197"></a>00197     <span class="keyword">struct </span>stm32_usart *base = (<span class="keyword">struct </span>stm32_usart *)UARTDesc[port].base;
<a name="l00198"></a>00198     <span class="keywordtype">char</span> c;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200     <span class="keywordflow">while</span> (stm32_uartRxReady(UARTDesc[port].base))
<a name="l00201"></a>00201     {
<a name="l00202"></a>00202         c = base-&gt;DR;
<a name="l00203"></a>00203         <span class="keywordflow">if</span> (<a class="code" href="group__fifobuf.html#ga5dc5785260c19521eb0988068cfbc2ae" title="Check whether the fifo is full.">fifo_isfull</a>(rxfifo))
<a name="l00204"></a>00204             ser_handles[port]-&gt;status |= <a class="code" href="ser__at91_8h.html#a6589b5f61d9a85328534326ca0d06b72" title="Rx FIFO buffer overrun.">SERRF_RXFIFOOVERRUN</a>;
<a name="l00205"></a>00205         <span class="keywordflow">else</span>
<a name="l00206"></a>00206             <a class="code" href="group__fifobuf.html#gaa90a12236437f4c2c3205cd1f991a322" title="Push a character on the fifo buffer.">fifo_push</a>(rxfifo, c);
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="keyword">static</span> <span class="keywordtype">void</span> uart_irq_tx(<span class="keywordtype">int</span> port)
<a name="l00211"></a>00211 {
<a name="l00212"></a>00212     <span class="keyword">struct </span>FIFOBuffer *txfifo = &amp;ser_handles[port]-&gt;txfifo;
<a name="l00213"></a>00213     <span class="keyword">struct </span>stm32_usart *base = (<span class="keyword">struct </span>stm32_usart *)UARTDesc[port].base;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     <span class="keywordflow">if</span> (<a class="code" href="group__fifobuf.html#ga0e994927c90f3db3a6df6877e948b77a" title="Check whether the fifo is empty.">fifo_isempty</a>(txfifo))
<a name="l00216"></a>00216     {
<a name="l00217"></a>00217         <span class="comment">/*</span>
<a name="l00218"></a>00218 <span class="comment">         * Disable TX empty interrupts if there&#39;re no more</span>
<a name="l00219"></a>00219 <span class="comment">         * characters to transmit.</span>
<a name="l00220"></a>00220 <span class="comment">         */</span>
<a name="l00221"></a>00221         base-&gt;CR1 &amp;= ~<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_TXEIE);
<a name="l00222"></a>00222         UARTDesc[port].sending = <span class="keyword">false</span>;
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224     <span class="keywordflow">else</span>
<a name="l00225"></a>00225     {
<a name="l00226"></a>00226         base-&gt;DR = <a class="code" href="group__fifobuf.html#ga10b23a805dd320d7767e99087fa7df84" title="Pop a character from the fifo buffer.">fifo_pop</a>(txfifo);
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228 }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keyword">static</span> <span class="keywordtype">void</span> uart_common_irq_handler(<span class="keywordtype">int</span> port)
<a name="l00231"></a>00231 {
<a name="l00232"></a>00232     <span class="keyword">struct </span>stm32_usart *base = (<span class="keyword">struct </span>stm32_usart *)UARTDesc[port].base;
<a name="l00233"></a>00233     uint32_t status;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235     <span class="comment">/* Read and clear the IRQ status */</span>
<a name="l00236"></a>00236     status = base-&gt;SR;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="comment">/* Check hw errors */</span>
<a name="l00239"></a>00239     ser_handles[port]-&gt;<a class="code" href="structSerial.html#aeb00432964b5907610c7394b800d8997" title="Holds the flags defined above.">status</a> = status &amp;
<a name="l00240"></a>00240         (<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(SR_ORE) | <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(SR_FE) | <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(SR_PE) | <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(SR_NE));
<a name="l00241"></a>00241 
<a name="l00242"></a>00242     <span class="comment">/* Process the IRQ */</span>
<a name="l00243"></a>00243     <span class="keywordflow">if</span> (status &amp; <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_RXNEIE))
<a name="l00244"></a>00244     {
<a name="l00245"></a>00245         uart_irq_rx(port);
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247     <span class="keywordflow">if</span> (status &amp; (<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_TXEIE) | <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_TCIE)))
<a name="l00248"></a>00248     {
<a name="l00249"></a>00249         uart_irq_tx(port);
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="keyword">static</span> <span class="keywordtype">void</span> stm32_uartIRQEnable(<span class="keywordtype">int</span> port, <a class="code" href="sysirq__at91_8h.html#a5d841605d626b85c8672c05cc47034d8" title="Type for system irq handler.">sysirq_handler_t</a> handler)
<a name="l00254"></a>00254 {
<a name="l00255"></a>00255     <span class="keyword">struct </span>stm32_usart *base = (<span class="keyword">struct </span>stm32_usart *)UARTDesc[port].base;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="comment">/* Register the IRQ handler */</span>
<a name="l00258"></a>00258     <a class="code" href="sysirq__at91_8c.html#ac306e48b7f835d555d57502b277961f8" title="Helper function used to set handler for system IRQ irq.">sysirq_setHandler</a>(UARTDesc[port].irq, handler);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     base-&gt;CR1 |= <a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_RXNEIE);
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="keyword">static</span> <span class="keywordtype">void</span> stm32_uartIRQDisable(<span class="keywordtype">int</span> port)
<a name="l00264"></a>00264 {
<a name="l00265"></a>00265     <span class="keyword">struct </span>stm32_usart *base = (<span class="keyword">struct </span>stm32_usart *)UARTDesc[port].base;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     base-&gt;CR1 &amp;= ~(<a class="code" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV</a>(CR1_RXNEIE) | USART_FLAG_TXE);
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="comment">/* UART class definition */</span>
<a name="l00272"></a>00272 <span class="preprocessor">#define UART_PORT(port)          \</span>
<a name="l00273"></a>00273 <span class="preprocessor">    </span><span class="comment">/* UART TX and RX buffers */</span> \
<a name="l00274"></a>00274     static unsigned char uart ## port ## _txbuffer[CONFIG_UART ## port ## _TXBUFSIZE]; \
<a name="l00275"></a>00275     static unsigned char uart ## port ## _rxbuffer[CONFIG_UART ## port ## _RXBUFSIZE];  \
<a name="l00276"></a>00276                                         \
<a name="l00277"></a>00277     <span class="comment">/* UART interrupt handler */</span>                        \
<a name="l00278"></a>00278     static DECLARE_ISR(uart ## port ## _irq_handler)    \
<a name="l00279"></a>00279     {                                   \
<a name="l00280"></a>00280         uart_common_irq_handler(USART ## port ## _PORT);    \
<a name="l00281"></a>00281     }                                   \
<a name="l00282"></a>00282                                         \
<a name="l00283"></a>00283     <span class="comment">/* UART public methods */</span> \
<a name="l00284"></a>00284     static void uart ## port ## _txStart(struct SerialHardware *_hw) \
<a name="l00285"></a>00285     {                                                                \
<a name="l00286"></a>00286         struct FIFOBuffer *txfifo = &amp;ser_handles[USART ## port ## _PORT]-&gt;txfifo;        \
<a name="l00287"></a>00287         struct CM3Serial *hw = (struct CM3Serial *)_hw;              \
<a name="l00288"></a>00288         struct stm32_usart *base = (struct stm32_usart *)USART## port ## _BASE; \
<a name="l00289"></a>00289         if (hw-&gt;sending)                        \
<a name="l00290"></a>00290             return;                         \
<a name="l00291"></a>00291         stm32_uartPutChar(USART ## port ## _BASE, fifo_pop(txfifo));    \
<a name="l00292"></a>00292         if (!fifo_isempty(txfifo))                  \
<a name="l00293"></a>00293         {                               \
<a name="l00294"></a>00294             hw-&gt;sending = true;  \
<a name="l00295"></a>00295             base-&gt;CR1 |= BV(CR1_TXEIE); \
<a name="l00296"></a>00296         } \
<a name="l00297"></a>00297     }                                   \
<a name="l00298"></a>00298                                         \
<a name="l00299"></a>00299     static void uart ## port ## _setbaudrate(UNUSED_ARG(struct SerialHardware *, hw), \
<a name="l00300"></a>00300                         unsigned long baud)     \
<a name="l00301"></a>00301     {                                   \
<a name="l00302"></a>00302         stm32_uartSetBaudRate(USART## port ## _BASE, baud);     \
<a name="l00303"></a>00303     }                                   \
<a name="l00304"></a>00304                                         \
<a name="l00305"></a>00305     static void uart ## port ## _setparity(UNUSED_ARG(struct SerialHardware *, hw), \
<a name="l00306"></a>00306                         int parity)         \
<a name="l00307"></a>00307     {                                   \
<a name="l00308"></a>00308         stm32_uartSetParity(USART## port ## _BASE, parity);     \
<a name="l00309"></a>00309     }                                   \
<a name="l00310"></a>00310                                         \
<a name="l00311"></a>00311     static void uart ## port ## _cleanup(struct SerialHardware *_hw)            \
<a name="l00312"></a>00312     {                                   \
<a name="l00313"></a>00313         struct CM3Serial *hw = (struct CM3Serial *)_hw;         \
<a name="l00314"></a>00314         hw-&gt;sending = false; \
<a name="l00315"></a>00315         stm32_uartIRQDisable(USART ## port ## _PORT);                   \
<a name="l00316"></a>00316         stm32_uartClear(USART## port ## _BASE);             \
<a name="l00317"></a>00317         stm32_uartDisable(USART## port ## _BASE);           \
<a name="l00318"></a>00318     }                                   \
<a name="l00319"></a>00319                                         \
<a name="l00320"></a>00320     static void uart ## port ## _init(UNUSED_ARG(struct SerialHardware *, hw),      \
<a name="l00321"></a>00321                 UNUSED_ARG(struct Serial *, ser))       \
<a name="l00322"></a>00322     {                                   \
<a name="l00323"></a>00323         stm32_uartInit(USART ## port ## _PORT);                     \
<a name="l00324"></a>00324         stm32_uartEnable(USART## port ## _BASE);                \
<a name="l00325"></a>00325         stm32_uartIRQEnable(USART ## port ## _PORT, uart ## port ## _irq_handler);      \
<a name="l00326"></a>00326     }                                   \
<a name="l00327"></a>00327                                         \
<a name="l00328"></a>00328     <span class="comment">/* UART operations */</span>                           \
<a name="l00329"></a>00329     static const struct SerialHardwareVT USART ## port ## _VT =     \
<a name="l00330"></a>00330     {                                   \
<a name="l00331"></a>00331         .init = uart ## port ## _init,                  \
<a name="l00332"></a>00332         .cleanup = uart ## port ## _cleanup,                \
<a name="l00333"></a>00333         .setBaudrate = uart ## port ## _setbaudrate,            \
<a name="l00334"></a>00334         .setParity = uart ## port ## _setparity,            \
<a name="l00335"></a>00335         .txStart = uart ## port ## _txStart,                \
<a name="l00336"></a>00336         .txSending = tx_sending,                    \
<a name="l00337"></a>00337     };
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="comment">/* UART port instances */</span>
<a name="l00340"></a>00340 UART_PORT(1)
<a name="l00341"></a>00341 UART_PORT(2)
<a name="l00342"></a>00342 <span class="preprocessor">#if CPU_CM3_STM32F103RB || CPU_CM3_STM32F103RE</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span>UART_PORT(3)
<a name="l00344"></a>00344 <span class="preprocessor">#endif</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span>
<a name="l00346"></a>00346 <span class="keyword">static</span> <span class="keyword">struct </span>CM3Serial UARTDesc[<a class="code" href="ser__at91_8h.html#a99fb83031ce9923c84392b4e92f956b5af417190a4a3042cd6e1d96883873457e" title="Number of serial ports.">SER_CNT</a>] =
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348     {
<a name="l00349"></a>00349         .hw = {
<a name="l00350"></a>00350             .table = &amp;USART1_VT,
<a name="l00351"></a>00351             .txbuffer = uart1_txbuffer,
<a name="l00352"></a>00352             .rxbuffer = uart1_rxbuffer,
<a name="l00353"></a>00353             .txbuffer_size = <span class="keyword">sizeof</span>(uart1_txbuffer),
<a name="l00354"></a>00354             .rxbuffer_size = <span class="keyword">sizeof</span>(uart1_rxbuffer),
<a name="l00355"></a>00355         },
<a name="l00356"></a>00356         .sending = <span class="keyword">false</span>,
<a name="l00357"></a>00357         .base = USART1_BASE,
<a name="l00358"></a>00358         .irq = <a class="code" href="stm32__ints_8h.html#a8bda21fab941211d1dae1f39322877fa" title="The following are defines for the interrupt assignments.">USART1_IRQHANDLER</a>,
<a name="l00359"></a>00359     },
<a name="l00360"></a>00360     {
<a name="l00361"></a>00361         .hw = {
<a name="l00362"></a>00362             .table = &amp;USART2_VT,
<a name="l00363"></a>00363             .txbuffer = uart2_txbuffer,
<a name="l00364"></a>00364             .rxbuffer = uart2_rxbuffer,
<a name="l00365"></a>00365             .txbuffer_size = <span class="keyword">sizeof</span>(uart2_txbuffer),
<a name="l00366"></a>00366             .rxbuffer_size = <span class="keyword">sizeof</span>(uart2_rxbuffer),
<a name="l00367"></a>00367         },
<a name="l00368"></a>00368         .sending = <span class="keyword">false</span>,
<a name="l00369"></a>00369         .base = USART2_BASE,
<a name="l00370"></a>00370         .irq = <a class="code" href="stm32__ints_8h.html#a9254d1a466dae20880f6964020a72adb" title="The following are defines for the interrupt assignments.">USART2_IRQHANDLER</a>,
<a name="l00371"></a>00371     },
<a name="l00372"></a>00372 <span class="preprocessor">#if CPU_CM3_STM32F103RB || CPU_CM3_STM32F103RE</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>    {
<a name="l00374"></a>00374         .hw = {
<a name="l00375"></a>00375             .table = &amp;USART3_VT,
<a name="l00376"></a>00376             .txbuffer = uart3_txbuffer,
<a name="l00377"></a>00377             .rxbuffer = uart3_rxbuffer,
<a name="l00378"></a>00378             .txbuffer_size = <span class="keyword">sizeof</span>(uart3_txbuffer),
<a name="l00379"></a>00379             .rxbuffer_size = <span class="keyword">sizeof</span>(uart3_rxbuffer),
<a name="l00380"></a>00380         },
<a name="l00381"></a>00381         .sending = <span class="keyword">false</span>,
<a name="l00382"></a>00382         .base = USART3_BASE,
<a name="l00383"></a>00383         .irq = <a class="code" href="stm32__ints_8h.html#a53a7411c544bbe7a12cae1b8cff529b5" title="The following are defines for the interrupt assignments.">USART3_IRQHANDLER</a>,
<a name="l00384"></a>00384     },
<a name="l00385"></a>00385 <span class="preprocessor">#endif</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>};
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 <span class="keyword">struct </span>SerialHardware *ser_hw_getdesc(<span class="keywordtype">int</span> port)
<a name="l00389"></a>00389 {
<a name="l00390"></a>00390     <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(port &gt;= 0 &amp;&amp; port &lt; <a class="code" href="ser__at91_8h.html#a99fb83031ce9923c84392b4e92f956b5af417190a4a3042cd6e1d96883873457e" title="Number of serial ports.">SER_CNT</a>);
<a name="l00391"></a>00391     <span class="keywordflow">return</span> &amp;UARTDesc[port].hw;
<a name="l00392"></a>00392 }
</pre></div></div>
</div>


