

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Simple RPC machinery</div>  </div>
<div class="ingroups"><a class="el" href="group__mware.html">Middleware facilities</a></div></div>
<div class="contents">

<p>Channel protocol parser and commands.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionparms.html">parms</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">union that contains parameters passed to and from commands  <a href="unionparms.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCmdTemplate.html">CmdTemplate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a command that can be tokenized by the parser.  <a href="structCmdTemplate.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gacced74394dff2418fee7f190d5546fb6">REGISTER_CMD</a>(NAME)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to register a command.  <a href="#gacced74394dff2418fee7f190d5546fb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#ga943d2fbf932f80b6a52f374bb712e2ae">MAKE_TEMPLATE</a>(NAME, ARGS, RES, FLAGS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility macro to create a command template.  <a href="#ga943d2fbf932f80b6a52f374bb712e2ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gade7a82f845459cea37bb02c48abff4fa">MAKE_CMD</a>(NAME, ARGS, RES, BODY, FLAGS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility macro to create command templates and callback functions.  <a href="#gade7a82f845459cea37bb02c48abff4fa"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1eee8060fb5c38f9c47559242cf5658"></a><!-- doxytag: member="parser::CmdFuncPtr" ref="gac1eee8060fb5c38f9c47559242cf5658" args=")(parms args_results[])" -->
typedef <a class="el" href="group__parser.html#gad8097859ab1bdd06be52a8421df152d4">ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gac1eee8060fb5c38f9c47559242cf5658">CmdFuncPtr</a> )(<a class="el" href="unionparms.html">parms</a> args_results[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to commands <br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gad8097859ab1bdd06be52a8421df152d4">ResultCode</a> { <a class="el" href="group__parser.html#ggad8097859ab1bdd06be52a8421df152d4aae4a23b560d56fcf0981a9636f58edeb">RC_ERROR</a> =  -1, 
<a class="el" href="group__parser.html#ggad8097859ab1bdd06be52a8421df152d4ab834a5bb2ce6d97c2831fe3d71103c14">RC_OK</a> =  0, 
<a class="el" href="group__parser.html#ggad8097859ab1bdd06be52a8421df152d4a71c73247221c21b225a9349c87ded3ed">RC_REPLY</a> =  1, 
<a class="el" href="group__parser.html#ggad8097859ab1bdd06be52a8421df152d4a94d7240246d2247a113a4f1ed0686c3b">RC_SKIP</a> =  2
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Error generated by the commands through the return code.  <a href="group__parser.html#gad8097859ab1bdd06be52a8421df152d4">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#ga412e2a44f5de56422d2c62bbae3685d0">parser_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the parser module.  <a href="#ga412e2a44f5de56422d2c62bbae3685d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gad5eec249e05ec5cadcde55382291773d">parser_register_cmd</a> (const struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *cmd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new command into the parser.  <a href="#gad5eec249e05ec5cadcde55382291773d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#ga2dbf6e316e7abed216031a805314cd14">parser_rl_match</a> (void *dummy, const char *word, int word_len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook for readline to provide completion support for the commands registered in the parser.  <a href="#ga2dbf6e316e7abed216031a805314cd14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gaea5ddc7bf6470ada78b70f24c369b16d">parser_process_line</a> (const char *line)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Command input handler.  <a href="#gaea5ddc7bf6470ada78b70f24c369b16d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gae48733c2c44a2c5bcd56cd910aacae0e">parser_execute_cmd</a> (const struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *templ, <a class="el" href="unionparms.html">parms</a> args[CONFIG_PARSER_MAX_ARGS])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a command with its arguments, and fetch its results.  <a href="#gae48733c2c44a2c5bcd56cd910aacae0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gac607092de13a1f01e3c9c34d5cfb8ad2">parser_get_cmd_template</a> (const char *line)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the template for the command contained in the text line.  <a href="#gac607092de13a1f01e3c9c34d5cfb8ad2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parser.html#gaef65813364192b283dc9dbbf7915eaaf">parser_get_cmd_arguments</a> (const char *line, const struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *templ, <a class="el" href="unionparms.html">parms</a> args[CONFIG_PARSER_MAX_ARGS])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the arguments for the command contained in the text line.  <a href="#gaef65813364192b283dc9dbbf7915eaaf"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Channel protocol parser and commands. </p>
<p>This module provides a simple text based RPC implementation. Often there is the need to give a command to the device and receive results back. Each command may have a variable number of input and output parameters, with variable type, and a return code which indicates if the command was successfully executed or not; this module provides the machinery to facilitate the above RPC scenario. You will need to write the RPC input and reply code as well as the definition of the commands.</p>
<p>Commands are defined using a <a class="el" href="structCmdTemplate.html" title="Define a command that can be tokenized by the parser.">CmdTemplate</a> struct containing:</p>
<ul>
<li>command name: the string that will be matched by the parser;</li>
<li>command arguments: a string representing type and number of input arguments;</li>
<li>command output: a string representing type and number of output arguments;</li>
<li>function callback: function implementing the command.</li>
</ul>
<p>Once you have declared the commands, you need to register them in the parser with the function <a class="el" href="group__parser.html#gad5eec249e05ec5cadcde55382291773d" title="Register a new command into the parser.">parser_register_cmd()</a>. You are strongly encouraged to use <a class="el" href="group__parser.html#gade7a82f845459cea37bb02c48abff4fa" title="Utility macro to create command templates and callback functions.">MAKE_CMD()</a> (or alternatively <a class="el" href="group__parser.html#ga943d2fbf932f80b6a52f374bb712e2ae" title="Utility macro to create a command template.">MAKE_TEMPLATE()</a>) and <a class="el" href="group__parser.html#gacced74394dff2418fee7f190d5546fb6" title="Utility function to register a command.">REGISTER_CMD()</a> to declare and register commands.</p>
<p>A command line can be parsed with the following steps:</p>
<ul>
<li>find the corresponding command template with <a class="el" href="group__parser.html#gac607092de13a1f01e3c9c34d5cfb8ad2" title="Find the template for the command contained in the text line.">parser_get_cmd_template()</a></li>
<li>extract command arguments with <a class="el" href="group__parser.html#gaef65813364192b283dc9dbbf7915eaaf" title="Extract the arguments for the command contained in the text line.">parser_get_cmd_arguments()</a></li>
<li>execute the command with <a class="el" href="group__parser.html#gae48733c2c44a2c5bcd56cd910aacae0e" title="Execute a command with its arguments, and fetch its results.">parser_execute_cmd()</a></li>
</ul>
<p>You can also provide interactive command line completion using <a class="el" href="parser_8c.html#a756e545c00b74d876d560e806423bb99" title="Hook provided by the parser for matching of command names (TAB completion) for readline.">parser_rl_match()</a>.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Declare a buzzer command</span>
 <a class="code" href="group__parser.html#gade7a82f845459cea37bb02c48abff4fa" title="Utility macro to create command templates and callback functions.">MAKE_CMD</a>(beep, <span class="stringliteral">&quot;d&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,
 ({
    <a class="code" href="buzzer_8c.html#aec6802f5fccf8d364a0b6d68ce1688e7" title="Beep for the specified ms time.">buz_beep</a>(args[1].l);
    <a class="code" href="group__parser.html#ggad8097859ab1bdd06be52a8421df152d4ab834a5bb2ce6d97c2831fe3d71103c14" title="No reply (ignore reply arguments).">RC_OK</a>;
 }), 0)

 <span class="comment">// initialize the parser</span>
 <a class="code" href="group__parser.html#ga412e2a44f5de56422d2c62bbae3685d0" title="Initialize the parser module.">parser_init</a>();
 <a class="code" href="group__parser.html#gacced74394dff2418fee7f190d5546fb6" title="Utility function to register a command.">REGISTER_CMD</a>(beep);

 <span class="comment">// parse an input line</span>
 <span class="keywordtype">char</span> buf[80];
 <span class="comment">// read line from somewhere</span>
 rpc_get(buf);
 <span class="comment">// now parse the line</span>
 const struct <a class="code" href="structCmdTemplate.html" title="Define a command that can be tokenized by the parser.">CmdTemplate</a> *templ;
 templ = <a class="code" href="group__parser.html#gac607092de13a1f01e3c9c34d5cfb8ad2" title="Find the template for the command contained in the text line.">parser_get_cmd_template</a>(buf);

 <span class="comment">// Take arguments (optionally check errors)</span>
 <a class="code" href="unionparms.html" title="union that contains parameters passed to and from commands">parms</a> args[PARSER_MAX_ARGS];
 <a class="code" href="group__parser.html#gaef65813364192b283dc9dbbf7915eaaf" title="Extract the arguments for the command contained in the text line.">parser_get_cmd_arguments</a>(buf, templ, args);
 <span class="comment">//Execute command</span>
 if(!<a class="code" href="group__parser.html#gae48733c2c44a2c5bcd56cd910aacae0e" title="Execute a command with its arguments, and fetch its results.">parser_execute_cmd</a>(templ, args))
 {
    <span class="comment">// error</span>
 }
 <span class="comment">// Now args contain the outputs of the function, you can send it</span>
 <span class="comment">// back to the caller</span>
 rpc_reply(args)
</pre></div><p><b>Configuration file</b>: <a class="el" href="cfg__parser_8h.html" title="Configuration file for parser module.">cfg_parser.h</a></p>
<dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd>
<dd>
Stefano Fedrigo &lt;<a href="mailto:aleph@develer.com">aleph@develer.com</a>&gt; </dd>
<dd>
Giovanni Bajo &lt;<a href="mailto:rasky@develer.com">rasky@develer.com</a>&gt; </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gade7a82f845459cea37bb02c48abff4fa"></a><!-- doxytag: member="parser.h::MAKE_CMD" ref="gade7a82f845459cea37bb02c48abff4fa" args="(NAME, ARGS, RES, BODY, FLAGS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAKE_CMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ARGS, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RES, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BODY, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FLAGS&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="group__parser.html#gad8097859ab1bdd06be52a8421df152d4" title="Error generated by the commands through the return code.">ResultCode</a> cmd_ ## NAME (<a class="code" href="unionparms.html" title="union that contains parameters passed to and from commands">parms</a> *args)    \
{                                               \
    <span class="keywordflow">return</span> (<a class="code" href="group__parser.html#gad8097859ab1bdd06be52a8421df152d4" title="Error generated by the commands through the return code.">ResultCode</a>)BODY;                \
}                                               \
<a class="code" href="group__parser.html#ga943d2fbf932f80b6a52f374bb712e2ae" title="Utility macro to create a command template.">MAKE_TEMPLATE</a>(NAME, ARGS, RES, FLAGS)
</pre></div>
<p>Utility macro to create command templates and callback functions. </p>
<p>Example for a version command: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__parser.html#gade7a82f845459cea37bb02c48abff4fa" title="Utility macro to create command templates and callback functions.">MAKE_CMD</a>(ver, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;ddd&quot;</span>,
 ({
    args[1].l = VERS_MAJOR;
    args[2].l = VERS_MINOR;
    args[3].l = VERS_REV;
    <a class="code" href="group__parser.html#ggad8097859ab1bdd06be52a8421df152d4ab834a5bb2ce6d97c2831fe3d71103c14" title="No reply (ignore reply arguments).">RC_OK</a>;
 }), 0);
</pre></div><p>Remember that input and output parameters start from index 1, since args[0] is the command itself. The last line is the return value of the function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">NAME</td><td>Command name matched by the parser </td></tr>
    <tr><td class="paramname">ARGS</td><td>Input arguments to the command </td></tr>
    <tr><td class="paramname">RES</td><td>Output arguments of the command </td></tr>
    <tr><td class="paramname">BODY</td><td>Command body, expressed with C 'statement expression' </td></tr>
    <tr><td class="paramname">FLAGS</td><td>Command flags </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00213">213</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga943d2fbf932f80b6a52f374bb712e2ae"></a><!-- doxytag: member="parser.h::MAKE_TEMPLATE" ref="ga943d2fbf932f80b6a52f374bb712e2ae" args="(NAME, ARGS, RES, FLAGS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAKE_TEMPLATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ARGS, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RES, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FLAGS&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structCmdTemplate.html" title="Define a command that can be tokenized by the parser.">CmdTemplate</a> cmd_ ## NAME ## _template =   \
{                                                      \
<span class="preprocessor">    #NAME, ARGS, RES, cmd_ ## NAME, FLAGS          \</span>
<span class="preprocessor">};</span>
</pre></div>
<p>Utility macro to create a command template. </p>
<p>It requires that a callback function with name <em>cmd_NAME</em> is already defined. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">NAME</td><td>Command name </td></tr>
    <tr><td class="paramname">ARGS</td><td>Input arguments </td></tr>
    <tr><td class="paramname">RES</td><td>Output arguments </td></tr>
    <tr><td class="paramname">FLAGS</td><td>Command flags </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00183">183</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacced74394dff2418fee7f190d5546fb6"></a><!-- doxytag: member="parser.h::REGISTER_CMD" ref="gacced74394dff2418fee7f190d5546fb6" args="(NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGISTER_CMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        <span class="keywordflow">if</span> (!REGISTER_FUNCTION(&amp;cmd_ ## NAME ## _template)) \
            <a class="code" href="group__debug.html#ga954b4ed06e69edc987d7aeefc30e717e" title="Assert a pre-condition and give explanation message when assert fails.">ASSERT2</a>(0, <span class="stringliteral">&quot;Error in registering command, no space left&quot;</span>); \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Utility function to register a command. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">NAME</td><td>Command name to register </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00167">167</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gad8097859ab1bdd06be52a8421df152d4"></a><!-- doxytag: member="parser.h::ResultCode" ref="gad8097859ab1bdd06be52a8421df152d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__parser.html#gad8097859ab1bdd06be52a8421df152d4">ResultCode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error generated by the commands through the return code. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggad8097859ab1bdd06be52a8421df152d4aae4a23b560d56fcf0981a9636f58edeb"></a><!-- doxytag: member="RC_ERROR" ref="ggad8097859ab1bdd06be52a8421df152d4aae4a23b560d56fcf0981a9636f58edeb" args="" -->RC_ERROR</em>&nbsp;</td><td>
<p>Reply with error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad8097859ab1bdd06be52a8421df152d4ab834a5bb2ce6d97c2831fe3d71103c14"></a><!-- doxytag: member="RC_OK" ref="ggad8097859ab1bdd06be52a8421df152d4ab834a5bb2ce6d97c2831fe3d71103c14" args="" -->RC_OK</em>&nbsp;</td><td>
<p>No reply (ignore reply arguments). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad8097859ab1bdd06be52a8421df152d4a71c73247221c21b225a9349c87ded3ed"></a><!-- doxytag: member="RC_REPLY" ref="ggad8097859ab1bdd06be52a8421df152d4a71c73247221c21b225a9349c87ded3ed" args="" -->RC_REPLY</em>&nbsp;</td><td>
<p>Reply command arguments. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad8097859ab1bdd06be52a8421df152d4a94d7240246d2247a113a4f1ed0686c3b"></a><!-- doxytag: member="RC_SKIP" ref="ggad8097859ab1bdd06be52a8421df152d4a94d7240246d2247a113a4f1ed0686c3b" args="" -->RC_SKIP</em>&nbsp;</td><td>
<p>Skip following commands. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00126">126</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae48733c2c44a2c5bcd56cd910aacae0e"></a><!-- doxytag: member="parser.h::parser_execute_cmd" ref="gae48733c2c44a2c5bcd56cd910aacae0e" args="(const struct CmdTemplate *templ, parms args[CONFIG_PARSER_MAX_ARGS])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_execute_cmd </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionparms.html">parms</a>&#160;</td>
          <td class="paramname"><em>args</em>[CONFIG_PARSER_MAX_ARGS]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute a command with its arguments, and fetch its results. </p>
<p>The <em>args</em> paramenter is value-result: it provides input arguments to the callback function and it stores output values on return.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">templ</td><td>Template of the command to be executed </td></tr>
    <tr><td class="paramname">args</td><td>Arguments for the command, and will contain the results</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if the command returned an error, true otherwise </dd></dl>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00252">252</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaef65813364192b283dc9dbbf7915eaaf"></a><!-- doxytag: member="parser.h::parser_get_cmd_arguments" ref="gaef65813364192b283dc9dbbf7915eaaf" args="(const char *line, const struct CmdTemplate *templ, parms args[CONFIG_PARSER_MAX_ARGS])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_get_cmd_arguments </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *&#160;</td>
          <td class="paramname"><em>cmdp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionparms.html">parms</a>&#160;</td>
          <td class="paramname"><em>args</em>[CONFIG_PARSER_MAX_ARGS]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the arguments for the command contained in the text line. </p>
<p>The first argument will always be the command name, so the actual arguments will start at index 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Text line to be processed (ASCIIZ) </td></tr>
    <tr><td class="paramname">cmdp</td><td>Command template for this line </td></tr>
    <tr><td class="paramname">args</td><td>Will contain the extracted parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if everything OK, false in case of parsing error. </dd></dl>

<p>Definition at line <a class="el" href="parser_8c_source.html#l00261">261</a> of file <a class="el" href="parser_8c_source.html">parser.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac607092de13a1f01e3c9c34d5cfb8ad2"></a><!-- doxytag: member="parser.h::parser_get_cmd_template" ref="gac607092de13a1f01e3c9c34d5cfb8ad2" args="(const char *line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a>* parser_get_cmd_template </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the template for the command contained in the text line. </p>
<p>The template can be used to tokenize the command and interpret it.</p>
<p>This function can be used to find out which command is contained in a given text line without parsing all the parameters and executing it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Text line to be processed (ASCIIZ)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The command template associated with the command contained in the line, or NULL if the command is invalid. </dd></dl>

<p>Definition at line <a class="el" href="parser_8c_source.html#l00216">216</a> of file <a class="el" href="parser_8c_source.html">parser.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga412e2a44f5de56422d2c62bbae3685d0"></a><!-- doxytag: member="parser.h::parser_init" ref="ga412e2a44f5de56422d2c62bbae3685d0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the parser module. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function must be called before any other function in this module </dd></dl>

<p>Definition at line <a class="el" href="parser_8c_source.html#l00319">319</a> of file <a class="el" href="parser_8c_source.html">parser.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaea5ddc7bf6470ada78b70f24c369b16d"></a><!-- doxytag: member="parser.h::parser_process_line" ref="gaea5ddc7bf6470ada78b70f24c369b16d" args="(const char *line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_process_line </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Command input handler. </p>
<p>Process the input, calling the requested command (if found).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Text line to be processed (ASCIIZ)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if everything is OK, false in case of errors </dd></dl>

<p>Definition at line <a class="el" href="parser_8c_source.html#l00290">290</a> of file <a class="el" href="parser_8c_source.html">parser.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad5eec249e05ec5cadcde55382291773d"></a><!-- doxytag: member="parser.h::parser_register_cmd" ref="gad5eec249e05ec5cadcde55382291773d" args="(const struct CmdTemplate *cmd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_register_cmd </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structCmdTemplate.html">CmdTemplate</a> *&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a new command into the parser. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Command template describing the command </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if registration was successful, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="parser_8c_source.html#l00314">314</a> of file <a class="el" href="parser_8c_source.html">parser.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2dbf6e316e7abed216031a805314cd14"></a><!-- doxytag: member="parser.h::parser_rl_match" ref="ga2dbf6e316e7abed216031a805314cd14" args="(void *dummy, const char *word, int word_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* parser_rl_match </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dummy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>word_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hook for readline to provide completion support for the commands registered in the parser. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is meant to be used with <a class="el" href="readline_8c.html" title="Line editing support with history.">mware/readline.c</a>. See the documentation there for a description of this hook. </dd></dl>

</div>
</div>
</div>


