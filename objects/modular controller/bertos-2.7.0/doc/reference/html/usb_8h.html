

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_f7c89dbd63e8f34e572fe939945c15d7.html">drv</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">usb.h File Reference</div>  </div>
</div>
<div class="contents">

<p>USB 2.0 standard descriptors.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="cpu_2byteorder_8h_source.html">cpu/byteorder.h</a>&gt;</code><br/>
</div>
<p><a href="usb_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUsbCtrlRequest.html">UsbCtrlRequest</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Control Request descriptor.  <a href="structUsbCtrlRequest.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUsbDescHeader.html">UsbDescHeader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">USB common descriptor header.  <a href="structUsbDescHeader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUsbDeviceDesc.html">UsbDeviceDesc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Device descriptor.  <a href="structUsbDeviceDesc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUsbStringDesc.html">UsbStringDesc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">USB string descriptor.  <a href="structUsbStringDesc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUsbConfigDesc.html">UsbConfigDesc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Device configuration descriptor.  <a href="structUsbConfigDesc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUsbInterfaceDesc.html">UsbInterfaceDesc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Device interface descriptor.  <a href="structUsbInterfaceDesc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint descriptor.  <a href="structUsbEndpointDesc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUsbDevice.html">UsbDevice</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">USB: generic device descriptor.  <a href="structUsbDevice.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#af60b491788c0564a61ddecd1902bf73a">USB_STRING</a>(...)&#160;&#160;&#160;PP_CAT(USB_STRING_, PP_COUNT(__VA_ARGS__))(__VA_ARGS__)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a list with a variable number of elements into a UTF-16LE USB string.  <a href="#af60b491788c0564a61ddecd1902bf73a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#adf50eba000e5cc5a7aa26d2f4c08c3b8">DEFINE_USB_STRING</a>(__name, __text)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define and initialize an USB string descriptor.  <a href="#adf50eba000e5cc5a7aa26d2f4c08c3b8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed779379eb63f73eb72f36c1cf44ca31"></a><!-- doxytag: member="usb.h::usb_endpointNum" ref="aed779379eb63f73eb72f36c1cf44ca31" args="(const UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#aed779379eb63f73eb72f36c1cf44ca31">usb_endpointNum</a> (const <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the endpoint's address number of <em>epd</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab014969a6920a6c4b255116d7efe141e"></a><!-- doxytag: member="usb.h::usb_endpointType" ref="ab014969a6920a6c4b255116d7efe141e" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#ab014969a6920a6c4b255116d7efe141e">usb_endpointType</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transfer type of the endpoint <em>epd</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6ceee72f10281b4e083c6dcacb6088d"></a><!-- doxytag: member="usb.h::usb_endpointDirIn" ref="ad6ceee72f10281b4e083c6dcacb6088d" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#ad6ceee72f10281b4e083c6dcacb6088d">usb_endpointDirIn</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> has IN direction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb3f3ea7f735fa738b8c8397517a67b4"></a><!-- doxytag: member="usb.h::usb_endpointDirOut" ref="aeb3f3ea7f735fa738b8c8397517a67b4" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#aeb3f3ea7f735fa738b8c8397517a67b4">usb_endpointDirOut</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> has OUT direction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3c031343eaea1ed3d688e5f14bac267"></a><!-- doxytag: member="usb.h::usb_endpointXferBulk" ref="ae3c031343eaea1ed3d688e5f14bac267" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#ae3c031343eaea1ed3d688e5f14bac267">usb_endpointXferBulk</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> has bulk transfer type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad05aabbfd76eac5a4929ccb93d94048c"></a><!-- doxytag: member="usb.h::usb_endpointXferControl" ref="ad05aabbfd76eac5a4929ccb93d94048c" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#ad05aabbfd76eac5a4929ccb93d94048c">usb_endpointXferControl</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> has control transfer type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadf8d4be811b02911e7a59de00bcb682"></a><!-- doxytag: member="usb.h::usb_endpointXferInt" ref="aadf8d4be811b02911e7a59de00bcb682" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#aadf8d4be811b02911e7a59de00bcb682">usb_endpointXferInt</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> has interrupt transfer type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdbe2e8666f436686807eca665a46150"></a><!-- doxytag: member="usb.h::usb_endpointXferIsoc" ref="abdbe2e8666f436686807eca665a46150" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#abdbe2e8666f436686807eca665a46150">usb_endpointXferIsoc</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> has isochronous transfer type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed05aac87a08d17d331c7c6334034b2a"></a><!-- doxytag: member="usb.h::usb_endpointIsBulkIn" ref="aed05aac87a08d17d331c7c6334034b2a" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#aed05aac87a08d17d331c7c6334034b2a">usb_endpointIsBulkIn</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> is bulk IN. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a417a87811849a8ab64339d14b10fe1dd"></a><!-- doxytag: member="usb.h::usb_endpointIsBulkOut" ref="a417a87811849a8ab64339d14b10fe1dd" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#a417a87811849a8ab64339d14b10fe1dd">usb_endpointIsBulkOut</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> is bulk OUT. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81b11e2cabb25875e3571d43e5a8bc7d"></a><!-- doxytag: member="usb.h::usb_endpointIsIntIn" ref="a81b11e2cabb25875e3571d43e5a8bc7d" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#a81b11e2cabb25875e3571d43e5a8bc7d">usb_endpointIsIntIn</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> is interrupt IN. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a433c4b07b97087f6dcd8f2b80d642b74"></a><!-- doxytag: member="usb.h::usb_endpointIsIntOut" ref="a433c4b07b97087f6dcd8f2b80d642b74" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#a433c4b07b97087f6dcd8f2b80d642b74">usb_endpointIsIntOut</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> is interrupt OUT. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c8c58c6df6d001c807026eef765a73a"></a><!-- doxytag: member="usb.h::usb_endpointIsIsocIn" ref="a4c8c58c6df6d001c807026eef765a73a" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#a4c8c58c6df6d001c807026eef765a73a">usb_endpointIsIsocIn</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> is isochronous IN. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab28876fe4d3a6a308248bb42475a59d2"></a><!-- doxytag: member="usb.h::usb_endpointIsIsocOut" ref="ab28876fe4d3a6a308248bb42475a59d2" args="(const struct UsbEndpointDesc *epd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#ab28876fe4d3a6a308248bb42475a59d2">usb_endpointIsIsocOut</a> (const struct <a class="el" href="structUsbEndpointDesc.html">UsbEndpointDesc</a> *epd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint <em>epd</em> is isochronous OUT. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#af07fa6932a42eee5fc6dc7272bc26277">usb_endpointReadTimeout</a> (int ep, void *buffer, ssize_t size, <a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read up to <em>size</em> bytes from the USB endpoint identified by the address <em>ep</em> and store them in <em>buffer</em>.  <a href="#af07fa6932a42eee5fc6dc7272bc26277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#a572e77599251fbf290354132a7701932">usb_endpointWriteTimeout</a> (int ep, const void *buffer, ssize_t size, <a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a> timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write up to <em>size</em> bytes from the buffer pointed <em>buffer</em> to the USB endpoint identified by the address <em>ep</em>.  <a href="#a572e77599251fbf290354132a7701932"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7b7732504616b306c090acc59397a38"></a><!-- doxytag: member="usb.h::usb_deviceRegister" ref="af7b7732504616b306c090acc59397a38" args="(UsbDevice *dev)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_8h.html#af7b7732504616b306c090acc59397a38">usb_deviceRegister</a> (<a class="el" href="structUsbDevice.html">UsbDevice</a> *dev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a generic USB device driver <em>dev</em> in the USB controller. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>USB 2.0 standard descriptors. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Andrea Righi &lt;<a href="mailto:arighi@develer.com">arighi@develer.com</a>&gt;</dd></dl>
<p>This file holds USB constants and structures that are needed for USB device APIs, as defined in the USB 2.0 specification.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The API is work in progress and may change in future versions. </dd></dl>

<p>Definition in file <a class="el" href="usb_8h_source.html">usb.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="adf50eba000e5cc5a7aa26d2f4c08c3b8"></a><!-- doxytag: member="usb.h::DEFINE_USB_STRING" ref="adf50eba000e5cc5a7aa26d2f4c08c3b8" args="(__name, __text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_USB_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__text&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">struct </span>{                            \
        <a class="code" href="structUsbDescHeader.html" title="USB common descriptor header.">UsbDescHeader</a> __header;                 \
        uint8_t __body[<span class="keyword">sizeof</span>(__text)];             \
    } PACKED __name = {                     \
        .__header = {                       \
            .bLength =                  \
                cpu_to_le16((uint16_t)<span class="keyword">sizeof</span>(__name)),  \
            .bDescriptorType = USB_DT_STRING,       \
        },                          \
        .__body = {__text},                 \
    }
</pre></div>
<p>Define and initialize an USB string descriptor. </p>
<p>This macro is reuquired to properly declare and initialize a constant USB string in UTF-16LE format.</p>
<p>The structure must contain the standard common USB header (<a class="el" href="structUsbDescHeader.html" title="USB common descriptor header.">UsbDescHeader</a>) and the UTF-16LE string all packed in a contiguous memory region. </p>

<p>Definition at line <a class="el" href="usb_8h_source.html#l00234">234</a> of file <a class="el" href="usb_8h_source.html">usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="af60b491788c0564a61ddecd1902bf73a"></a><!-- doxytag: member="usb.h::USB_STRING" ref="af60b491788c0564a61ddecd1902bf73a" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;PP_CAT(USB_STRING_, PP_COUNT(__VA_ARGS__))(__VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack a list with a variable number of elements into a UTF-16LE USB string. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The macro is recursively defined according the number of elements passed as argument. At the moment we support strings with up to 16 characters. </dd></dl>

<p>Definition at line <a class="el" href="usb_8h_source.html#l00223">223</a> of file <a class="el" href="usb_8h_source.html">usb.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af07fa6932a42eee5fc6dc7272bc26277"></a><!-- doxytag: member="usb.h::usb_endpointReadTimeout" ref="af07fa6932a42eee5fc6dc7272bc26277" args="(int ep, void *buffer, ssize_t size, ticks_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t usb_endpointReadTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read up to <em>size</em> bytes from the USB endpoint identified by the address <em>ep</em> and store them in <em>buffer</em>. </p>
<p>The <em>timeout</em> is an upper bound on the amount of time (in ticks) elapsed before returns. If <em>timeout</em> is zero, the the function returns immediatly and it basically works in non-blocking fashion. A negative value for <em>timeout</em> means that the function can block indefinitely.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes actually read, or a negative value in case of errors. </dd></dl>

<p>Definition at line <a class="el" href="usb__stm32_8c_source.html#l01120">1120</a> of file <a class="el" href="usb__stm32_8c_source.html">usb_stm32.c</a>.</p>

</div>
</div>
<a class="anchor" id="a572e77599251fbf290354132a7701932"></a><!-- doxytag: member="usb.h::usb_endpointWriteTimeout" ref="a572e77599251fbf290354132a7701932" args="(int ep, const void *buffer, ssize_t size, ticks_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t usb_endpointWriteTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="compiler_8h.html#a9f2d272efa5f391ffc4b9ec4eb59fa88">ticks_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write up to <em>size</em> bytes from the buffer pointed <em>buffer</em> to the USB endpoint identified by the address <em>ep</em>. </p>
<p>The <em>timeout</em> is an upper bound on the amount of time (in ticks) elapsed before returns. If <em>timeout</em> is zero, the the function returns immediatly and it basically works in non-blocking fashion. A negative value for <em>timeout</em> means that the function can block indefinitely.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes actually wrote, or a negative value in case of errors. </dd></dl>

<p>Definition at line <a class="el" href="usb__stm32_8c_source.html#l01179">1179</a> of file <a class="el" href="usb__stm32_8c_source.html">usb_stm32.c</a>.</p>

</div>
</div>
</div>


