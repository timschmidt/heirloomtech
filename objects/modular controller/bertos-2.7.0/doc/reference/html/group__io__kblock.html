

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">KBlock interface</div>  </div>
<div class="ingroups"><a class="el" href="group__core.html">BeRTOS core functionality</a></div></div>
<div class="contents">

<p><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKBlock.html">KBlock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a>: interface for a generic block device.  <a href="structKBlock.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga526f985ee7bf6d4190fb2a2eb7b2fa39"></a><!-- doxytag: member="io_kblock::KB_BUFFERED" ref="ga526f985ee7bf6d4190fb2a2eb7b2fa39" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga526f985ee7bf6d4190fb2a2eb7b2fa39">KB_BUFFERED</a>&#160;&#160;&#160;BV(0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal flag: true if the <a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> has a buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf0e0e908d1328f3ddf16de8c5a9ec48"></a><!-- doxytag: member="io_kblock::KB_CACHE_DIRTY" ref="gacf0e0e908d1328f3ddf16de8c5a9ec48" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#gacf0e0e908d1328f3ddf16de8c5a9ec48">KB_CACHE_DIRTY</a>&#160;&#160;&#160;BV(1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal flag: true if the cache is dirty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8aa2063df75dcbf08edfd284ffded73"></a><!-- doxytag: member="io_kblock::KB_PARTIAL_WRITE" ref="gaa8aa2063df75dcbf08edfd284ffded73" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#gaa8aa2063df75dcbf08edfd284ffded73">KB_PARTIAL_WRITE</a>&#160;&#160;&#160;BV(2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal flag: true if the device allows partial block write. <br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for addressing blocks in the device.  <a href="#ga662608dd815d6c4b83ce42c3d153a88b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga0a44548c390609987086cac6a2387b99">kblock_trim</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> start, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a subset of the blocks on the device.  <a href="#ga0a44548c390609987086cac6a2387b99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#gafd524f60f13c7195dec14dd0194444f0">kblock_error</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current errors for the device.  <a href="#gafd524f60f13c7195dec14dd0194444f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga358abdb8b724d8cc470247c1c4cc9fa4">kblock_clearerr</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the errors of the device.  <a href="#ga358abdb8b724d8cc470247c1c4cc9fa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga3c09ba3c8d69e8160284243c104ea6ae">kblock_flush</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the cache (if any) to the device.  <a href="#ga3c09ba3c8d69e8160284243c104ea6ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga011015cdc89b0d465113e1644ec96967">kblock_close</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the device.  <a href="#ga011015cdc89b0d465113e1644ec96967"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#gaa3d27079ce4119ed5549cde2deb98fe8">kblock_buffered</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga433e2e003e4fb47989dd60dea4baa062">kblock_cachedBlock</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga98d097adfab2a37e9d25286a9c55f564">kblock_cacheDirty</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the internal cache.  <a href="#ga98d097adfab2a37e9d25286a9c55f564"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga71ae645b5d672d3903b6646bd0955993">kblock_partialWrite</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga1f50056687e375253e3d11b11bc060a5">kblock_read</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> idx, void *buf, size_t offset, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the block device.  <a href="#ga1f50056687e375253e3d11b11bc060a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#ga069340cc7fe0a6aec2bada078ad9c889">kblock_write</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> idx, const void *buf, size_t offset, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the block device.  <a href="#ga069340cc7fe0a6aec2bada078ad9c889"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__kblock.html#gaa2d454f0b9a082ded20f385c3cfc99a5">kblock_copy</a> (struct <a class="el" href="structKBlock.html">KBlock</a> *b, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> src, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> dest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one block to another.  <a href="#gaa2d454f0b9a082ded20f385c3cfc99a5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Prototypes for KBlock low level access functions.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp38cb90a5648f01020e890cdd458e4bca"></a>When writing a driver implementing the <a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> interface you can choose which function subset to implement, but you have to set to NULL unimplemented features. </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab36240e6b194313e6a1d465ba062b88f"></a><!-- doxytag: member="io_kblock::kblock_read_direct_t" ref="gab36240e6b194313e6a1d465ba062b88f" args=")(struct KBlock *b, block_idx_t index, void *buf, size_t offset, size_t size)" -->
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_read_direct_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> index, void *buf, size_t offset, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c383aaf9c1f8d4d51976e51e12c2740"></a><!-- doxytag: member="io_kblock::kblock_write_direct_t" ref="ga0c383aaf9c1f8d4d51976e51e12c2740" args=")(struct KBlock *b, block_idx_t index, const void *buf, size_t offset, size_t size)" -->
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_write_direct_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> index, const void *buf, size_t offset, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9e48b2bba9c56769977dd448e3f45c9d"></a><!-- doxytag: member="io_kblock::kblock_read_t" ref="ga9e48b2bba9c56769977dd448e3f45c9d" args=")(struct KBlock *b, void *buf, size_t offset, size_t size)" -->
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_read_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b, void *buf, size_t offset, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a3be624c18f3d80ed6f88c47df4dbdc"></a><!-- doxytag: member="io_kblock::kblock_write_t" ref="ga9a3be624c18f3d80ed6f88c47df4dbdc" args=")(struct KBlock *b, const void *buf, size_t offset, size_t size)" -->
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_write_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b, const void *buf, size_t offset, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8d15cfb150932db981cd7bb781294a0f"></a><!-- doxytag: member="io_kblock::kblock_load_t" ref="ga8d15cfb150932db981cd7bb781294a0f" args=")(struct KBlock *b, block_idx_t index)" -->
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_load_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad1fed4f6e6aeee89e6f66988321b94bd"></a><!-- doxytag: member="io_kblock::kblock_store_t" ref="gad1fed4f6e6aeee89e6f66988321b94bd" args=")(struct KBlock *b, block_idx_t index)" -->
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_store_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b, <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07236c4294ad75c25edbe99dfb29ceb1"></a><!-- doxytag: member="io_kblock::kblock_error_t" ref="ga07236c4294ad75c25edbe99dfb29ceb1" args=")(struct KBlock *b)" -->
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_error_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c67da4d131456ffe19ea8f620ae7359"></a><!-- doxytag: member="io_kblock::kblock_clearerr_t" ref="ga8c67da4d131456ffe19ea8f620ae7359" args=")(struct KBlock *b)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_clearerr_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1a9448cce7baae9f863fdd5947e087c"></a><!-- doxytag: member="io_kblock::kblock_close_t" ref="gaf1a9448cce7baae9f863fdd5947e087c" args=")(struct KBlock *b)" -->
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>kblock_close_t</b> )(struct <a class="el" href="structKBlock.html">KBlock</a> *b)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> interface. </p>
<p>A block device is a device which can only be read/written with data blocks of constant size: flash memories, SD cards, hard disks, etc... This interface is designed to adapt to most block devices and use peculiar features in order to save CPU time and memory space.</p>
<p>There is no init function because you do not have to use this structure directly, specific implementations will supply their own init functions.</p>
<p>Error handling is done in a way similar to standard C library: whenever a function (eg. <a class="el" href="group__io__kblock.html#ga3c09ba3c8d69e8160284243c104ea6ae" title="Flush the cache (if any) to the device.">kblock_flush()</a>) returns error, you need to check the error code, which is implementation specific.</p>
<p>Example of code flow: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// init a KBlock-derived class</span>
 <a class="code" href="structFlash.html" title="EmbFlash KBlock context structure.">Flash</a> fls;
 <a class="code" href="group__drv__emb__flash.html#ga4ac5b95e3a0356f065fe0bb5eb9e3d33" title="Init function for flash driver.">flash_init</a>(&amp;fls.<a class="code" href="structFlash.html#adbd85a74983c749e2ddf796538ac6baa" title="KBlock context.">blk</a>, 0);

 <span class="comment">// use kblock_* functions to access the derived class</span>
 <a class="code" href="group__io__kblock.html#ga069340cc7fe0a6aec2bada078ad9c889" title="Write data to the block device.">kblock_write</a>(&amp;fls.<a class="code" href="structFlash.html#adbd85a74983c749e2ddf796538ac6baa" title="KBlock context.">blk</a>, ...);
 <span class="keywordflow">if</span> (<a class="code" href="group__io__kblock.html#ga3c09ba3c8d69e8160284243c104ea6ae" title="Flush the cache (if any) to the device.">kblock_flush</a>(&amp;fls.<a class="code" href="structFlash.html#adbd85a74983c749e2ddf796538ac6baa" title="KBlock context.">blk</a>) == EOF)
 {
     <span class="comment">// oops, error occurred!</span>
     <span class="keywordtype">int</span> err = <a class="code" href="group__io__kblock.html#gafd524f60f13c7195dec14dd0194444f0" title="Get the current errors for the device.">kblock_error</a>(&amp;fls.<a class="code" href="structFlash.html#adbd85a74983c749e2ddf796538ac6baa" title="KBlock context.">blk</a>);
     <span class="comment">// handle Flash specific error conditions</span>
     <span class="comment">// ...</span>
     <span class="comment">// clear error condition</span>
     <a class="code" href="group__io__kblock.html#ga358abdb8b724d8cc470247c1c4cc9fa4" title="Clear the errors of the device.">kblock_clearerr</a>(&amp;fls.<a class="code" href="structFlash.html#adbd85a74983c749e2ddf796538ac6baa" title="KBlock context.">blk</a>);
 }
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The <a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> interface is optimized for block reads. If you need a file-like access, you can use <a class="el" href="group__kfile__block.html">KFile interface over KBlock</a>.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Francesco Sacchi &lt;<a href="mailto:batt@develer.com">batt@develer.com</a>&gt; </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga662608dd815d6c4b83ce42c3d153a88b"></a><!-- doxytag: member="kblock.h::block_idx_t" ref="ga662608dd815d6c4b83ce42c3d153a88b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type for addressing blocks in the device. </p>

<p>Definition at line <a class="el" href="kblock_8h_source.html#l00088">88</a> of file <a class="el" href="kblock_8h_source.html">kblock.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa3d27079ce4119ed5549cde2deb98fe8"></a><!-- doxytag: member="kblock.h::kblock_buffered" ref="gaa3d27079ce4119ed5549cde2deb98fe8" args="(struct KBlock *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kblock_buffered </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the device <em>b</em> is buffered, false otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#ga433e2e003e4fb47989dd60dea4baa062">kblock_cachedBlock()</a>, <a class="el" href="group__io__kblock.html#ga98d097adfab2a37e9d25286a9c55f564" title="Return the status of the internal cache.">kblock_cacheDirty()</a>. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8h_source.html#l00274">274</a> of file <a class="el" href="kblock_8h_source.html">kblock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga433e2e003e4fb47989dd60dea4baa062"></a><!-- doxytag: member="kblock.h::kblock_cachedBlock" ref="ga433e2e003e4fb47989dd60dea4baa062" args="(struct KBlock *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a> kblock_cachedBlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The current cached block number if the device is buffered. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will throw an ASSERT if called on a non buffered <a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#gaa3d27079ce4119ed5549cde2deb98fe8">kblock_buffered()</a>, <a class="el" href="group__io__kblock.html#ga98d097adfab2a37e9d25286a9c55f564" title="Return the status of the internal cache.">kblock_cacheDirty()</a>. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8h_source.html#l00287">287</a> of file <a class="el" href="kblock_8h_source.html">kblock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga98d097adfab2a37e9d25286a9c55f564"></a><!-- doxytag: member="kblock.h::kblock_cacheDirty" ref="ga98d097adfab2a37e9d25286a9c55f564" args="(struct KBlock *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kblock_cacheDirty </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the internal cache. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the device supports buffering, returns true if the cache is dirty, false if the cache is clean and coherent with device content. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will throw an ASSERT if called on a non buffered <a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#ga433e2e003e4fb47989dd60dea4baa062">kblock_cachedBlock()</a>, <a class="el" href="group__io__kblock.html#gaa3d27079ce4119ed5549cde2deb98fe8">kblock_buffered()</a>. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8h_source.html#l00303">303</a> of file <a class="el" href="kblock_8h_source.html">kblock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga358abdb8b724d8cc470247c1c4cc9fa4"></a><!-- doxytag: member="kblock.h::kblock_clearerr" ref="ga358abdb8b724d8cc470247c1c4cc9fa4" args="(struct KBlock *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kblock_clearerr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the errors of the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#gafd524f60f13c7195dec14dd0194444f0" title="Get the current errors for the device.">kblock_error()</a> </dd></dl>

<p>Definition at line <a class="el" href="kblock_8h_source.html#l00238">238</a> of file <a class="el" href="kblock_8h_source.html">kblock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga011015cdc89b0d465113e1644ec96967"></a><!-- doxytag: member="kblock.h::kblock_close" ref="ga011015cdc89b0d465113e1644ec96967" args="(struct KBlock *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kblock_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, EOF on errors. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8h_source.html#l00263">263</a> of file <a class="el" href="kblock_8h_source.html">kblock.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa2d454f0b9a082ded20f385c3cfc99a5"></a><!-- doxytag: member="kblock.h::kblock_copy" ref="gaa2d454f0b9a082ded20f385c3cfc99a5" args="(struct KBlock *b, block_idx_t src, block_idx_t dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kblock_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy one block to another. </p>
<p>This function will copy the content of block <em>src</em> to block <em>dest</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is available only on devices which support partial block write or are opened in buffered mode.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device. </td></tr>
    <tr><td class="paramname">src</td><td>source block number. </td></tr>
    <tr><td class="paramname">dest</td><td>destination block number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if all is OK, EOF on errors. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8c_source.html#l00196">196</a> of file <a class="el" href="kblock_8c_source.html">kblock.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafd524f60f13c7195dec14dd0194444f0"></a><!-- doxytag: member="kblock.h::kblock_error" ref="gafd524f60f13c7195dec14dd0194444f0" args="(struct KBlock *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kblock_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current errors for the device. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Calling this function will not clear the errors.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error is present, a driver specific mask of errors otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#ga358abdb8b724d8cc470247c1c4cc9fa4" title="Clear the errors of the device.">kblock_clearerr()</a> </dd></dl>

<p>Definition at line <a class="el" href="kblock_8h_source.html#l00224">224</a> of file <a class="el" href="kblock_8h_source.html">kblock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c09ba3c8d69e8160284243c104ea6ae"></a><!-- doxytag: member="kblock.h::kblock_flush" ref="ga3c09ba3c8d69e8160284243c104ea6ae" args="(struct KBlock *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kblock_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush the cache (if any) to the device. </p>
<p>This function will write any pending modifications to the device. If the device does not have a cache, this function will do nothing.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if all is OK, EOF on errors. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#ga1f50056687e375253e3d11b11bc060a5" title="Read data from the block device.">kblock_read()</a>, <a class="el" href="group__io__kblock.html#ga069340cc7fe0a6aec2bada078ad9c889" title="Write data to the block device.">kblock_write()</a>, <a class="el" href="group__io__kblock.html#gaa3d27079ce4119ed5549cde2deb98fe8">kblock_buffered()</a>. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8c_source.html#l00117">117</a> of file <a class="el" href="kblock_8c_source.html">kblock.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga71ae645b5d672d3903b6646bd0955993"></a><!-- doxytag: member="kblock.h::kblock_partialWrite" ref="ga71ae645b5d672d3903b6646bd0955993" args="(struct KBlock *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kblock_partialWrite </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the device <em>b</em> supports partial block write. That is, you can call <a class="el" href="group__io__kblock.html#ga069340cc7fe0a6aec2bada078ad9c889" title="Write data to the block device.">kblock_write()</a> with a size which is lesser than the block size. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#ga069340cc7fe0a6aec2bada078ad9c889" title="Write data to the block device.">kblock_write()</a>. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8h_source.html#l00316">316</a> of file <a class="el" href="kblock_8h_source.html">kblock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f50056687e375253e3d11b11bc060a5"></a><!-- doxytag: member="kblock.h::kblock_read" ref="ga1f50056687e375253e3d11b11bc060a5" args="(struct KBlock *b, block_idx_t idx, void *buf, size_t offset, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t kblock_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from the block device. </p>
<p>This function will read <em>size</em> bytes from block <em>idx</em> starting at address <em>offset</em> inside the block.</p>
<p>Most block devices (almost all flash memories, for instance), can efficiently read even a part of the block.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function can be slow if you try to partial read a block from a device which does not support partial block reads and is opened in unbuffered mode.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device. </td></tr>
    <tr><td class="paramname">idx</td><td>the block number where you want to read. </td></tr>
    <tr><td class="paramname">buf</td><td>a buffer where the data will be read. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset inside the block from which data reading will start. </td></tr>
    <tr><td class="paramname">size</td><td>the size of data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes read.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#ga069340cc7fe0a6aec2bada078ad9c889" title="Write data to the block device.">kblock_write()</a>. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8c_source.html#l00103">103</a> of file <a class="el" href="kblock_8c_source.html">kblock.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a44548c390609987086cac6a2387b99"></a><!-- doxytag: member="kblock.h::kblock_trim" ref="ga0a44548c390609987086cac6a2387b99" args="(struct KBlock *b, block_idx_t start, block_idx_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kblock_trim </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use a subset of the blocks on the device. </p>
<p>This function is useful for partitioning a device and use it for different purposes at the same time.</p>
<p>This function will limit the number of blocks used on the device by setting a start index and a number of blocks to be used counting from that index.</p>
<p>The blocks outside this range are no more accessible.</p>
<p>Logical block indexes will be mapped to physical indexes inside this new range automatically. Even following calls to <a class="el" href="group__io__kblock.html#ga0a44548c390609987086cac6a2387b99" title="Use a subset of the blocks on the device.">kblock_trim()</a> will use logical indexes, so, once trimmed, access can only be limited further and never expanded back.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">//...init KBlock device dev</span>
 <a class="code" href="group__io__kblock.html#ga0a44548c390609987086cac6a2387b99" title="Use a subset of the blocks on the device.">kblock_trim</a>(dev, 200, 1500); <span class="comment">// Restrict access to the 200-1700 physical block range.</span>
 <a class="code" href="group__io__kblock.html#ga1f50056687e375253e3d11b11bc060a5" title="Read data from the block device.">kblock_read</a>(dev, 0, buf, 0, dev-&gt;blk_size);  <span class="comment">// Read from physical block #200.</span>
 <a class="code" href="group__io__kblock.html#ga0a44548c390609987086cac6a2387b99" title="Use a subset of the blocks on the device.">kblock_trim</a>(dev, 0, 300); <span class="comment">// Restrict access to the 200-500 physical block range.</span>
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device. </td></tr>
    <tr><td class="paramname">start</td><td>The index of the start block for the limiting window in logical addressing units. </td></tr>
    <tr><td class="paramname">count</td><td>The number of blocks to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if all is OK, EOF on errors. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8c_source.html#l00152">152</a> of file <a class="el" href="kblock_8c_source.html">kblock.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga069340cc7fe0a6aec2bada078ad9c889"></a><!-- doxytag: member="kblock.h::kblock_write" ref="ga069340cc7fe0a6aec2bada078ad9c889" args="(struct KBlock *b, block_idx_t idx, const void *buf, size_t offset, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t kblock_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structKBlock.html">KBlock</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__io__kblock.html#ga662608dd815d6c4b83ce42c3d153a88b">block_idx_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to the block device. </p>
<p>This function will write <em>size</em> bytes to block <em>idx</em> starting at address <em>offset</em> inside the block.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Partial block writes are supported only on certain devices. You can use <a class="el" href="group__io__kblock.html#ga71ae645b5d672d3903b6646bd0955993">kblock_partialWrite()</a> in order to check if the device has this feature or not.</dd>
<dd>
If the device is opened in buffered mode, this function will use efficiently and trasparently the cache provided. In order to be sure that all modifications are actually written to the device you have to call <a class="el" href="group__io__kblock.html#ga3c09ba3c8d69e8160284243c104ea6ae" title="Flush the cache (if any) to the device.">kblock_flush()</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><a class="el" href="structKBlock.html" title="KBlock: interface for a generic block device.">KBlock</a> device. </td></tr>
    <tr><td class="paramname">idx</td><td>the block number where you want to write. </td></tr>
    <tr><td class="paramname">buf</td><td>a pointer to the data to be written. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset inside the block from which data writing will start. </td></tr>
    <tr><td class="paramname">size</td><td>the size of data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes written.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__io__kblock.html#ga1f50056687e375253e3d11b11bc060a5" title="Read data from the block device.">kblock_read()</a>, <a class="el" href="group__io__kblock.html#ga3c09ba3c8d69e8160284243c104ea6ae" title="Flush the cache (if any) to the device.">kblock_flush()</a>, <a class="el" href="group__io__kblock.html#gaa3d27079ce4119ed5549cde2deb98fe8">kblock_buffered()</a>, <a class="el" href="group__io__kblock.html#ga71ae645b5d672d3903b6646bd0955993">kblock_partialWrite()</a>. </dd></dl>

<p>Definition at line <a class="el" href="kblock_8c_source.html#l00169">169</a> of file <a class="el" href="kblock_8c_source.html">kblock.c</a>.</p>

</div>
</div>
</div>


