

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_cd5151ad4b595b3b6d6807653813384b.html">fs</a>      </li>
      <li class="navelem"><a class="el" href="dir_bd5c0b238e05c2000320b63ac440e705.html">fatfs</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ff.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*----------------------------------------------------------------------------/</span>
<a name="l00002"></a>00002 <span class="comment">/  FatFs - FAT file system module  R0.07a                    (C)ChaN, 2009</span>
<a name="l00003"></a>00003 <span class="comment">/-----------------------------------------------------------------------------/</span>
<a name="l00004"></a>00004 <span class="comment">/ FatFs module is an open source software to implement FAT file system to</span>
<a name="l00005"></a>00005 <span class="comment">/ small embedded systems. This is a free software and is opened for education,</span>
<a name="l00006"></a>00006 <span class="comment">/ research and commercial developments under license policy of following trems.</span>
<a name="l00007"></a>00007 <span class="comment">/</span>
<a name="l00008"></a>00008 <span class="comment">/  Copyright (C) 2009, ChaN, all right reserved.</span>
<a name="l00009"></a>00009 <span class="comment">/</span>
<a name="l00010"></a>00010 <span class="comment">/ * The FatFs module is a free software and there is NO WARRANTY.</span>
<a name="l00011"></a>00011 <span class="comment">/ * No restriction on use. You can use, modify and redistribute it for</span>
<a name="l00012"></a>00012 <span class="comment">/   personal, non-profit or commercial use UNDER YOUR RESPONSIBILITY.</span>
<a name="l00013"></a>00013 <span class="comment">/ * Redistributions of source code must retain the above copyright notice.</span>
<a name="l00014"></a>00014 <span class="comment">//-----------------------------------------------------------------------------/</span>
<a name="l00015"></a>00015 <span class="comment">/ Feb 26,&#39;06 R0.00  Prototype.</span>
<a name="l00016"></a>00016 <span class="comment">/</span>
<a name="l00017"></a>00017 <span class="comment">/ Apr 29,&#39;06 R0.01  First stable version.</span>
<a name="l00018"></a>00018 <span class="comment">/</span>
<a name="l00019"></a>00019 <span class="comment">/ Jun 01,&#39;06 R0.02  Added FAT12 support.</span>
<a name="l00020"></a>00020 <span class="comment">/                   Removed unbuffered mode.</span>
<a name="l00021"></a>00021 <span class="comment">/                   Fixed a problem on small (&lt;32M) patition.</span>
<a name="l00022"></a>00022 <span class="comment">/ Jun 10,&#39;06 R0.02a Added a configuration option (_FS_MINIMUM).</span>
<a name="l00023"></a>00023 <span class="comment">/</span>
<a name="l00024"></a>00024 <span class="comment">/ Sep 22,&#39;06 R0.03  Added f_rename().</span>
<a name="l00025"></a>00025 <span class="comment">/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.</span>
<a name="l00026"></a>00026 <span class="comment">/ Dec 11,&#39;06 R0.03a Improved cluster scan algolithm to write files fast.</span>
<a name="l00027"></a>00027 <span class="comment">/                   Fixed f_mkdir() creates incorrect directory on FAT32.</span>
<a name="l00028"></a>00028 <span class="comment">/</span>
<a name="l00029"></a>00029 <span class="comment">/ Feb 04,&#39;07 R0.04  Supported multiple drive system.</span>
<a name="l00030"></a>00030 <span class="comment">/                   Changed some interfaces for multiple drive system.</span>
<a name="l00031"></a>00031 <span class="comment">/                   Changed f_mountdrv() to f_mount().</span>
<a name="l00032"></a>00032 <span class="comment">/                   Added f_mkfs().</span>
<a name="l00033"></a>00033 <span class="comment">/ Apr 01,&#39;07 R0.04a Supported multiple partitions on a plysical drive.</span>
<a name="l00034"></a>00034 <span class="comment">/                   Added a capability of extending file size to f_lseek().</span>
<a name="l00035"></a>00035 <span class="comment">/                   Added minimization level 3.</span>
<a name="l00036"></a>00036 <span class="comment">/                   Fixed an endian sensitive code in f_mkfs().</span>
<a name="l00037"></a>00037 <span class="comment">/ May 05,&#39;07 R0.04b Added a configuration option _USE_NTFLAG.</span>
<a name="l00038"></a>00038 <span class="comment">/                   Added FSInfo support.</span>
<a name="l00039"></a>00039 <span class="comment">/                   Fixed DBCS name can result FR_INVALID_NAME.</span>
<a name="l00040"></a>00040 <span class="comment">/                   Fixed short seek (&lt;= csize) collapses the file object.</span>
<a name="l00041"></a>00041 <span class="comment">/</span>
<a name="l00042"></a>00042 <span class="comment">/ Aug 25,&#39;07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().</span>
<a name="l00043"></a>00043 <span class="comment">/                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.</span>
<a name="l00044"></a>00044 <span class="comment">/                   Fixed f_mkdir() on FAT32 creates incorrect directory.</span>
<a name="l00045"></a>00045 <span class="comment">/ Feb 03,&#39;08 R0.05a Added f_truncate() and f_utime().</span>
<a name="l00046"></a>00046 <span class="comment">/                   Fixed off by one error at FAT sub-type determination.</span>
<a name="l00047"></a>00047 <span class="comment">/                   Fixed btr in f_read() can be mistruncated.</span>
<a name="l00048"></a>00048 <span class="comment">/                   Fixed cached sector is not flushed when create and close</span>
<a name="l00049"></a>00049 <span class="comment">/                   without write.</span>
<a name="l00050"></a>00050 <span class="comment">/</span>
<a name="l00051"></a>00051 <span class="comment">/ Apr 01,&#39;08 R0.06  Added fputc(), fputs(), fprintf() and fgets().</span>
<a name="l00052"></a>00052 <span class="comment">/                   Improved performance of f_lseek() on moving to the same</span>
<a name="l00053"></a>00053 <span class="comment">/                   or following cluster.</span>
<a name="l00054"></a>00054 <span class="comment">/</span>
<a name="l00055"></a>00055 <span class="comment">/ Apr 01,&#39;09 R0.07  Merged Tiny-FatFs as a buffer configuration option.</span>
<a name="l00056"></a>00056 <span class="comment">/                   Added long file name support.</span>
<a name="l00057"></a>00057 <span class="comment">/                   Added multiple code page support.</span>
<a name="l00058"></a>00058 <span class="comment">/                   Added re-entrancy for multitask operation.</span>
<a name="l00059"></a>00059 <span class="comment">/                   Added auto cluster size selection to f_mkfs().</span>
<a name="l00060"></a>00060 <span class="comment">/                   Added rewind option to f_readdir().</span>
<a name="l00061"></a>00061 <span class="comment">/                   Changed result code of critical errors.</span>
<a name="l00062"></a>00062 <span class="comment">/                   Renamed string functions to avoid name collision.</span>
<a name="l00063"></a>00063 <span class="comment">/ Apr 14,&#39;09 R0.07a Separated out OS dependent code on reentrant cfg.</span>
<a name="l00064"></a>00064 <span class="comment">/                   Added multiple sector size support.</span>
<a name="l00065"></a>00065 <span class="comment">/---------------------------------------------------------------------------*/</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;ff.h&quot;</span>         <span class="comment">/* FatFs configurations and declarations */</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;diskio.h&quot;</span>     <span class="comment">/* Declarations of low level disk I/O functions */</span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">/*--------------------------------------------------------------------------</span>
<a name="l00072"></a>00072 <span class="comment"></span>
<a name="l00073"></a>00073 <span class="comment">   Module Private Definitions</span>
<a name="l00074"></a>00074 <span class="comment"></span>
<a name="l00075"></a>00075 <span class="comment">---------------------------------------------------------------------------*/</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="preprocessor">#if _FS_REENTRANT</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#if _USE_LFN == 1</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#error Static LFN work area must not be used in re-entrant configuration.</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#define ENTER_FF(fs)        { if (!lock_fs(fs)) return FR_TIMEOUT; }</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#define LEAVE_FF(fs, res)   { unlock_fs(fs, res); return res; }</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00084"></a>00084 <span class="preprocessor">#else</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#define ENTER_FF(fs)</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#define LEAVE_FF(fs, res)   return res</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088 <span class="preprocessor">#endif</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>
<a name="l00090"></a>00090 <span class="preprocessor">#define ABORT(fs, res)      { fp-&gt;flag |= FA__ERROR; LEAVE_FF(fs, res); }</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>
<a name="l00092"></a>00092 <span class="preprocessor">#ifndef NULL</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#define NULL    0</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">/*--------------------------------------------------------------------------</span>
<a name="l00098"></a>00098 <span class="comment"></span>
<a name="l00099"></a>00099 <span class="comment">   Private Work Area</span>
<a name="l00100"></a>00100 <span class="comment"></span>
<a name="l00101"></a>00101 <span class="comment">---------------------------------------------------------------------------*/</span>
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keyword">static</span>
<a name="l00104"></a>00104 FATFS *FatFs[_DRIVES];  <span class="comment">/* Pointer to the file system objects (logical drives) */</span>
<a name="l00105"></a>00105 <span class="keyword">static</span>
<a name="l00106"></a>00106 WORD Fsid;              <span class="comment">/* File system mount ID */</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="preprocessor">#if _USE_LFN == 1   </span><span class="comment">/* LFN with static LFN working buffer */</span>
<a name="l00110"></a>00110 <span class="keyword">static</span>
<a name="l00111"></a>00111 WORD LfnBuf[_MAX_LFN + 1];
<a name="l00112"></a>00112 <span class="preprocessor">#define NAMEBUF(sp,lp)  BYTE sp[12]; WCHAR *lp = LfnBuf</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#define INITBUF(dj,sp,lp)   dj.fn = sp; dj.lfn = lp</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>
<a name="l00115"></a>00115 <span class="preprocessor">#elif _USE_LFN &gt; 1  </span><span class="comment">/* LFN with dynamic LFN working buffer */</span>
<a name="l00116"></a>00116 <span class="preprocessor">#define NAMEBUF(sp,lp)  BYTE sp[12]; WCHAR lbuf[_MAX_LFN + 1], *lp = lbuf</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#define INITBUF(dj,sp,lp)   dj.fn = sp; dj.lfn = lp</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>
<a name="l00119"></a>00119 <span class="preprocessor">#else               </span><span class="comment">/* No LFN */</span>
<a name="l00120"></a>00120 <span class="preprocessor">#define NAMEBUF(sp,lp)  BYTE sp[12]</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="preprocessor">#define INITBUF(dj,sp,lp)   dj.fn = sp</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>
<a name="l00123"></a>00123 <span class="preprocessor">#endif</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="comment">/*--------------------------------------------------------------------------</span>
<a name="l00129"></a>00129 <span class="comment"></span>
<a name="l00130"></a>00130 <span class="comment">   Private Functions</span>
<a name="l00131"></a>00131 <span class="comment"></span>
<a name="l00132"></a>00132 <span class="comment">---------------------------------------------------------------------------*/</span>
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00136"></a>00136 <span class="comment">/* String functions                                                      */</span>
<a name="l00137"></a>00137 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="comment">/* Copy memory to memory */</span>
<a name="l00140"></a>00140 <span class="keyword">static</span>
<a name="l00141"></a>00141 <span class="keywordtype">void</span> mem_cpy (<span class="keywordtype">void</span>* dst, <span class="keyword">const</span> <span class="keywordtype">void</span>* src, <span class="keywordtype">int</span> cnt) {
<a name="l00142"></a>00142     <span class="keywordtype">char</span> *d = (<span class="keywordtype">char</span>*)dst;
<a name="l00143"></a>00143     <span class="keyword">const</span> <span class="keywordtype">char</span> *s = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)src;
<a name="l00144"></a>00144     <span class="keywordflow">while</span> (cnt--) *d++ = *s++;
<a name="l00145"></a>00145 }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">/* Fill memory */</span>
<a name="l00148"></a>00148 <span class="keyword">static</span>
<a name="l00149"></a>00149 <span class="keywordtype">void</span> mem_set (<span class="keywordtype">void</span>* dst, <span class="keywordtype">int</span> val, <span class="keywordtype">int</span> cnt) {
<a name="l00150"></a>00150     <span class="keywordtype">char</span> *d = (<span class="keywordtype">char</span>*)dst;
<a name="l00151"></a>00151     <span class="keywordflow">while</span> (cnt--) *d++ = (char)val;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="comment">/* Compare memory to memory */</span>
<a name="l00155"></a>00155 <span class="keyword">static</span>
<a name="l00156"></a>00156 <span class="keywordtype">int</span> mem_cmp (<span class="keyword">const</span> <span class="keywordtype">void</span>* dst, <span class="keyword">const</span> <span class="keywordtype">void</span>* src, <span class="keywordtype">int</span> cnt) {
<a name="l00157"></a>00157     <span class="keyword">const</span> <span class="keywordtype">char</span> *d = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)dst, *s = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)src;
<a name="l00158"></a>00158     <span class="keywordtype">int</span> r = 0;
<a name="l00159"></a>00159     <span class="keywordflow">while</span> (cnt-- &amp;&amp; (r = *d++ - *s++) == 0) ;
<a name="l00160"></a>00160     <span class="keywordflow">return</span> r;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">/* Check if chr is contained in the string */</span>
<a name="l00164"></a>00164 <span class="keyword">static</span>
<a name="l00165"></a>00165 <span class="keywordtype">int</span> chk_chr (<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">int</span> chr) {
<a name="l00166"></a>00166     <span class="keywordflow">while</span> (*str &amp;&amp; *str != chr) str++;
<a name="l00167"></a>00167     <span class="keywordflow">return</span> *str;
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00173"></a>00173 <span class="comment">/* Request/Release grant to access the volume                            */</span>
<a name="l00174"></a>00174 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00175"></a>00175 <span class="preprocessor">#if _FS_REENTRANT</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span>
<a name="l00177"></a>00177 <span class="keyword">static</span>
<a name="l00178"></a>00178 BOOL lock_fs (
<a name="l00179"></a>00179     FATFS *fs       <span class="comment">/* File system object */</span>
<a name="l00180"></a>00180 )
<a name="l00181"></a>00181 {
<a name="l00182"></a>00182     <span class="keywordflow">return</span> ff_req_grant(fs-&gt;sobj);
<a name="l00183"></a>00183 }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="keyword">static</span>
<a name="l00187"></a>00187 <span class="keywordtype">void</span> unlock_fs (
<a name="l00188"></a>00188     FATFS *fs,      <span class="comment">/* File system object */</span>
<a name="l00189"></a>00189     FRESULT res     <span class="comment">/* Result code to be returned */</span>
<a name="l00190"></a>00190 )
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192     <span class="keywordflow">if</span> (res != FR_NOT_ENABLED &amp;&amp;
<a name="l00193"></a>00193         res != FR_INVALID_DRIVE &amp;&amp;
<a name="l00194"></a>00194         res != FR_INVALID_OBJECT &amp;&amp;
<a name="l00195"></a>00195         res != FR_TIMEOUT) {
<a name="l00196"></a>00196         ff_rel_grant(fs-&gt;sobj);
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198 }
<a name="l00199"></a>00199 <span class="preprocessor">#endif</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00204"></a>00204 <span class="comment">/* Change window offset                                                  */</span>
<a name="l00205"></a>00205 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keyword">static</span>
<a name="l00208"></a>00208 FRESULT move_window (
<a name="l00209"></a>00209     FATFS *fs,      <span class="comment">/* File system object */</span>
<a name="l00210"></a>00210     DWORD sector    <span class="comment">/* Sector number to make apperance in the fs-&gt;win[] */</span>
<a name="l00211"></a>00211 )                   <span class="comment">/* Move to zero only writes back dirty window */</span>
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213     DWORD wsect;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     wsect = fs-&gt;winsect;
<a name="l00217"></a>00217     <span class="keywordflow">if</span> (wsect != sector) {  <span class="comment">/* Changed current window */</span>
<a name="l00218"></a>00218 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fs-&gt;wflag) {    <span class="comment">/* Write back dirty window if needed */</span>
<a name="l00220"></a>00220             <span class="keywordflow">if</span> (disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1) != RES_OK)
<a name="l00221"></a>00221                 <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l00222"></a>00222             fs-&gt;wflag = 0;
<a name="l00223"></a>00223             <span class="keywordflow">if</span> (wsect &lt; (fs-&gt;fatbase + fs-&gt;sects_fat)) {    <span class="comment">/* In FAT area */</span>
<a name="l00224"></a>00224                 BYTE nf;
<a name="l00225"></a>00225                 <span class="keywordflow">for</span> (nf = fs-&gt;n_fats; nf &gt;= 2; nf--) {  <span class="comment">/* Refrect the change to FAT copy */</span>
<a name="l00226"></a>00226                     wsect += fs-&gt;sects_fat;
<a name="l00227"></a>00227                     disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1);
<a name="l00228"></a>00228                 }
<a name="l00229"></a>00229             }
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231 <span class="preprocessor">#endif</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (sector) {
<a name="l00233"></a>00233             <span class="keywordflow">if</span> (disk_read(fs-&gt;drive, fs-&gt;win, sector, 1) != RES_OK)
<a name="l00234"></a>00234                 <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l00235"></a>00235             fs-&gt;winsect = sector;
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keywordflow">return</span> FR_OK;
<a name="l00240"></a>00240 }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00246"></a>00246 <span class="comment">/* Clean-up cached data                                                  */</span>
<a name="l00247"></a>00247 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00248"></a>00248 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00250"></a>00250 FRESULT sync (  <span class="comment">/* FR_OK: successful, FR_DISK_ERR: failed */</span>
<a name="l00251"></a>00251     FATFS *fs   <span class="comment">/* File system object */</span>
<a name="l00252"></a>00252 )
<a name="l00253"></a>00253 {
<a name="l00254"></a>00254     FRESULT res;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     res = move_window(fs, 0);
<a name="l00258"></a>00258     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l00259"></a>00259         <span class="comment">/* Update FSInfo sector if needed */</span>
<a name="l00260"></a>00260         <span class="keywordflow">if</span> (fs-&gt;fs_type == FS_FAT32 &amp;&amp; fs-&gt;fsi_flag) {
<a name="l00261"></a>00261             fs-&gt;winsect = 0;
<a name="l00262"></a>00262             mem_set(fs-&gt;win, 0, 512);
<a name="l00263"></a>00263             ST_WORD(fs-&gt;win+BS_55AA, 0xAA55);
<a name="l00264"></a>00264             ST_DWORD(fs-&gt;win+FSI_LeadSig, 0x41615252);
<a name="l00265"></a>00265             ST_DWORD(fs-&gt;win+FSI_StrucSig, 0x61417272);
<a name="l00266"></a>00266             ST_DWORD(fs-&gt;win+FSI_Free_Count, fs-&gt;free_clust);
<a name="l00267"></a>00267             ST_DWORD(fs-&gt;win+FSI_Nxt_Free, fs-&gt;last_clust);
<a name="l00268"></a>00268             disk_write(fs-&gt;drive, fs-&gt;win, fs-&gt;fsi_sector, 1);
<a name="l00269"></a>00269             fs-&gt;fsi_flag = 0;
<a name="l00270"></a>00270         }
<a name="l00271"></a>00271         <span class="comment">/* Make sure that no pending write process in the physical drive */</span>
<a name="l00272"></a>00272         <span class="keywordflow">if</span> (disk_ioctl(fs-&gt;drive, CTRL_SYNC, (<span class="keywordtype">void</span>*)NULL) != RES_OK)
<a name="l00273"></a>00273             res = FR_DISK_ERR;
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276     <span class="keywordflow">return</span> res;
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 <span class="preprocessor">#endif</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00284"></a>00284 <span class="comment">/* Get a cluster status                                                  */</span>
<a name="l00285"></a>00285 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="keyword">static</span>
<a name="l00288"></a>00288 DWORD get_cluster ( <span class="comment">/* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */</span>
<a name="l00289"></a>00289     FATFS *fs,      <span class="comment">/* File system object */</span>
<a name="l00290"></a>00290     DWORD clst      <span class="comment">/* Cluster# to get the link information */</span>
<a name="l00291"></a>00291 )
<a name="l00292"></a>00292 {
<a name="l00293"></a>00293     WORD wc, bc;
<a name="l00294"></a>00294     DWORD fsect;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keywordflow">if</span> (clst &lt; 2 || clst &gt;= fs-&gt;max_clust)  <span class="comment">/* Check cluster address range */</span>
<a name="l00298"></a>00298         <span class="keywordflow">return</span> 1;
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     fsect = fs-&gt;fatbase;
<a name="l00301"></a>00301     <span class="keywordflow">switch</span> (fs-&gt;fs_type) {
<a name="l00302"></a>00302     <span class="keywordflow">case</span> FS_FAT12 :
<a name="l00303"></a>00303         bc = (WORD)clst * 3 / 2;
<a name="l00304"></a>00304         <span class="keywordflow">if</span> (move_window(fs, fsect + (bc / SS(fs)))) <span class="keywordflow">break</span>;
<a name="l00305"></a>00305         wc = fs-&gt;win[bc &amp; (SS(fs) - 1)]; bc++;
<a name="l00306"></a>00306         <span class="keywordflow">if</span> (move_window(fs, fsect + (bc / SS(fs)))) <span class="keywordflow">break</span>;
<a name="l00307"></a>00307         wc |= (WORD)fs-&gt;win[bc &amp; (SS(fs) - 1)] &lt;&lt; 8;
<a name="l00308"></a>00308         <span class="keywordflow">return</span> (clst &amp; 1) ? (wc &gt;&gt; 4) : (wc &amp; 0xFFF);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordflow">case</span> FS_FAT16 :
<a name="l00311"></a>00311         <span class="keywordflow">if</span> (move_window(fs, fsect + (clst / (SS(fs) / 2)))) <span class="keywordflow">break</span>;
<a name="l00312"></a>00312         <span class="keywordflow">return</span> LD_WORD(&amp;fs-&gt;win[((WORD)clst * 2) &amp; (SS(fs) - 1)]);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     <span class="keywordflow">case</span> FS_FAT32 :
<a name="l00315"></a>00315         <span class="keywordflow">if</span> (move_window(fs, fsect + (clst / (SS(fs) / 4)))) <span class="keywordflow">break</span>;
<a name="l00316"></a>00316         <span class="keywordflow">return</span> LD_DWORD(&amp;fs-&gt;win[((WORD)clst * 4) &amp; (SS(fs) - 1)]) &amp; 0x0FFFFFFF;
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     <span class="keywordflow">return</span> 0xFFFFFFFF;  <span class="comment">/* An error occured at the disk I/O layer */</span>
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00326"></a>00326 <span class="comment">/* Change a cluster status                                               */</span>
<a name="l00327"></a>00327 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00328"></a>00328 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00330"></a>00330 FRESULT put_cluster (
<a name="l00331"></a>00331     FATFS *fs,      <span class="comment">/* File system object */</span>
<a name="l00332"></a>00332     DWORD clst,     <span class="comment">/* Cluster# to be changed (must be 2 to fs-&gt;max_clust-1) */</span>
<a name="l00333"></a>00333     DWORD val       <span class="comment">/* New value to mark the cluster */</span>
<a name="l00334"></a>00334 )
<a name="l00335"></a>00335 {
<a name="l00336"></a>00336     WORD bc;
<a name="l00337"></a>00337     BYTE *p;
<a name="l00338"></a>00338     DWORD fsect;
<a name="l00339"></a>00339     FRESULT res;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 
<a name="l00342"></a>00342     <span class="keywordflow">if</span> (clst &lt; 2 || clst &gt;= fs-&gt;max_clust) {    <span class="comment">/* Check cluster address range */</span>
<a name="l00343"></a>00343         res = FR_INT_ERR;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345     } <span class="keywordflow">else</span> {
<a name="l00346"></a>00346         fsect = fs-&gt;fatbase;
<a name="l00347"></a>00347         <span class="keywordflow">switch</span> (fs-&gt;fs_type) {
<a name="l00348"></a>00348         <span class="keywordflow">case</span> FS_FAT12 :
<a name="l00349"></a>00349             bc = (WORD)clst * 3 / 2;
<a name="l00350"></a>00350             res = move_window(fs, fsect + (bc / SS(fs)));
<a name="l00351"></a>00351             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00352"></a>00352             p = &amp;fs-&gt;win[bc &amp; (SS(fs) - 1)];
<a name="l00353"></a>00353             *p = (clst &amp; 1) ? ((*p &amp; 0x0F) | ((BYTE)val &lt;&lt; 4)) : (BYTE)val;
<a name="l00354"></a>00354             bc++;
<a name="l00355"></a>00355             fs-&gt;wflag = 1;
<a name="l00356"></a>00356             res = move_window(fs, fsect + (bc / SS(fs)));
<a name="l00357"></a>00357             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00358"></a>00358             p = &amp;fs-&gt;win[bc &amp; (SS(fs) - 1)];
<a name="l00359"></a>00359             *p = (clst &amp; 1) ? (BYTE)(val &gt;&gt; 4) : ((*p &amp; 0xF0) | ((BYTE)(val &gt;&gt; 8) &amp; 0x0F));
<a name="l00360"></a>00360             <span class="keywordflow">break</span>;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362         <span class="keywordflow">case</span> FS_FAT16 :
<a name="l00363"></a>00363             res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
<a name="l00364"></a>00364             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00365"></a>00365             ST_WORD(&amp;fs-&gt;win[((WORD)clst * 2) &amp; (SS(fs) - 1)], (WORD)val);
<a name="l00366"></a>00366             <span class="keywordflow">break</span>;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         <span class="keywordflow">case</span> FS_FAT32 :
<a name="l00369"></a>00369             res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
<a name="l00370"></a>00370             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00371"></a>00371             ST_DWORD(&amp;fs-&gt;win[((WORD)clst * 4) &amp; (SS(fs) - 1)], val);
<a name="l00372"></a>00372             <span class="keywordflow">break</span>;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374         <span class="keywordflow">default</span> :
<a name="l00375"></a>00375             res = FR_INT_ERR;
<a name="l00376"></a>00376         }
<a name="l00377"></a>00377         fs-&gt;wflag = 1;
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     <span class="keywordflow">return</span> res;
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 <span class="preprocessor">#endif </span><span class="comment">/* !_FS_READONLY */</span>
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00388"></a>00388 <span class="comment">/* Remove a cluster chain                                                */</span>
<a name="l00389"></a>00389 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00390"></a>00390 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00391"></a>00391 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00392"></a>00392 FRESULT remove_chain (
<a name="l00393"></a>00393     FATFS *fs,          <span class="comment">/* File system object */</span>
<a name="l00394"></a>00394     DWORD clst          <span class="comment">/* Cluster# to remove chain from */</span>
<a name="l00395"></a>00395 )
<a name="l00396"></a>00396 {
<a name="l00397"></a>00397     FRESULT res;
<a name="l00398"></a>00398     DWORD nxt;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <span class="keywordflow">if</span> (clst &lt; 2 || clst &gt;= fs-&gt;max_clust) {    <span class="comment">/* Check cluster address range */</span>
<a name="l00402"></a>00402         res = FR_INT_ERR;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404     } <span class="keywordflow">else</span> {
<a name="l00405"></a>00405         res = FR_OK;
<a name="l00406"></a>00406         <span class="keywordflow">while</span> (clst &lt; fs-&gt;max_clust) {          <span class="comment">/* Not a last link? */</span>
<a name="l00407"></a>00407             nxt = get_cluster(fs, clst);        <span class="comment">/* Get cluster status */</span>
<a name="l00408"></a>00408             <span class="keywordflow">if</span> (nxt == 0) <span class="keywordflow">break</span>;                <span class="comment">/* Empty cluster? */</span>
<a name="l00409"></a>00409             <span class="keywordflow">if</span> (nxt == 1) { res = FR_INT_ERR; <span class="keywordflow">break</span>; }  <span class="comment">/* Internal error? */</span>
<a name="l00410"></a>00410             <span class="keywordflow">if</span> (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; <span class="keywordflow">break</span>; }    <span class="comment">/* Disk error? */</span>
<a name="l00411"></a>00411             res = put_cluster(fs, clst, 0);     <span class="comment">/* Mark the cluster &quot;empty&quot; */</span>
<a name="l00412"></a>00412             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00413"></a>00413             <span class="keywordflow">if</span> (fs-&gt;free_clust != 0xFFFFFFFF) { <span class="comment">/* Update FSInfo */</span>
<a name="l00414"></a>00414                 fs-&gt;free_clust++;
<a name="l00415"></a>00415                 fs-&gt;fsi_flag = 1;
<a name="l00416"></a>00416             }
<a name="l00417"></a>00417             clst = nxt; <span class="comment">/* Next cluster */</span>
<a name="l00418"></a>00418         }
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     <span class="keywordflow">return</span> res;
<a name="l00422"></a>00422 }
<a name="l00423"></a>00423 <span class="preprocessor">#endif</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span>
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00429"></a>00429 <span class="comment">/* Stretch or create a cluster chain                                     */</span>
<a name="l00430"></a>00430 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00431"></a>00431 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00433"></a>00433 DWORD create_chain (    <span class="comment">/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, &gt;=2:New cluster# */</span>
<a name="l00434"></a>00434     FATFS *fs,          <span class="comment">/* File system object */</span>
<a name="l00435"></a>00435     DWORD clst          <span class="comment">/* Cluster# to stretch. 0 means create a new chain. */</span>
<a name="l00436"></a>00436 )
<a name="l00437"></a>00437 {
<a name="l00438"></a>00438     DWORD cs, ncl, scl, mcl;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 
<a name="l00441"></a>00441     mcl = fs-&gt;max_clust;
<a name="l00442"></a>00442     <span class="keywordflow">if</span> (clst == 0) {        <span class="comment">/* Create new chain */</span>
<a name="l00443"></a>00443         scl = fs-&gt;last_clust;           <span class="comment">/* Get suggested start point */</span>
<a name="l00444"></a>00444         <span class="keywordflow">if</span> (scl == 0 || scl &gt;= mcl) scl = 1;
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446     <span class="keywordflow">else</span> {                  <span class="comment">/* Stretch existing chain */</span>
<a name="l00447"></a>00447         cs = get_cluster(fs, clst);     <span class="comment">/* Check the cluster status */</span>
<a name="l00448"></a>00448         <span class="keywordflow">if</span> (cs &lt; 2) <span class="keywordflow">return</span> 1;           <span class="comment">/* It is an invalid cluster */</span>
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (cs &lt; mcl) <span class="keywordflow">return</span> cs;        <span class="comment">/* It is already followed by next cluster */</span>
<a name="l00450"></a>00450         scl = clst;
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     ncl = scl;              <span class="comment">/* Start cluster */</span>
<a name="l00454"></a>00454     <span class="keywordflow">for</span> (;;) {
<a name="l00455"></a>00455         ncl++;                          <span class="comment">/* Next cluster */</span>
<a name="l00456"></a>00456         <span class="keywordflow">if</span> (ncl &gt;= mcl) {               <span class="comment">/* Wrap around */</span>
<a name="l00457"></a>00457             ncl = 2;
<a name="l00458"></a>00458             <span class="keywordflow">if</span> (ncl &gt; scl) <span class="keywordflow">return</span> 0;    <span class="comment">/* No free custer */</span>
<a name="l00459"></a>00459         }
<a name="l00460"></a>00460         cs = get_cluster(fs, ncl);      <span class="comment">/* Get the cluster status */</span>
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (cs == 0) <span class="keywordflow">break</span>;             <span class="comment">/* Found a free cluster */</span>
<a name="l00462"></a>00462         <span class="keywordflow">if</span> (cs == 0xFFFFFFFF || cs == 1)<span class="comment">/* An error occured */</span>
<a name="l00463"></a>00463             <span class="keywordflow">return</span> cs;
<a name="l00464"></a>00464         <span class="keywordflow">if</span> (ncl == scl) <span class="keywordflow">return</span> 0;       <span class="comment">/* No free custer */</span>
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     <span class="keywordflow">if</span> (put_cluster(fs, ncl, 0x0FFFFFFF))   <span class="comment">/* Mark the new cluster &quot;in use&quot; */</span>
<a name="l00468"></a>00468         <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00469"></a>00469     <span class="keywordflow">if</span> (clst != 0) {                        <span class="comment">/* Link it to previous one if needed */</span>
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (put_cluster(fs, clst, ncl))
<a name="l00471"></a>00471             <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474     fs-&gt;last_clust = ncl;               <span class="comment">/* Update FSINFO */</span>
<a name="l00475"></a>00475     <span class="keywordflow">if</span> (fs-&gt;free_clust != 0xFFFFFFFF) {
<a name="l00476"></a>00476         fs-&gt;free_clust--;
<a name="l00477"></a>00477         fs-&gt;fsi_flag = 1;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480     <span class="keywordflow">return</span> ncl;     <span class="comment">/* Return new cluster number */</span>
<a name="l00481"></a>00481 }
<a name="l00482"></a>00482 <span class="preprocessor">#endif </span><span class="comment">/* !_FS_READONLY */</span>
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00488"></a>00488 <span class="comment">/* Get sector# from cluster#                                             */</span>
<a name="l00489"></a>00489 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="keyword">static</span>
<a name="l00492"></a>00492 DWORD clust2sect (  <span class="comment">/* !=0: sector number, 0: failed - invalid cluster# */</span>
<a name="l00493"></a>00493     FATFS *fs,      <span class="comment">/* File system object */</span>
<a name="l00494"></a>00494     DWORD clst      <span class="comment">/* Cluster# to be converted */</span>
<a name="l00495"></a>00495 )
<a name="l00496"></a>00496 {
<a name="l00497"></a>00497     clst -= 2;
<a name="l00498"></a>00498     <span class="keywordflow">if</span> (clst &gt;= (fs-&gt;max_clust - 2)) <span class="keywordflow">return</span> 0;      <span class="comment">/* Invalid cluster# */</span>
<a name="l00499"></a>00499     <span class="keywordflow">return</span> clst * fs-&gt;csize + fs-&gt;database;
<a name="l00500"></a>00500 }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00506"></a>00506 <span class="comment">/* Seek directory index                                                  */</span>
<a name="l00507"></a>00507 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="keyword">static</span>
<a name="l00510"></a>00510 FRESULT dir_seek (
<a name="l00511"></a>00511     DIR *dj,        <span class="comment">/* Pointer to directory object */</span>
<a name="l00512"></a>00512     WORD idx        <span class="comment">/* Directory index number */</span>
<a name="l00513"></a>00513 )
<a name="l00514"></a>00514 {
<a name="l00515"></a>00515     DWORD clst;
<a name="l00516"></a>00516     WORD ic;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     dj-&gt;index = idx;
<a name="l00520"></a>00520     clst = dj-&gt;sclust;
<a name="l00521"></a>00521     <span class="keywordflow">if</span> (clst == 1 || clst &gt;= dj-&gt;fs-&gt;max_clust) <span class="comment">/* Check start cluster range */</span>
<a name="l00522"></a>00522         <span class="keywordflow">return</span> FR_INT_ERR;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524     <span class="keywordflow">if</span> (clst == 0) {    <span class="comment">/* Static table */</span>
<a name="l00525"></a>00525         <span class="keywordflow">if</span> (idx &gt;= dj-&gt;fs-&gt;n_rootdir)       <span class="comment">/* Index is out of range */</span>
<a name="l00526"></a>00526             <span class="keywordflow">return</span> FR_INT_ERR;
<a name="l00527"></a>00527         dj-&gt;sect = dj-&gt;fs-&gt;dirbase + idx / (SS(dj-&gt;fs) / 32);
<a name="l00528"></a>00528     }
<a name="l00529"></a>00529     <span class="keywordflow">else</span> {              <span class="comment">/* Dynamic table */</span>
<a name="l00530"></a>00530         ic = SS(dj-&gt;fs) / 32 * dj-&gt;fs-&gt;csize;   <span class="comment">/* Indexes per cluster */</span>
<a name="l00531"></a>00531         <span class="keywordflow">while</span> (idx &gt;= ic) { <span class="comment">/* Follow cluster chain */</span>
<a name="l00532"></a>00532             clst = get_cluster(dj-&gt;fs, clst);           <span class="comment">/* Get next cluster */</span>
<a name="l00533"></a>00533             <span class="keywordflow">if</span> (clst == 0xFFFFFFFF) <span class="keywordflow">return</span> FR_DISK_ERR; <span class="comment">/* Disk error */</span>
<a name="l00534"></a>00534             <span class="keywordflow">if</span> (clst &lt; 2 || clst &gt;= dj-&gt;fs-&gt;max_clust)  <span class="comment">/* Reached to end of table or int error */</span>
<a name="l00535"></a>00535                 <span class="keywordflow">return</span> FR_INT_ERR;
<a name="l00536"></a>00536             idx -= ic;
<a name="l00537"></a>00537         }
<a name="l00538"></a>00538         dj-&gt;clust = clst;
<a name="l00539"></a>00539         dj-&gt;sect = clust2sect(dj-&gt;fs, clst) + idx / (SS(dj-&gt;fs) / 32);
<a name="l00540"></a>00540     }
<a name="l00541"></a>00541     dj-&gt;dir = dj-&gt;fs-&gt;win + (idx % (SS(dj-&gt;fs) / 32)) * 32;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="keywordflow">return</span> FR_OK;   <span class="comment">/* Seek succeeded */</span>
<a name="l00544"></a>00544 }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00550"></a>00550 <span class="comment">/* Move directory index next                                             */</span>
<a name="l00551"></a>00551 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 <span class="keyword">static</span>
<a name="l00554"></a>00554 FRESULT dir_next (  <span class="comment">/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */</span>
<a name="l00555"></a>00555     DIR *dj,        <span class="comment">/* Pointer to directory object */</span>
<a name="l00556"></a>00556     BOOL streach    <span class="comment">/* FALSE: Do not streach table, TRUE: Streach table if needed */</span>
<a name="l00557"></a>00557 )
<a name="l00558"></a>00558 {
<a name="l00559"></a>00559     DWORD clst;
<a name="l00560"></a>00560     WORD i;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     i = dj-&gt;index + 1;
<a name="l00564"></a>00564     <span class="keywordflow">if</span> (!i || !dj-&gt;sect)    <span class="comment">/* Report EOT when index has reached 65535 */</span>
<a name="l00565"></a>00565         <span class="keywordflow">return</span> FR_NO_FILE;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567     <span class="keywordflow">if</span> (!(i % (SS(dj-&gt;fs) / 32))) { <span class="comment">/* Sector changed? */</span>
<a name="l00568"></a>00568         dj-&gt;sect++;                 <span class="comment">/* Next sector */</span>
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         <span class="keywordflow">if</span> (dj-&gt;sclust == 0) {  <span class="comment">/* Static table */</span>
<a name="l00571"></a>00571             <span class="keywordflow">if</span> (i &gt;= dj-&gt;fs-&gt;n_rootdir) <span class="comment">/* Report EOT when end of table */</span>
<a name="l00572"></a>00572                 <span class="keywordflow">return</span> FR_NO_FILE;
<a name="l00573"></a>00573         }
<a name="l00574"></a>00574         <span class="keywordflow">else</span> {                  <span class="comment">/* Dynamic table */</span>
<a name="l00575"></a>00575             <span class="keywordflow">if</span> (((i / (SS(dj-&gt;fs) / 32)) &amp; (dj-&gt;fs-&gt;csize - 1)) == 0) { <span class="comment">/* Cluster changed? */</span>
<a name="l00576"></a>00576                 clst = get_cluster(dj-&gt;fs, dj-&gt;clust);          <span class="comment">/* Get next cluster */</span>
<a name="l00577"></a>00577                 <span class="keywordflow">if</span> (clst &lt;= 1) <span class="keywordflow">return</span> FR_INT_ERR;
<a name="l00578"></a>00578                 <span class="keywordflow">if</span> (clst == 0xFFFFFFFF) <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l00579"></a>00579                 <span class="keywordflow">if</span> (clst &gt;= dj-&gt;fs-&gt;max_clust) {                <span class="comment">/* When it reached end of dinamic table */</span>
<a name="l00580"></a>00580 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00581"></a>00581 <span class="preprocessor"></span>                    BYTE c;
<a name="l00582"></a>00582                     <span class="keywordflow">if</span> (!streach) <span class="keywordflow">return</span> FR_NO_FILE;            <span class="comment">/* When do not streach, report EOT */</span>
<a name="l00583"></a>00583                     clst = create_chain(dj-&gt;fs, dj-&gt;clust);     <span class="comment">/* Streach cluster chain */</span>
<a name="l00584"></a>00584                     <span class="keywordflow">if</span> (clst == 0) <span class="keywordflow">return</span> FR_DENIED;            <span class="comment">/* No free cluster */</span>
<a name="l00585"></a>00585                     <span class="keywordflow">if</span> (clst == 1) <span class="keywordflow">return</span> FR_INT_ERR;
<a name="l00586"></a>00586                     <span class="keywordflow">if</span> (clst == 0xFFFFFFFF) <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l00587"></a>00587                     <span class="comment">/* Clean-up streached table */</span>
<a name="l00588"></a>00588                     <span class="keywordflow">if</span> (move_window(dj-&gt;fs, 0)) <span class="keywordflow">return</span> FR_DISK_ERR; <span class="comment">/* Flush active window */</span>
<a name="l00589"></a>00589                     mem_set(dj-&gt;fs-&gt;win, 0, SS(dj-&gt;fs));            <span class="comment">/* Clear window buffer */</span>
<a name="l00590"></a>00590                     dj-&gt;fs-&gt;winsect = clust2sect(dj-&gt;fs, clst); <span class="comment">/* Cluster start sector */</span>
<a name="l00591"></a>00591                     <span class="keywordflow">for</span> (c = 0; c &lt; dj-&gt;fs-&gt;csize; c++) {       <span class="comment">/* Fill the new cluster with 0 */</span>
<a name="l00592"></a>00592                         dj-&gt;fs-&gt;wflag = 1;
<a name="l00593"></a>00593                         <span class="keywordflow">if</span> (move_window(dj-&gt;fs, 0)) <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l00594"></a>00594                         dj-&gt;fs-&gt;winsect++;
<a name="l00595"></a>00595                     }
<a name="l00596"></a>00596                     dj-&gt;fs-&gt;winsect -= c;                       <span class="comment">/* Rewind window address */</span>
<a name="l00597"></a>00597 <span class="preprocessor">#else</span>
<a name="l00598"></a>00598 <span class="preprocessor"></span>                    <span class="keywordflow">return</span> FR_NO_FILE;          <span class="comment">/* Report EOT */</span>
<a name="l00599"></a>00599 <span class="preprocessor">#endif</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span>                }
<a name="l00601"></a>00601                 dj-&gt;clust = clst;               <span class="comment">/* Initialize data for new cluster */</span>
<a name="l00602"></a>00602                 dj-&gt;sect = clust2sect(dj-&gt;fs, clst);
<a name="l00603"></a>00603             }
<a name="l00604"></a>00604         }
<a name="l00605"></a>00605     }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     dj-&gt;index = i;
<a name="l00608"></a>00608     dj-&gt;dir = dj-&gt;fs-&gt;win + (i % (SS(dj-&gt;fs) / 32)) * 32;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610     <span class="keywordflow">return</span> FR_OK;
<a name="l00611"></a>00611 }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00617"></a>00617 <span class="comment">/* Test/Pick/Fit an LFN segment from/to directory entry                  */</span>
<a name="l00618"></a>00618 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00619"></a>00619 <span class="preprocessor">#if _USE_LFN</span>
<a name="l00620"></a>00620 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00621"></a>00621 <span class="keyword">const</span> BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};  <span class="comment">/* Offset of LFN chars in the directory entry */</span>
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 <span class="keyword">static</span>
<a name="l00625"></a>00625 BOOL test_lfn (         <span class="comment">/* TRUE:Matched, FALSE:Not matched */</span>
<a name="l00626"></a>00626     WCHAR *lfnbuf,      <span class="comment">/* Pointer to the LFN to be compared */</span>
<a name="l00627"></a>00627     BYTE *dir           <span class="comment">/* Pointer to the directory entry containing a part of LFN */</span>
<a name="l00628"></a>00628 )
<a name="l00629"></a>00629 {
<a name="l00630"></a>00630     <span class="keywordtype">int</span> i, s;
<a name="l00631"></a>00631     WCHAR wc1, wc2;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     i = ((dir[LDIR_Ord] &amp; 0xBF) - 1) * 13;  <span class="comment">/* Offset in the LFN buffer */</span>
<a name="l00635"></a>00635     s = 0;
<a name="l00636"></a>00636     <span class="keywordflow">do</span> {
<a name="l00637"></a>00637         <span class="keywordflow">if</span> (i &gt;= _MAX_LFN) <span class="keywordflow">return</span> FALSE;    <span class="comment">/* Out of buffer range? */</span>
<a name="l00638"></a>00638         wc1 = LD_WORD(dir+LfnOfs[s]);       <span class="comment">/* Get both characters to compare */</span>
<a name="l00639"></a>00639         wc2 = lfnbuf[i++];
<a name="l00640"></a>00640         <span class="keywordflow">if</span> (IsLower(wc1)) wc1 -= 0x20;      <span class="comment">/* Compare it (ignore case) */</span>
<a name="l00641"></a>00641         <span class="keywordflow">if</span> (IsLower(wc2)) wc2 -= 0x20;
<a name="l00642"></a>00642         <span class="keywordflow">if</span> (wc1 != wc2) <span class="keywordflow">return</span> FALSE;
<a name="l00643"></a>00643     } <span class="keywordflow">while</span> (++s &lt; 13 &amp;&amp; wc1);              <span class="comment">/* Repeat until last char or a NUL char is processed */</span>
<a name="l00644"></a>00644 
<a name="l00645"></a>00645     <span class="keywordflow">return</span> TRUE;                            <span class="comment">/* The LFN entry matched */</span>
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 
<a name="l00650"></a>00650 <span class="keyword">static</span>
<a name="l00651"></a>00651 BOOL pick_lfn (         <span class="comment">/* TRUE:Succeeded, FALSE:Buffer overflow */</span>
<a name="l00652"></a>00652     WCHAR *lfnbuf,      <span class="comment">/* Pointer to the Unicode-LFN buffer */</span>
<a name="l00653"></a>00653     BYTE *dir           <span class="comment">/* Pointer to the directory entry */</span>
<a name="l00654"></a>00654 )
<a name="l00655"></a>00655 {
<a name="l00656"></a>00656     <span class="keywordtype">int</span> i, s;
<a name="l00657"></a>00657     WCHAR wchr;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     i = ((dir[LDIR_Ord] &amp; 0xBF) - 1) * 13;  <span class="comment">/* Offset in the LFN buffer */</span>
<a name="l00661"></a>00661     s = 0;
<a name="l00662"></a>00662     <span class="keywordflow">do</span> {
<a name="l00663"></a>00663         wchr = LD_WORD(dir+LfnOfs[s]);      <span class="comment">/* Get an LFN char */</span>
<a name="l00664"></a>00664         <span class="keywordflow">if</span> (!wchr) <span class="keywordflow">break</span>;                   <span class="comment">/* End of LFN? */</span>
<a name="l00665"></a>00665         <span class="keywordflow">if</span> (i &gt;= _MAX_LFN) <span class="keywordflow">return</span> FALSE;    <span class="comment">/* Buffer overflow */</span>
<a name="l00666"></a>00666         lfnbuf[i++] = wchr;                 <span class="comment">/* Store it */</span>
<a name="l00667"></a>00667     } <span class="keywordflow">while</span> (++s &lt; 13);                     <span class="comment">/* Repeat until last char is copied */</span>
<a name="l00668"></a>00668     <span class="keywordflow">if</span> (dir[LDIR_Ord] &amp; 0x40) lfnbuf[i] = 0;    <span class="comment">/* Put terminator if last LFN entry */</span>
<a name="l00669"></a>00669 
<a name="l00670"></a>00670     <span class="keywordflow">return</span> TRUE;
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00675"></a>00675 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00676"></a>00676 <span class="keywordtype">void</span> fit_lfn (
<a name="l00677"></a>00677     <span class="keyword">const</span> WCHAR *lfnbuf,    <span class="comment">/* Pointer to the LFN buffer */</span>
<a name="l00678"></a>00678     BYTE *dir,              <span class="comment">/* Pointer to the directory entry */</span>
<a name="l00679"></a>00679     BYTE ord,               <span class="comment">/* LFN order (1-20) */</span>
<a name="l00680"></a>00680     BYTE sum                <span class="comment">/* SFN sum */</span>
<a name="l00681"></a>00681 )
<a name="l00682"></a>00682 {
<a name="l00683"></a>00683     <span class="keywordtype">int</span> i, s;
<a name="l00684"></a>00684     WCHAR wchr;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 
<a name="l00687"></a>00687     dir[LDIR_Chksum] = sum;         <span class="comment">/* Set check sum */</span>
<a name="l00688"></a>00688     dir[LDIR_Attr] = AM_LFN;        <span class="comment">/* Set attribute. LFN entry */</span>
<a name="l00689"></a>00689     dir[LDIR_Type] = 0;
<a name="l00690"></a>00690     ST_WORD(dir+LDIR_FstClusLO, 0);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692     i = (ord - 1) * 13;             <span class="comment">/* Offset in the LFN buffer */</span>
<a name="l00693"></a>00693     s = wchr = 0;
<a name="l00694"></a>00694     <span class="keywordflow">do</span> {
<a name="l00695"></a>00695         <span class="keywordflow">if</span> (wchr != 0xFFFF) wchr = lfnbuf[i++]; <span class="comment">/* Get an effective char */</span>
<a name="l00696"></a>00696         ST_WORD(dir+LfnOfs[s], wchr);   <span class="comment">/* Put it */</span>
<a name="l00697"></a>00697         <span class="keywordflow">if</span> (!wchr) wchr = 0xFFFF;   <span class="comment">/* Padding chars following last char */</span>
<a name="l00698"></a>00698     } <span class="keywordflow">while</span> (++s &lt; 13);
<a name="l00699"></a>00699     <span class="keywordflow">if</span> (wchr == 0xFFFF || !lfnbuf[i]) ord |= 0x40;<span class="comment">/* Bottom LFN part is the start of LFN sequence */</span>
<a name="l00700"></a>00700     dir[LDIR_Ord] = ord;            <span class="comment">/* Set the LFN order */</span>
<a name="l00701"></a>00701 }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 <span class="preprocessor">#endif</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00705"></a>00705 <span class="preprocessor"></span>
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 
<a name="l00708"></a>00708 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00709"></a>00709 <span class="comment">/* Create numbered name                                                  */</span>
<a name="l00710"></a>00710 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00711"></a>00711 <span class="preprocessor">#if _USE_LFN</span>
<a name="l00712"></a>00712 <span class="preprocessor"></span><span class="keywordtype">void</span> gen_numname (
<a name="l00713"></a>00713     BYTE *dst,          <span class="comment">/* Pointer to genartated SFN */</span>
<a name="l00714"></a>00714     <span class="keyword">const</span> BYTE *src,    <span class="comment">/* Pointer to source SFN to be modified */</span>
<a name="l00715"></a>00715     <span class="keyword">const</span> WCHAR *lfn,   <span class="comment">/* Pointer to LFN */</span>
<a name="l00716"></a>00716     WORD num            <span class="comment">/* Sequense number */</span>
<a name="l00717"></a>00717 )
<a name="l00718"></a>00718 {
<a name="l00719"></a>00719     <span class="keywordtype">char</span> ns[8];
<a name="l00720"></a>00720     <span class="keywordtype">int</span> i, j;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 
<a name="l00723"></a>00723     mem_cpy(dst, src, 11);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     <span class="keywordflow">if</span> (num &gt; 5) {  <span class="comment">/* On many collisions, generate a hash number instead of sequencial number */</span>
<a name="l00726"></a>00726         <span class="keywordflow">do</span> num = (num &gt;&gt; 1) + (num &lt;&lt; 15) + (WORD)*lfn++; <span class="keywordflow">while</span> (*lfn);
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     <span class="comment">/* itoa */</span>
<a name="l00730"></a>00730     i = 7;
<a name="l00731"></a>00731     <span class="keywordflow">do</span> {
<a name="l00732"></a>00732         ns[i--] = (num % 10) + <span class="charliteral">&#39;0&#39;</span>;
<a name="l00733"></a>00733         num /= 10;
<a name="l00734"></a>00734     } <span class="keywordflow">while</span> (num);
<a name="l00735"></a>00735     ns[i] = <span class="charliteral">&#39;~&#39;</span>;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737     <span class="comment">/* Append the number */</span>
<a name="l00738"></a>00738     <span class="keywordflow">for</span> (j = 0; j &lt; i &amp;&amp; dst[j] != <span class="charliteral">&#39; &#39;</span>; j++) {
<a name="l00739"></a>00739         <span class="keywordflow">if</span> (IsDBCS1(dst[j])) {
<a name="l00740"></a>00740             <span class="keywordflow">if</span> (j == i - 1) <span class="keywordflow">break</span>;
<a name="l00741"></a>00741             j++;
<a name="l00742"></a>00742         }
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744     <span class="keywordflow">do</span> {
<a name="l00745"></a>00745         dst[j++] = (i &lt; 8) ? ns[i++] : <span class="charliteral">&#39; &#39;</span>;
<a name="l00746"></a>00746     } <span class="keywordflow">while</span> (j &lt; 8);
<a name="l00747"></a>00747 }
<a name="l00748"></a>00748 <span class="preprocessor">#endif</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span>
<a name="l00750"></a>00750 
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00754"></a>00754 <span class="comment">/* Calculate sum of an SFN                                               */</span>
<a name="l00755"></a>00755 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00756"></a>00756 <span class="preprocessor">#if _USE_LFN</span>
<a name="l00757"></a>00757 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00758"></a>00758 BYTE sum_sfn (
<a name="l00759"></a>00759     <span class="keyword">const</span> BYTE *dir     <span class="comment">/* Ptr to directory entry */</span>
<a name="l00760"></a>00760 )
<a name="l00761"></a>00761 {
<a name="l00762"></a>00762     BYTE sum = 0;
<a name="l00763"></a>00763     <span class="keywordtype">int</span> n = 11;
<a name="l00764"></a>00764 
<a name="l00765"></a>00765     <span class="keywordflow">do</span> sum = (sum &gt;&gt; 1) + (sum &lt;&lt; 7) + *dir++; <span class="keywordflow">while</span> (--n);
<a name="l00766"></a>00766     <span class="keywordflow">return</span> sum;
<a name="l00767"></a>00767 }
<a name="l00768"></a>00768 <span class="preprocessor">#endif</span>
<a name="l00769"></a>00769 <span class="preprocessor"></span>
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00774"></a>00774 <span class="comment">/* Find an object in the directory                                       */</span>
<a name="l00775"></a>00775 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="keyword">static</span>
<a name="l00778"></a>00778 FRESULT dir_find (
<a name="l00779"></a>00779     DIR *dj         <span class="comment">/* Pointer to the directory object linked to the file name */</span>
<a name="l00780"></a>00780 )
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782     FRESULT res;
<a name="l00783"></a>00783     BYTE a, c, lfen, ord, sum, *dir;
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 
<a name="l00786"></a>00786     res = dir_seek(dj, 0);          <span class="comment">/* Rewind directory object */</span>
<a name="l00787"></a>00787     <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">return</span> res;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789     ord = sum = 0xFF; lfen = *(dj-&gt;fn+11) &amp; 1;
<a name="l00790"></a>00790     <span class="keywordflow">do</span> {
<a name="l00791"></a>00791         res = move_window(dj-&gt;fs, dj-&gt;sect);
<a name="l00792"></a>00792         <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00793"></a>00793         dir = dj-&gt;dir;                  <span class="comment">/* Ptr to the directory entry of current index */</span>
<a name="l00794"></a>00794         c = dir[DIR_Name];
<a name="l00795"></a>00795         <span class="keywordflow">if</span> (c == 0) { res = FR_NO_FILE; <span class="keywordflow">break</span>; }    <span class="comment">/* Reached to end of table */</span>
<a name="l00796"></a>00796         a = dir[DIR_Attr] &amp; AM_MASK;
<a name="l00797"></a>00797 <span class="preprocessor">#if _USE_LFN    </span><span class="comment">/* LFN configuration */</span>
<a name="l00798"></a>00798         <span class="keywordflow">if</span> (c == 0xE5 || c == <span class="charliteral">&#39;.&#39;</span> || ((a &amp; AM_VOL) &amp;&amp; a != AM_LFN)) {   <span class="comment">/* An entry without valid data */</span>
<a name="l00799"></a>00799             ord = 0xFF;
<a name="l00800"></a>00800         } <span class="keywordflow">else</span> {
<a name="l00801"></a>00801             <span class="keywordflow">if</span> (a == AM_LFN) {          <span class="comment">/* An LFN entry is found */</span>
<a name="l00802"></a>00802                 <span class="keywordflow">if</span> (dj-&gt;lfn) {
<a name="l00803"></a>00803                     <span class="keywordflow">if</span> (c &amp; 0x40) {     <span class="comment">/* Is it start of LFN sequence? */</span>
<a name="l00804"></a>00804                         sum = dir[LDIR_Chksum];
<a name="l00805"></a>00805                         c &amp;= 0xBF; ord = c;     <span class="comment">/* LFN start order */</span>
<a name="l00806"></a>00806                         dj-&gt;lfn_idx = dj-&gt;index;
<a name="l00807"></a>00807                     }
<a name="l00808"></a>00808                     <span class="comment">/* Check LFN validity. Compare LFN if it is out of 8.3 format */</span>
<a name="l00809"></a>00809                     ord = (c == ord &amp;&amp; sum == dir[LDIR_Chksum] &amp;&amp; (!lfen || test_lfn(dj-&gt;lfn, dir))) ? ord - 1 : 0xFF;
<a name="l00810"></a>00810                 }
<a name="l00811"></a>00811             } <span class="keywordflow">else</span> {                    <span class="comment">/* An SFN entry is found */</span>
<a name="l00812"></a>00812                 <span class="keywordflow">if</span> (ord || sum != sum_sfn(dir)) {   <span class="comment">/* Did not LFN match? */</span>
<a name="l00813"></a>00813                     dj-&gt;lfn_idx = 0xFFFF;
<a name="l00814"></a>00814                     ord = 0xFF;
<a name="l00815"></a>00815                 }
<a name="l00816"></a>00816                 <span class="keywordflow">if</span> (lfen) {             <span class="comment">/* Match LFN if it is out of 8.3 format */</span>
<a name="l00817"></a>00817                     <span class="keywordflow">if</span> (ord == 0) <span class="keywordflow">break</span>;
<a name="l00818"></a>00818                 } <span class="keywordflow">else</span> {                <span class="comment">/* Match SFN if LFN is in 8.3 format */</span>
<a name="l00819"></a>00819                     <span class="keywordflow">if</span> (!mem_cmp(dir, dj-&gt;fn, 11)) <span class="keywordflow">break</span>;
<a name="l00820"></a>00820                 }
<a name="l00821"></a>00821             }
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823 <span class="preprocessor">#else   </span><span class="comment">/* Non LFN configuration */</span>
<a name="l00824"></a>00824         <span class="keywordflow">if</span> (c != 0xE5 &amp;&amp; c != <span class="charliteral">&#39;.&#39;</span> &amp;&amp; !(a &amp; AM_VOL) &amp;&amp; !mem_cmp(dir, dj-&gt;fn, 11)) <span class="comment">/* Is it a valid entry? */</span>
<a name="l00825"></a>00825             <span class="keywordflow">break</span>;
<a name="l00826"></a>00826 <span class="preprocessor">#endif</span>
<a name="l00827"></a>00827 <span class="preprocessor"></span>        res = dir_next(dj, FALSE);              <span class="comment">/* Next entry */</span>
<a name="l00828"></a>00828     } <span class="keywordflow">while</span> (res == FR_OK);
<a name="l00829"></a>00829 
<a name="l00830"></a>00830     <span class="keywordflow">return</span> res;
<a name="l00831"></a>00831 }
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 
<a name="l00836"></a>00836 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00837"></a>00837 <span class="comment">/* Read an object from the directory                                     */</span>
<a name="l00838"></a>00838 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00839"></a>00839 <span class="preprocessor">#if _FS_MINIMIZE &lt;= 2</span>
<a name="l00840"></a>00840 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00841"></a>00841 FRESULT dir_read (
<a name="l00842"></a>00842     DIR *dj         <span class="comment">/* Pointer to the directory object to store read object name */</span>
<a name="l00843"></a>00843 )
<a name="l00844"></a>00844 {
<a name="l00845"></a>00845     FRESULT res;
<a name="l00846"></a>00846     BYTE a, c, ord, sum, *dir;
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 
<a name="l00849"></a>00849     ord = sum = 0xFF;
<a name="l00850"></a>00850     res = FR_NO_FILE;
<a name="l00851"></a>00851     <span class="keywordflow">while</span> (dj-&gt;sect) {
<a name="l00852"></a>00852         res = move_window(dj-&gt;fs, dj-&gt;sect);
<a name="l00853"></a>00853         <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00854"></a>00854         dir = dj-&gt;dir;                  <span class="comment">/* Ptr to the directory entry of current index */</span>
<a name="l00855"></a>00855         c = dir[DIR_Name];
<a name="l00856"></a>00856         <span class="keywordflow">if</span> (c == 0) { res = FR_NO_FILE; <span class="keywordflow">break</span>; }    <span class="comment">/* Reached to end of table */</span>
<a name="l00857"></a>00857         a = dir[DIR_Attr] &amp; AM_MASK;
<a name="l00858"></a>00858 <span class="preprocessor">#if _USE_LFN    </span><span class="comment">/* LFN configuration */</span>
<a name="l00859"></a>00859         <span class="keywordflow">if</span> (c == 0xE5 || c == <span class="charliteral">&#39;.&#39;</span> || ((a &amp; AM_VOL) &amp;&amp; a != AM_LFN)) {   <span class="comment">/* An entry without valid data */</span>
<a name="l00860"></a>00860             ord = 0xFF;
<a name="l00861"></a>00861         } <span class="keywordflow">else</span> {
<a name="l00862"></a>00862             <span class="keywordflow">if</span> (a == AM_LFN) {          <span class="comment">/* An LFN entry is found */</span>
<a name="l00863"></a>00863                 <span class="keywordflow">if</span> (c &amp; 0x40) {         <span class="comment">/* Is it start of LFN sequence? */</span>
<a name="l00864"></a>00864                     sum = dir[LDIR_Chksum];
<a name="l00865"></a>00865                     c &amp;= 0xBF; ord = c;
<a name="l00866"></a>00866                     dj-&gt;lfn_idx = dj-&gt;index;
<a name="l00867"></a>00867                 }
<a name="l00868"></a>00868                 <span class="comment">/* Check LFN validity and capture it */</span>
<a name="l00869"></a>00869                 ord = (c == ord &amp;&amp; sum == dir[LDIR_Chksum] &amp;&amp; pick_lfn(dj-&gt;lfn, dir)) ? ord - 1 : 0xFF;
<a name="l00870"></a>00870             } <span class="keywordflow">else</span> {                    <span class="comment">/* An SFN entry is found */</span>
<a name="l00871"></a>00871                 <span class="keywordflow">if</span> (ord || sum != sum_sfn(dir)) <span class="comment">/* Is there a valid LFN entry? */</span>
<a name="l00872"></a>00872                     dj-&gt;lfn_idx = 0xFFFF;       <span class="comment">/* No LFN. */</span>
<a name="l00873"></a>00873                 <span class="keywordflow">break</span>;
<a name="l00874"></a>00874             }
<a name="l00875"></a>00875         }
<a name="l00876"></a>00876 <span class="preprocessor">#else   </span><span class="comment">/* Non LFN configuration */</span>
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (c != 0xE5 &amp;&amp; c != <span class="charliteral">&#39;.&#39;</span> &amp;&amp; !(a &amp; AM_VOL)) <span class="comment">/* Is it a valid entry? */</span>
<a name="l00878"></a>00878             <span class="keywordflow">break</span>;
<a name="l00879"></a>00879 <span class="preprocessor">#endif</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span>        res = dir_next(dj, FALSE);              <span class="comment">/* Next entry */</span>
<a name="l00881"></a>00881         <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00882"></a>00882     }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     <span class="keywordflow">if</span> (res != FR_OK) dj-&gt;sect = 0;
<a name="l00885"></a>00885 
<a name="l00886"></a>00886     <span class="keywordflow">return</span> res;
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 <span class="preprocessor">#endif</span>
<a name="l00889"></a>00889 <span class="preprocessor"></span>
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 
<a name="l00892"></a>00892 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00893"></a>00893 <span class="comment">/* Register an object to the directory                                   */</span>
<a name="l00894"></a>00894 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00895"></a>00895 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00896"></a>00896 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00897"></a>00897 FRESULT dir_register (  <span class="comment">/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */</span>
<a name="l00898"></a>00898     DIR *dj             <span class="comment">/* Target directory with object name to be created */</span>
<a name="l00899"></a>00899 )
<a name="l00900"></a>00900 {
<a name="l00901"></a>00901     FRESULT res;
<a name="l00902"></a>00902     BYTE c, *dir;
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 <span class="preprocessor">#if _USE_LFN    </span><span class="comment">/* LFN configuration */</span>
<a name="l00905"></a>00905     WORD n, ne, is;
<a name="l00906"></a>00906     BYTE sn[12], *fn, sum;
<a name="l00907"></a>00907     WCHAR *lfn;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909     fn = dj-&gt;fn; lfn = dj-&gt;lfn;
<a name="l00910"></a>00910     mem_cpy(sn, fn, 12);
<a name="l00911"></a>00911     <span class="keywordflow">if</span> (sn[11] &amp; 1) {       <span class="comment">/* When LFN is out of 8.3 format, generate a numbered name */</span>
<a name="l00912"></a>00912         fn[11] = 0; dj-&gt;lfn = NULL;         <span class="comment">/* Find only SFN */</span>
<a name="l00913"></a>00913         <span class="keywordflow">for</span> (n = 1; n &lt; 100; n++) {
<a name="l00914"></a>00914             gen_numname(fn, sn, lfn, n);    <span class="comment">/* Generate a numbered name */</span>
<a name="l00915"></a>00915             res = dir_find(dj);             <span class="comment">/* Check if the name collides with existing SFN */</span>
<a name="l00916"></a>00916             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00917"></a>00917         }
<a name="l00918"></a>00918         <span class="keywordflow">if</span> (n == 100) <span class="keywordflow">return</span> FR_DENIED;     <span class="comment">/* Abort if too many collisions */</span>
<a name="l00919"></a>00919         <span class="keywordflow">if</span> (res != FR_NO_FILE) <span class="keywordflow">return</span> res;  <span class="comment">/* Abort if the result is other than &#39;not collided&#39; */</span>
<a name="l00920"></a>00920         fn[11] = sn[11]; dj-&gt;lfn = lfn;
<a name="l00921"></a>00921     }
<a name="l00922"></a>00922     <span class="keywordflow">if</span> (sn[11] &amp; 2) {       <span class="comment">/* When eliminate LFN, reserve only an SFN entry. */</span>
<a name="l00923"></a>00923         ne = 1;
<a name="l00924"></a>00924     } <span class="keywordflow">else</span> {                <span class="comment">/* Otherwise reserve an SFN + LFN entries. */</span>
<a name="l00925"></a>00925         <span class="keywordflow">for</span> (ne = 0; lfn[ne]; ne++) ;
<a name="l00926"></a>00926         ne = (ne + 25) / 13;
<a name="l00927"></a>00927     }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929     <span class="comment">/* Reserve contiguous entries */</span>
<a name="l00930"></a>00930     res = dir_seek(dj, 0);
<a name="l00931"></a>00931     <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">return</span> res;
<a name="l00932"></a>00932     n = is = 0;
<a name="l00933"></a>00933     <span class="keywordflow">do</span> {
<a name="l00934"></a>00934         res = move_window(dj-&gt;fs, dj-&gt;sect);
<a name="l00935"></a>00935         <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00936"></a>00936         c = *dj-&gt;dir;   <span class="comment">/* Check the entry status */</span>
<a name="l00937"></a>00937         <span class="keywordflow">if</span> (c == 0xE5 || c == 0) {  <span class="comment">/* Is it a blank entry? */</span>
<a name="l00938"></a>00938             <span class="keywordflow">if</span> (n == 0) is = dj-&gt;index; <span class="comment">/* First index of the contigulus entry */</span>
<a name="l00939"></a>00939             <span class="keywordflow">if</span> (++n == ne) <span class="keywordflow">break</span>;   <span class="comment">/* A contiguous entry that requiered count is found */</span>
<a name="l00940"></a>00940         } <span class="keywordflow">else</span> {
<a name="l00941"></a>00941             n = 0;                  <span class="comment">/* Not a blank entry. Restart to search */</span>
<a name="l00942"></a>00942         }
<a name="l00943"></a>00943         res = dir_next(dj, TRUE);   <span class="comment">/* Next entry with table streach */</span>
<a name="l00944"></a>00944     } <span class="keywordflow">while</span> (res == FR_OK);
<a name="l00945"></a>00945 
<a name="l00946"></a>00946     <span class="keywordflow">if</span> (res == FR_OK &amp;&amp; ne &gt; 1) {   <span class="comment">/* Initialize LFN entry if needed */</span>
<a name="l00947"></a>00947         res = dir_seek(dj, is);
<a name="l00948"></a>00948         <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l00949"></a>00949             sum = sum_sfn(dj-&gt;fn);  <span class="comment">/* Sum of the SFN tied to the LFN */</span>
<a name="l00950"></a>00950             ne--;
<a name="l00951"></a>00951             <span class="keywordflow">do</span> {                    <span class="comment">/* Store LFN entries in bottom first */</span>
<a name="l00952"></a>00952                 res = move_window(dj-&gt;fs, dj-&gt;sect);
<a name="l00953"></a>00953                 <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00954"></a>00954                 fit_lfn(dj-&gt;lfn, dj-&gt;dir, (BYTE)ne, sum);
<a name="l00955"></a>00955                 dj-&gt;fs-&gt;wflag = 1;
<a name="l00956"></a>00956                 res = dir_next(dj, FALSE);  <span class="comment">/* Next entry */</span>
<a name="l00957"></a>00957             } <span class="keywordflow">while</span> (res == FR_OK &amp;&amp; --ne);
<a name="l00958"></a>00958         }
<a name="l00959"></a>00959     }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="preprocessor">#else   </span><span class="comment">/* Non LFN configuration */</span>
<a name="l00962"></a>00962     res = dir_seek(dj, 0);
<a name="l00963"></a>00963     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l00964"></a>00964         <span class="keywordflow">do</span> {    <span class="comment">/* Find a blank entry for the SFN */</span>
<a name="l00965"></a>00965             res = move_window(dj-&gt;fs, dj-&gt;sect);
<a name="l00966"></a>00966             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l00967"></a>00967             c = *dj-&gt;dir;
<a name="l00968"></a>00968             <span class="keywordflow">if</span> (c == 0xE5 || c == 0) <span class="keywordflow">break</span>; <span class="comment">/* Is it a blank entry? */</span>
<a name="l00969"></a>00969             res = dir_next(dj, TRUE);       <span class="comment">/* Next entry with table streach */</span>
<a name="l00970"></a>00970         } <span class="keywordflow">while</span> (res == FR_OK);
<a name="l00971"></a>00971     }
<a name="l00972"></a>00972 <span class="preprocessor">#endif</span>
<a name="l00973"></a>00973 <span class="preprocessor"></span>
<a name="l00974"></a>00974     <span class="keywordflow">if</span> (res == FR_OK) {     <span class="comment">/* Initialize the SFN entry */</span>
<a name="l00975"></a>00975         res = move_window(dj-&gt;fs, dj-&gt;sect);
<a name="l00976"></a>00976         <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l00977"></a>00977             dir = dj-&gt;dir;
<a name="l00978"></a>00978             mem_set(dir, 0, 32);            <span class="comment">/* Clean the entry */</span>
<a name="l00979"></a>00979             mem_cpy(dir, dj-&gt;fn, 11);   <span class="comment">/* Put SFN */</span>
<a name="l00980"></a>00980             dir[DIR_NTres] = *(dj-&gt;fn+11) &amp; 0x18;   <span class="comment">/* Put NT flag */</span>
<a name="l00981"></a>00981             dj-&gt;fs-&gt;wflag = 1;
<a name="l00982"></a>00982         }
<a name="l00983"></a>00983     }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985     <span class="keywordflow">return</span> res;
<a name="l00986"></a>00986 }
<a name="l00987"></a>00987 <span class="preprocessor">#endif </span><span class="comment">/* !_FS_READONLY */</span>
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00993"></a>00993 <span class="comment">/* Remove an object from the directory                                   */</span>
<a name="l00994"></a>00994 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l00995"></a>00995 <span class="preprocessor">#if !_FS_READONLY &amp;&amp; !_FS_MINIMIZE</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l00997"></a>00997 FRESULT dir_remove (    <span class="comment">/* FR_OK: Successful, FR_DISK_ERR: A disk error */</span>
<a name="l00998"></a>00998     DIR *dj             <span class="comment">/* Directory object pointing the entry to be removed */</span>
<a name="l00999"></a>00999 )
<a name="l01000"></a>01000 {
<a name="l01001"></a>01001     FRESULT res;
<a name="l01002"></a>01002 
<a name="l01003"></a>01003 <span class="preprocessor">#if _USE_LFN    </span><span class="comment">/* LFN configuration */</span>
<a name="l01004"></a>01004     WORD i;
<a name="l01005"></a>01005 
<a name="l01006"></a>01006     i = dj-&gt;index;  <span class="comment">/* SFN index */</span>
<a name="l01007"></a>01007     res = dir_seek(dj, (WORD)((dj-&gt;lfn_idx == 0xFFFF) ? i : dj-&gt;lfn_idx));  <span class="comment">/* Goto the SFN or top of the LFN entries */</span>
<a name="l01008"></a>01008     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l01009"></a>01009         <span class="keywordflow">do</span> {
<a name="l01010"></a>01010             res = move_window(dj-&gt;fs, dj-&gt;sect);
<a name="l01011"></a>01011             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l01012"></a>01012             *dj-&gt;dir = 0xE5;                <span class="comment">/* Mark the entry &quot;deleted&quot; */</span>
<a name="l01013"></a>01013             dj-&gt;fs-&gt;wflag = 1;
<a name="l01014"></a>01014             <span class="keywordflow">if</span> (dj-&gt;index &gt;= i) <span class="keywordflow">break</span>;      <span class="comment">/* When SFN is deleted, all entries of the object is deleted. */</span>
<a name="l01015"></a>01015             res = dir_next(dj, FALSE);      <span class="comment">/* Next entry */</span>
<a name="l01016"></a>01016         } <span class="keywordflow">while</span> (res == FR_OK);
<a name="l01017"></a>01017         <span class="keywordflow">if</span> (res == FR_NO_FILE) res = FR_INT_ERR;
<a name="l01018"></a>01018     }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 <span class="preprocessor">#else           </span><span class="comment">/* Non LFN configuration */</span>
<a name="l01021"></a>01021     res = dir_seek(dj, dj-&gt;index);
<a name="l01022"></a>01022     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l01023"></a>01023         res = move_window(dj-&gt;fs, dj-&gt;sect);
<a name="l01024"></a>01024         <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l01025"></a>01025             *dj-&gt;dir = 0xE5;                <span class="comment">/* Mark the entry &quot;deleted&quot; */</span>
<a name="l01026"></a>01026             dj-&gt;fs-&gt;wflag = 1;
<a name="l01027"></a>01027         }
<a name="l01028"></a>01028     }
<a name="l01029"></a>01029 <span class="preprocessor">#endif</span>
<a name="l01030"></a>01030 <span class="preprocessor"></span>
<a name="l01031"></a>01031     <span class="keywordflow">return</span> res;
<a name="l01032"></a>01032 }
<a name="l01033"></a>01033 <span class="preprocessor">#endif </span><span class="comment">/* !_FS_READONLY */</span>
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 
<a name="l01038"></a>01038 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01039"></a>01039 <span class="comment">/* Pick a segment and create the object name in directory form           */</span>
<a name="l01040"></a>01040 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01041"></a>01041 
<a name="l01042"></a>01042 <span class="keyword">static</span>
<a name="l01043"></a>01043 FRESULT create_name (
<a name="l01044"></a>01044     DIR *dj,            <span class="comment">/* Pointer to the directory object */</span>
<a name="l01045"></a>01045     <span class="keyword">const</span> <span class="keywordtype">char</span> **path   <span class="comment">/* Pointer to pointer to the segment in the path string */</span>
<a name="l01046"></a>01046 )
<a name="l01047"></a>01047 {
<a name="l01048"></a>01048 <span class="preprocessor">#if _USE_LFN</span>
<a name="l01049"></a>01049 <span class="preprocessor"></span>    BYTE c, b, cf, *sfn;
<a name="l01050"></a>01050     WCHAR w, *lfn;
<a name="l01051"></a>01051     <span class="keywordtype">int</span> i, ni, si, di;
<a name="l01052"></a>01052     <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054     <span class="comment">/* Create LFN in Unicode */</span>
<a name="l01055"></a>01055     si = di = 0;
<a name="l01056"></a>01056     p = *path;
<a name="l01057"></a>01057     lfn = dj-&gt;lfn;
<a name="l01058"></a>01058     <span class="keywordflow">for</span> (;;) {
<a name="l01059"></a>01059         w = (BYTE)p[si++];              <span class="comment">/* Get a character */</span>
<a name="l01060"></a>01060         <span class="keywordflow">if</span> (w &lt; <span class="charliteral">&#39; &#39;</span> || w == <span class="charliteral">&#39;/&#39;</span> || w == <span class="charliteral">&#39;\\&#39;</span>) <span class="keywordflow">break</span>;    <span class="comment">/* Break on end of segment */</span>
<a name="l01061"></a>01061         <span class="keywordflow">if</span> (IsDBCS1(w)) {               <span class="comment">/* If it is DBC 1st byte */</span>
<a name="l01062"></a>01062             c = p[si++];                <span class="comment">/* Get 2nd byte */</span>
<a name="l01063"></a>01063             <span class="keywordflow">if</span> (!IsDBCS2(c))            <span class="comment">/* Reject invalid DBC */</span>
<a name="l01064"></a>01064                 <span class="keywordflow">return</span> FR_INVALID_NAME;
<a name="l01065"></a>01065             w = (w &lt;&lt; 8) + c;
<a name="l01066"></a>01066         } <span class="keywordflow">else</span> {
<a name="l01067"></a>01067             <span class="keywordflow">if</span> (chk_chr(<span class="stringliteral">&quot;\&quot;*:&lt;&gt;\?|\x7F&quot;</span>, w))    <span class="comment">/* Reject unallowable chars for LFN */</span>
<a name="l01068"></a>01068                 <span class="keywordflow">return</span> FR_INVALID_NAME;
<a name="l01069"></a>01069         }
<a name="l01070"></a>01070         w = ff_convert(w, 1);           <span class="comment">/* Convert OEM to Unicode, store it */</span>
<a name="l01071"></a>01071         <span class="keywordflow">if</span> (!w || di &gt;= _MAX_LFN)       <span class="comment">/* Reject invalid code or too long name */</span>
<a name="l01072"></a>01072             <span class="keywordflow">return</span> FR_INVALID_NAME;
<a name="l01073"></a>01073         lfn[di++] = w;
<a name="l01074"></a>01074     }
<a name="l01075"></a>01075     *path = &amp;p[si];                     <span class="comment">/* Rerurn pointer to the next segment */</span>
<a name="l01076"></a>01076     cf = (w &lt; <span class="charliteral">&#39; &#39;</span>) ? 4 : 0;             <span class="comment">/* Set last segment flag if end of path */</span>
<a name="l01077"></a>01077 
<a name="l01078"></a>01078     <span class="keywordflow">while</span> (di) {                        <span class="comment">/* Strip trailing spaces and dots */</span>
<a name="l01079"></a>01079         w = lfn[di - 1];
<a name="l01080"></a>01080         <span class="keywordflow">if</span> (w != <span class="charliteral">&#39; &#39;</span> &amp;&amp; w != <span class="charliteral">&#39;.&#39;</span>) <span class="keywordflow">break</span>;
<a name="l01081"></a>01081         di--;
<a name="l01082"></a>01082     }
<a name="l01083"></a>01083     <span class="keywordflow">if</span> (!di) <span class="keywordflow">return</span> FR_INVALID_NAME;    <span class="comment">/* Reject null string */</span>
<a name="l01084"></a>01084 
<a name="l01085"></a>01085     lfn[di] = 0;                        <span class="comment">/* LFN is created */</span>
<a name="l01086"></a>01086 
<a name="l01087"></a>01087     <span class="comment">/* Create SFN in directory form */</span>
<a name="l01088"></a>01088     sfn = dj-&gt;fn;
<a name="l01089"></a>01089     mem_set(sfn, <span class="charliteral">&#39; &#39;</span>, 11);
<a name="l01090"></a>01090     <span class="keywordflow">for</span> (si = 0; lfn[si] == <span class="charliteral">&#39; &#39;</span> || lfn[si] == <span class="charliteral">&#39;.&#39;</span>; si++) ;  <span class="comment">/* Strip leading spaces and dots */</span>
<a name="l01091"></a>01091     <span class="keywordflow">if</span> (si) cf |= 1;
<a name="l01092"></a>01092     <span class="keywordflow">while</span> (di &amp;&amp; lfn[di - 1] != <span class="charliteral">&#39;.&#39;</span>) di--;  <span class="comment">/* Find extension (di&lt;=si: no extension) */</span>
<a name="l01093"></a>01093 
<a name="l01094"></a>01094     b = i = 0; ni = 8;
<a name="l01095"></a>01095     <span class="keywordflow">for</span> (;;) {
<a name="l01096"></a>01096         w = lfn[si++];                  <span class="comment">/* Get an LFN char */</span>
<a name="l01097"></a>01097         <span class="keywordflow">if</span> (w == 0) <span class="keywordflow">break</span>;              <span class="comment">/* Break when enf of the LFN */</span>
<a name="l01098"></a>01098         <span class="keywordflow">if</span> (w == <span class="charliteral">&#39; &#39;</span> || (w == <span class="charliteral">&#39;.&#39;</span> &amp;&amp; si != di)) {   <span class="comment">/* Remove spaces and dots */</span>
<a name="l01099"></a>01099             cf |= 1; <span class="keywordflow">continue</span>;
<a name="l01100"></a>01100         }
<a name="l01101"></a>01101         <span class="keywordflow">if</span> (i &gt;= ni || si == di) {      <span class="comment">/* Here is extension or end of SFN */</span>
<a name="l01102"></a>01102             <span class="keywordflow">if</span> (ni == 11) {             <span class="comment">/* Extension is longer than 3 bytes */</span>
<a name="l01103"></a>01103                 cf |= 1; <span class="keywordflow">break</span>;
<a name="l01104"></a>01104             }
<a name="l01105"></a>01105             <span class="keywordflow">if</span> (si != di) cf |= 1;      <span class="comment">/* File name is longer than 8 bytes */</span>
<a name="l01106"></a>01106             <span class="keywordflow">if</span> (si &gt; di) <span class="keywordflow">break</span>;         <span class="comment">/* No extension */</span>
<a name="l01107"></a>01107             si = di; i = 8; ni = 11;    <span class="comment">/* Enter extension section */</span>
<a name="l01108"></a>01108             b &lt;&lt;= 2; <span class="keywordflow">continue</span>;
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110         w = ff_convert(w, 0);           <span class="comment">/* Unicode -&gt; OEM code */</span>
<a name="l01111"></a>01111         <span class="keywordflow">if</span> (w &gt;= 0x80) cf |= 0x20;      <span class="comment">/* If there is any extended char, force create an LFN */</span>
<a name="l01112"></a>01112         <span class="keywordflow">if</span> (w &gt;= 0x100) {               <span class="comment">/* Double byte char */</span>
<a name="l01113"></a>01113             <span class="keywordflow">if</span> (i &gt;= ni - 1) {
<a name="l01114"></a>01114                 cf |= 1; i = ni; <span class="keywordflow">continue</span>;
<a name="l01115"></a>01115             }
<a name="l01116"></a>01116             sfn[i++] = (BYTE)(w &gt;&gt; 8);
<a name="l01117"></a>01117         } <span class="keywordflow">else</span> {                        <span class="comment">/* Single byte char */</span>
<a name="l01118"></a>01118             <span class="keywordflow">if</span> (chk_chr(<span class="stringliteral">&quot;+,;[=]&quot;</span>, w)) { <span class="comment">/* Replace unallowable chars for SFN */</span>
<a name="l01119"></a>01119                 w = <span class="charliteral">&#39;_&#39;</span>; cf |= 1;
<a name="l01120"></a>01120             } <span class="keywordflow">else</span> {
<a name="l01121"></a>01121                 <span class="keywordflow">if</span> (IsUpper(w)) {       <span class="comment">/* Large capital */</span>
<a name="l01122"></a>01122                     b |= 2;
<a name="l01123"></a>01123                 } <span class="keywordflow">else</span> {
<a name="l01124"></a>01124                     <span class="keywordflow">if</span> (IsLower(w)) {   <span class="comment">/* Small capital */</span>
<a name="l01125"></a>01125                         b |= 1; w -= 0x20;
<a name="l01126"></a>01126                     }
<a name="l01127"></a>01127                 }
<a name="l01128"></a>01128             }
<a name="l01129"></a>01129         }
<a name="l01130"></a>01130         sfn[i++] = (BYTE)w;
<a name="l01131"></a>01131     }
<a name="l01132"></a>01132     <span class="keywordflow">if</span> (sfn[0] == 0xE5) sfn[0] = 0x05;  <span class="comment">/* When first char collides with 0xE5, replace it with 0x05 */</span>
<a name="l01133"></a>01133 
<a name="l01134"></a>01134     <span class="keywordflow">if</span> (ni == 8) b &lt;&lt;= 2;
<a name="l01135"></a>01135     <span class="keywordflow">if</span> ((cf &amp; 0x21) == 0) { <span class="comment">/* When LFN is in 8.3 format without extended char, NT flags are created */</span>
<a name="l01136"></a>01136         <span class="keywordflow">if</span> ((b &amp; 0x03) == 0x01) cf |= 0x10; <span class="comment">/* NT flag (Extension has only small capital) */</span>
<a name="l01137"></a>01137         <span class="keywordflow">if</span> ((b &amp; 0x0C) == 0x04) cf |= 0x08; <span class="comment">/* NT flag (Filename has only small capital) */</span>
<a name="l01138"></a>01138         <span class="keywordflow">if</span> ((b &amp; 0x0C) != 0x0C &amp;&amp; (b &amp; 0x03) != 0x03) cf |= 2;  <span class="comment">/* Eliminate LFN when non composite capitals */</span>
<a name="l01139"></a>01139     }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     sfn[11] = cf;       <span class="comment">/* SFN is created */</span>
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 <span class="preprocessor">#else</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span>    BYTE c, d, b, *sfn;
<a name="l01145"></a>01145     <span class="keywordtype">int</span> ni, si, i;
<a name="l01146"></a>01146     <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
<a name="l01147"></a>01147 
<a name="l01148"></a>01148     <span class="comment">/* Create file name in directory form */</span>
<a name="l01149"></a>01149     sfn = dj-&gt;fn;
<a name="l01150"></a>01150     mem_set(sfn, <span class="charliteral">&#39; &#39;</span>, 11);
<a name="l01151"></a>01151     si = i = b = 0; ni = 8;
<a name="l01152"></a>01152     p = *path;
<a name="l01153"></a>01153     <span class="keywordflow">for</span> (;;) {
<a name="l01154"></a>01154         c = p[si++];
<a name="l01155"></a>01155         <span class="keywordflow">if</span> (c &lt; <span class="charliteral">&#39; &#39;</span> || c == <span class="charliteral">&#39;/&#39;</span> || c == <span class="charliteral">&#39;\\&#39;</span>) <span class="keywordflow">break</span>;    <span class="comment">/* Break on end of segment */</span>
<a name="l01156"></a>01156         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;.&#39;</span> || i &gt;= ni) {
<a name="l01157"></a>01157             <span class="keywordflow">if</span> (ni != 8 || c != <span class="charliteral">&#39;.&#39;</span>) <span class="keywordflow">return</span> FR_INVALID_NAME;
<a name="l01158"></a>01158             i = 8; ni = 11;
<a name="l01159"></a>01159             b &lt;&lt;= 2; <span class="keywordflow">continue</span>;
<a name="l01160"></a>01160         }
<a name="l01161"></a>01161         <span class="keywordflow">if</span> (c &gt;= 0x80) b |= 3;          <span class="comment">/* If there is any extended char, eliminate NT flag */</span>
<a name="l01162"></a>01162         <span class="keywordflow">if</span> (IsDBCS1(c)) {               <span class="comment">/* If it is DBC 1st byte */</span>
<a name="l01163"></a>01163             d = p[si++];                <span class="comment">/* Get 2nd byte */</span>
<a name="l01164"></a>01164             <span class="keywordflow">if</span> (!IsDBCS2(d) || i &gt;= ni - 1) <span class="comment">/* Reject invalid DBC */</span>
<a name="l01165"></a>01165                 <span class="keywordflow">return</span> FR_INVALID_NAME;
<a name="l01166"></a>01166             sfn[i++] = c;
<a name="l01167"></a>01167             sfn[i++] = d;
<a name="l01168"></a>01168         } <span class="keywordflow">else</span> {
<a name="l01169"></a>01169             <span class="keywordflow">if</span> (chk_chr(<span class="stringliteral">&quot; +,;[=]\&quot;*:&lt;&gt;\?|\x7F&quot;</span>, c)) <span class="comment">/* Reject unallowable chrs for SFN */</span>
<a name="l01170"></a>01170                 <span class="keywordflow">return</span> FR_INVALID_NAME;
<a name="l01171"></a>01171             <span class="keywordflow">if</span> (IsUpper(c)) {
<a name="l01172"></a>01172                 b |= 2;
<a name="l01173"></a>01173             } <span class="keywordflow">else</span> {
<a name="l01174"></a>01174                 <span class="keywordflow">if</span> (IsLower(c)) {
<a name="l01175"></a>01175                     b |= 1; c -= 0x20;
<a name="l01176"></a>01176                 }
<a name="l01177"></a>01177             }
<a name="l01178"></a>01178             sfn[i++] = c;
<a name="l01179"></a>01179         }
<a name="l01180"></a>01180     }
<a name="l01181"></a>01181     *path = &amp;p[si];                     <span class="comment">/* Rerurn pointer to the next segment */</span>
<a name="l01182"></a>01182     c = (c &lt; <span class="charliteral">&#39; &#39;</span>) ? 4 : 0;              <span class="comment">/* Set last segment flag if end of path */</span>
<a name="l01183"></a>01183 
<a name="l01184"></a>01184     <span class="keywordflow">if</span> (!i) <span class="keywordflow">return</span> FR_INVALID_NAME;     <span class="comment">/* Reject null string */</span>
<a name="l01185"></a>01185     <span class="keywordflow">if</span> (sfn[0] == 0xE5) sfn[0] = 0x05;  <span class="comment">/* When first char collides with 0xE5, replace it with 0x05 */</span>
<a name="l01186"></a>01186 
<a name="l01187"></a>01187     <span class="keywordflow">if</span> (ni == 8) b &lt;&lt;= 2;
<a name="l01188"></a>01188     <span class="keywordflow">if</span> ((b &amp; 0x03) == 0x01) c |= 0x10;  <span class="comment">/* NT flag (Extension has only small capital) */</span>
<a name="l01189"></a>01189     <span class="keywordflow">if</span> ((b &amp; 0x0C) == 0x04) c |= 0x08;  <span class="comment">/* NT flag (Filename has only small capital) */</span>
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     sfn[11] = c;        <span class="comment">/* Store NT flag, File name is created */</span>
<a name="l01192"></a>01192 <span class="preprocessor">#endif</span>
<a name="l01193"></a>01193 <span class="preprocessor"></span>
<a name="l01194"></a>01194     <span class="keywordflow">return</span> FR_OK;
<a name="l01195"></a>01195 }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 
<a name="l01198"></a>01198 
<a name="l01199"></a>01199 
<a name="l01200"></a>01200 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01201"></a>01201 <span class="comment">/* Get file information from directory entry                             */</span>
<a name="l01202"></a>01202 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01203"></a>01203 <span class="preprocessor">#if _FS_MINIMIZE &lt;= 1</span>
<a name="l01204"></a>01204 <span class="preprocessor"></span><span class="keyword">static</span>
<a name="l01205"></a>01205 <span class="keywordtype">void</span> get_fileinfo (     <span class="comment">/* No return code */</span>
<a name="l01206"></a>01206     DIR *dj,            <span class="comment">/* Pointer to the directory object */</span>
<a name="l01207"></a>01207     FILINFO *fno        <span class="comment">/* Pointer to store the file information */</span>
<a name="l01208"></a>01208 )
<a name="l01209"></a>01209 {
<a name="l01210"></a>01210     <span class="keywordtype">int</span> i;
<a name="l01211"></a>01211     BYTE c, nt, *dir;
<a name="l01212"></a>01212     <span class="keywordtype">char</span> *p;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214 
<a name="l01215"></a>01215     p = fno-&gt;fname;
<a name="l01216"></a>01216     <span class="keywordflow">if</span> (dj-&gt;sect) {
<a name="l01217"></a>01217         dir = dj-&gt;dir;
<a name="l01218"></a>01218         nt = dir[DIR_NTres];        <span class="comment">/* NT flag */</span>
<a name="l01219"></a>01219         <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {   <span class="comment">/* Copy file name body */</span>
<a name="l01220"></a>01220             c = dir[i];
<a name="l01221"></a>01221             <span class="keywordflow">if</span> (c == <span class="charliteral">&#39; &#39;</span>) <span class="keywordflow">break</span>;
<a name="l01222"></a>01222             <span class="keywordflow">if</span> (c == 0x05) c = 0xE5;
<a name="l01223"></a>01223             <span class="keywordflow">if</span> ((nt &amp; 0x08) &amp;&amp; IsUpper(c)) c += 0x20;
<a name="l01224"></a>01224             *p++ = c;
<a name="l01225"></a>01225         }
<a name="l01226"></a>01226         <span class="keywordflow">if</span> (dir[8] != <span class="charliteral">&#39; &#39;</span>) {        <span class="comment">/* Copy file name extension */</span>
<a name="l01227"></a>01227             *p++ = <span class="charliteral">&#39;.&#39;</span>;
<a name="l01228"></a>01228             <span class="keywordflow">for</span> (i = 8; i &lt; 11; i++) {
<a name="l01229"></a>01229                 c = dir[i];
<a name="l01230"></a>01230                 <span class="keywordflow">if</span> (c == <span class="charliteral">&#39; &#39;</span>) <span class="keywordflow">break</span>;
<a name="l01231"></a>01231                 <span class="keywordflow">if</span> ((nt &amp; 0x10) &amp;&amp; IsUpper(c)) c += 0x20;
<a name="l01232"></a>01232                 *p++ = c;
<a name="l01233"></a>01233             }
<a name="l01234"></a>01234         }
<a name="l01235"></a>01235         fno-&gt;fattrib = dir[DIR_Attr];               <span class="comment">/* Attribute */</span>
<a name="l01236"></a>01236         fno-&gt;fsize = LD_DWORD(dir+DIR_FileSize);    <span class="comment">/* Size */</span>
<a name="l01237"></a>01237         fno-&gt;fdate = LD_WORD(dir+DIR_WrtDate);      <span class="comment">/* Date */</span>
<a name="l01238"></a>01238         fno-&gt;ftime = LD_WORD(dir+DIR_WrtTime);      <span class="comment">/* Time */</span>
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240     *p = 0;
<a name="l01241"></a>01241 
<a name="l01242"></a>01242 <span class="preprocessor">#if _USE_LFN</span>
<a name="l01243"></a>01243 <span class="preprocessor"></span>    p = fno-&gt;lfname;
<a name="l01244"></a>01244     <span class="keywordflow">if</span> (p) {
<a name="l01245"></a>01245         WCHAR wchr, *lfn;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247         i = 0;
<a name="l01248"></a>01248         <span class="keywordflow">if</span> (dj-&gt;sect &amp;&amp; dj-&gt;lfn_idx != 0xFFFF) {<span class="comment">/* Get LFN if available */</span>
<a name="l01249"></a>01249             lfn = dj-&gt;lfn;
<a name="l01250"></a>01250             <span class="keywordflow">while</span> ((wchr = *lfn++) != 0) {      <span class="comment">/* Get an LFN char */</span>
<a name="l01251"></a>01251                 wchr = ff_convert(wchr, 0);     <span class="comment">/* Unicode -&gt; OEM code */</span>
<a name="l01252"></a>01252                 <span class="keywordflow">if</span> (!wchr) { i = 0; <span class="keywordflow">break</span>; }    <span class="comment">/* Conversion error, no LFN */</span>
<a name="l01253"></a>01253                 <span class="keywordflow">if</span> (_DF1S &amp;&amp; wchr &gt;= 0x100)     <span class="comment">/* Put 1st byte if it is a DBC */</span>
<a name="l01254"></a>01254                     p[i++] = (char)(wchr &gt;&gt; 8);
<a name="l01255"></a>01255                 p[i++] = (char)wchr;
<a name="l01256"></a>01256                 <span class="keywordflow">if</span> (i &gt;= fno-&gt;lfsize) { i = 0; <span class="keywordflow">break</span>; } <span class="comment">/* Buffer overrun, no LFN */</span>
<a name="l01257"></a>01257             }
<a name="l01258"></a>01258         }
<a name="l01259"></a>01259         p[i] = 0;   <span class="comment">/* Terminator */</span>
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261 <span class="preprocessor">#endif</span>
<a name="l01262"></a>01262 <span class="preprocessor"></span>}
<a name="l01263"></a>01263 <span class="preprocessor">#endif </span><span class="comment">/* _FS_MINIMIZE &lt;= 1 */</span>
<a name="l01264"></a>01264 
<a name="l01265"></a>01265 
<a name="l01266"></a>01266 
<a name="l01267"></a>01267 
<a name="l01268"></a>01268 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01269"></a>01269 <span class="comment">/* Follow a file path                                                    */</span>
<a name="l01270"></a>01270 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 <span class="keyword">static</span>
<a name="l01273"></a>01273 FRESULT follow_path (   <span class="comment">/* FR_OK(0): successful, !=0: error code */</span>
<a name="l01274"></a>01274     DIR *dj,            <span class="comment">/* Directory object to return last directory and found object */</span>
<a name="l01275"></a>01275     <span class="keyword">const</span> <span class="keywordtype">char</span> *path    <span class="comment">/* Full-path string to find a file or directory */</span>
<a name="l01276"></a>01276 )
<a name="l01277"></a>01277 {
<a name="l01278"></a>01278     FRESULT res;
<a name="l01279"></a>01279     BYTE *dir, last;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     <span class="keywordflow">if</span> (*path == <span class="charliteral">&#39;/&#39;</span> || *path == <span class="charliteral">&#39;\\&#39;</span> ) path++; <span class="comment">/* Strip heading separator */</span>
<a name="l01283"></a>01283 
<a name="l01284"></a>01284     dj-&gt;sclust =                        <span class="comment">/* Set start directory (root dir) */</span>
<a name="l01285"></a>01285         (dj-&gt;fs-&gt;fs_type == FS_FAT32) ? dj-&gt;fs-&gt;dirbase : 0;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287     if ((BYTE)*path &lt; <span class="charliteral">&#39; &#39;</span>) {            <span class="comment">/* Null path means the root directory */</span>
<a name="l01288"></a>01288         res = dir_seek(dj, 0);
<a name="l01289"></a>01289         dj-&gt;dir = NULL;
<a name="l01290"></a>01290 
<a name="l01291"></a>01291     } <span class="keywordflow">else</span> {                            <span class="comment">/* Follow path */</span>
<a name="l01292"></a>01292         <span class="keywordflow">for</span> (;;) {
<a name="l01293"></a>01293             res = create_name(dj, &amp;path);   <span class="comment">/* Get a segment */</span>
<a name="l01294"></a>01294             <span class="keywordflow">if</span> (res != FR_OK) <span class="keywordflow">break</span>;
<a name="l01295"></a>01295             res = dir_find(dj);             <span class="comment">/* Find it */</span>
<a name="l01296"></a>01296             last = *(dj-&gt;fn+11) &amp; 4;
<a name="l01297"></a>01297             <span class="keywordflow">if</span> (res != FR_OK) {             <span class="comment">/* Could not find the object */</span>
<a name="l01298"></a>01298                 <span class="keywordflow">if</span> (res == FR_NO_FILE &amp;&amp; !last)
<a name="l01299"></a>01299                     res = FR_NO_PATH;
<a name="l01300"></a>01300                 <span class="keywordflow">break</span>;
<a name="l01301"></a>01301             }
<a name="l01302"></a>01302             <span class="keywordflow">if</span> (last) <span class="keywordflow">break</span>;                <span class="comment">/* Last segment match. Function completed. */</span>
<a name="l01303"></a>01303             dir = dj-&gt;dir;                  <span class="comment">/* There is next segment. Follow the sub directory */</span>
<a name="l01304"></a>01304             <span class="keywordflow">if</span> (!(dir[DIR_Attr] &amp; AM_DIR)) { <span class="comment">/* Cannot follow because it is a file */</span>
<a name="l01305"></a>01305                 res = FR_NO_PATH; <span class="keywordflow">break</span>;
<a name="l01306"></a>01306             }
<a name="l01307"></a>01307             dj-&gt;sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
<a name="l01308"></a>01308         }
<a name="l01309"></a>01309     }
<a name="l01310"></a>01310 
<a name="l01311"></a>01311     <span class="keywordflow">return</span> res;
<a name="l01312"></a>01312 }
<a name="l01313"></a>01313 
<a name="l01314"></a>01314 
<a name="l01315"></a>01315 
<a name="l01316"></a>01316 
<a name="l01317"></a>01317 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01318"></a>01318 <span class="comment">/* Load boot record and check if it is an FAT boot record                */</span>
<a name="l01319"></a>01319 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01320"></a>01320 
<a name="l01321"></a>01321 <span class="keyword">static</span>
<a name="l01322"></a>01322 BYTE check_fs ( <span class="comment">/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */</span>
<a name="l01323"></a>01323     FATFS *fs,  <span class="comment">/* File system object */</span>
<a name="l01324"></a>01324     DWORD sect  <span class="comment">/* Sector# (lba) to check if it is an FAT boot record or not */</span>
<a name="l01325"></a>01325 )
<a name="l01326"></a>01326 {
<a name="l01327"></a>01327     <span class="keywordflow">if</span> (disk_read(fs-&gt;drive, fs-&gt;win, sect, 1) != RES_OK)   <span class="comment">/* Load boot record */</span>
<a name="l01328"></a>01328         <span class="keywordflow">return</span> 3;
<a name="l01329"></a>01329     <span class="keywordflow">if</span> (LD_WORD(&amp;fs-&gt;win[BS_55AA]) != 0xAA55)               <span class="comment">/* Check record signature (always placed at offset 510 even if the sector size is &gt;512) */</span>
<a name="l01330"></a>01330         <span class="keywordflow">return</span> 2;
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     <span class="keywordflow">if</span> (!mem_cmp(&amp;fs-&gt;win[BS_FilSysType], <span class="stringliteral">&quot;FAT&quot;</span>, 3))        <span class="comment">/* Check FAT signature */</span>
<a name="l01333"></a>01333         <span class="keywordflow">return</span> 0;
<a name="l01334"></a>01334     <span class="keywordflow">if</span> (!mem_cmp(&amp;fs-&gt;win[BS_FilSysType32], <span class="stringliteral">&quot;FAT32&quot;</span>, 5) &amp;&amp; !(fs-&gt;win[BPB_ExtFlags] &amp; 0x80))
<a name="l01335"></a>01335         <span class="keywordflow">return</span> 0;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     <span class="keywordflow">return</span> 1;
<a name="l01338"></a>01338 }
<a name="l01339"></a>01339 
<a name="l01340"></a>01340 
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 
<a name="l01343"></a>01343 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01344"></a>01344 <span class="comment">/* Make sure that the file system is valid                               */</span>
<a name="l01345"></a>01345 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="keyword">static</span>
<a name="l01348"></a>01348 FRESULT auto_mount (    <span class="comment">/* FR_OK(0): successful, !=0: any error occured */</span>
<a name="l01349"></a>01349     <span class="keyword">const</span> <span class="keywordtype">char</span> **path,  <span class="comment">/* Pointer to pointer to the path name (drive number) */</span>
<a name="l01350"></a>01350     FATFS **rfs,        <span class="comment">/* Pointer to pointer to the found file system object */</span>
<a name="l01351"></a>01351     BYTE chk_wp         <span class="comment">/* !=0: Check media write protection for write access */</span>
<a name="l01352"></a>01352 )
<a name="l01353"></a>01353 {
<a name="l01354"></a>01354     FRESULT res;
<a name="l01355"></a>01355     BYTE vol, fmt, *tbl;
<a name="l01356"></a>01356     DSTATUS stat;
<a name="l01357"></a>01357     DWORD bsect, fsize, tsect, mclst;
<a name="l01358"></a>01358     <span class="keyword">const</span> <span class="keywordtype">char</span> *p = *path;
<a name="l01359"></a>01359     FATFS *fs;
<a name="l01360"></a>01360 
<a name="l01361"></a>01361 
<a name="l01362"></a>01362     <span class="comment">/* Get logical drive number from the path name */</span>
<a name="l01363"></a>01363     vol = p[0] - <span class="charliteral">&#39;0&#39;</span>;           <span class="comment">/* Is there a drive number? */</span>
<a name="l01364"></a>01364     <span class="keywordflow">if</span> (vol &lt;= 9 &amp;&amp; p[1] == <span class="charliteral">&#39;:&#39;</span>) {
<a name="l01365"></a>01365         p += 2;                 <span class="comment">/* Found a drive number, get and strip it */</span>
<a name="l01366"></a>01366         *path = p;              <span class="comment">/* Return pointer to the path name */</span>
<a name="l01367"></a>01367     } <span class="keywordflow">else</span> {
<a name="l01368"></a>01368         vol = 0;                <span class="comment">/* No drive number is given, use drive number 0 as default */</span>
<a name="l01369"></a>01369     }
<a name="l01370"></a>01370 
<a name="l01371"></a>01371     <span class="comment">/* Check if the logical drive number is valid or not */</span>
<a name="l01372"></a>01372     <span class="keywordflow">if</span> (vol &gt;= _DRIVES) <span class="keywordflow">return</span> FR_INVALID_DRIVE;    <span class="comment">/* Is the drive number valid? */</span>
<a name="l01373"></a>01373     *rfs = fs = FatFs[vol];                 <span class="comment">/* Returen pointer to the corresponding file system object */</span>
<a name="l01374"></a>01374     <span class="keywordflow">if</span> (!fs) <span class="keywordflow">return</span> FR_NOT_ENABLED;         <span class="comment">/* Is the file system object registered? */</span>
<a name="l01375"></a>01375 
<a name="l01376"></a>01376     ENTER_FF(fs);               <span class="comment">/* Lock file system */</span>
<a name="l01377"></a>01377 
<a name="l01378"></a>01378     <span class="keywordflow">if</span> (fs-&gt;fs_type) {                      <span class="comment">/* If the logical drive has been mounted */</span>
<a name="l01379"></a>01379         stat = disk_status(fs-&gt;drive);
<a name="l01380"></a>01380         <span class="keywordflow">if</span> (!(stat &amp; STA_NOINIT)) {         <span class="comment">/* and physical drive is kept initialized (has not been changed), */</span>
<a name="l01381"></a>01381 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01382"></a>01382 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (chk_wp &amp;&amp; (stat &amp; STA_PROTECT)) <span class="comment">/* Check write protection if needed */</span>
<a name="l01383"></a>01383                 <span class="keywordflow">return</span> FR_WRITE_PROTECTED;
<a name="l01384"></a>01384 <span class="preprocessor">#endif</span>
<a name="l01385"></a>01385 <span class="preprocessor"></span>            <span class="keywordflow">return</span> FR_OK;                   <span class="comment">/* The file system object is valid */</span>
<a name="l01386"></a>01386         }
<a name="l01387"></a>01387     }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389     <span class="comment">/* The logical drive must be re-mounted. Following code attempts to mount the volume */</span>
<a name="l01390"></a>01390 
<a name="l01391"></a>01391     fs-&gt;fs_type = 0;                    <span class="comment">/* Clear the file system object */</span>
<a name="l01392"></a>01392     fs-&gt;drive = LD2PD(vol);             <span class="comment">/* Bind the logical drive and a physical drive */</span>
<a name="l01393"></a>01393     stat = disk_initialize(fs-&gt;drive);  <span class="comment">/* Initialize low level disk I/O layer */</span>
<a name="l01394"></a>01394     <span class="keywordflow">if</span> (stat &amp; STA_NOINIT)              <span class="comment">/* Check if the drive is ready */</span>
<a name="l01395"></a>01395         <span class="keywordflow">return</span> FR_NOT_READY;
<a name="l01396"></a>01396 <span class="preprocessor">#if _MAX_SS != 512                      </span><span class="comment">/* Get disk sector size if needed */</span>
<a name="l01397"></a>01397     <span class="keywordflow">if</span> (disk_ioctl(fs-&gt;drive, GET_SECTOR_SIZE, &amp;SS(fs)) != RES_OK || SS(fs) &gt; _MAX_SS)
<a name="l01398"></a>01398         <span class="keywordflow">return</span> FR_NO_FILESYSTEM;
<a name="l01399"></a>01399 <span class="preprocessor">#endif</span>
<a name="l01400"></a>01400 <span class="preprocessor"></span><span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01401"></a>01401 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (chk_wp &amp;&amp; (stat &amp; STA_PROTECT)) <span class="comment">/* Check write protection if needed */</span>
<a name="l01402"></a>01402         <span class="keywordflow">return</span> FR_WRITE_PROTECTED;
<a name="l01403"></a>01403 <span class="preprocessor">#endif</span>
<a name="l01404"></a>01404 <span class="preprocessor"></span>    <span class="comment">/* Search FAT partition on the drive */</span>
<a name="l01405"></a>01405     fmt = check_fs(fs, bsect = 0);      <span class="comment">/* Check sector 0 as an SFD format */</span>
<a name="l01406"></a>01406     <span class="keywordflow">if</span> (fmt == 1) {                     <span class="comment">/* Not an FAT boot record, it may be patitioned */</span>
<a name="l01407"></a>01407         <span class="comment">/* Check a partition listed in top of the partition table */</span>
<a name="l01408"></a>01408         tbl = &amp;fs-&gt;win[MBR_Table + LD2PT(vol) * 16];    <span class="comment">/* Partition table */</span>
<a name="l01409"></a>01409         <span class="keywordflow">if</span> (tbl[4]) {                                   <span class="comment">/* Is the partition existing? */</span>
<a name="l01410"></a>01410             bsect = LD_DWORD(&amp;tbl[8]);                  <span class="comment">/* Partition offset in LBA */</span>
<a name="l01411"></a>01411             fmt = check_fs(fs, bsect);                  <span class="comment">/* Check the partition */</span>
<a name="l01412"></a>01412         }
<a name="l01413"></a>01413     }
<a name="l01414"></a>01414     <span class="keywordflow">if</span> (fmt == 3) <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l01415"></a>01415     <span class="keywordflow">if</span> (fmt || LD_WORD(fs-&gt;win+BPB_BytsPerSec) != SS(fs))   <span class="comment">/* No valid FAT patition is found */</span>
<a name="l01416"></a>01416         <span class="keywordflow">return</span> FR_NO_FILESYSTEM;
<a name="l01417"></a>01417 
<a name="l01418"></a>01418     <span class="comment">/* Initialize the file system object */</span>
<a name="l01419"></a>01419     fsize = LD_WORD(fs-&gt;win+BPB_FATSz16);               <span class="comment">/* Number of sectors per FAT */</span>
<a name="l01420"></a>01420     <span class="keywordflow">if</span> (!fsize) fsize = LD_DWORD(fs-&gt;win+BPB_FATSz32);
<a name="l01421"></a>01421     fs-&gt;sects_fat = fsize;
<a name="l01422"></a>01422     fs-&gt;n_fats = fs-&gt;win[BPB_NumFATs];                  <span class="comment">/* Number of FAT copies */</span>
<a name="l01423"></a>01423     fsize *= fs-&gt;n_fats;                                <span class="comment">/* (Number of sectors in FAT area) */</span>
<a name="l01424"></a>01424     fs-&gt;fatbase = bsect + LD_WORD(fs-&gt;win+BPB_RsvdSecCnt); <span class="comment">/* FAT start sector (lba) */</span>
<a name="l01425"></a>01425     fs-&gt;csize = fs-&gt;win[BPB_SecPerClus];                <span class="comment">/* Number of sectors per cluster */</span>
<a name="l01426"></a>01426     fs-&gt;n_rootdir = LD_WORD(fs-&gt;win+BPB_RootEntCnt);    <span class="comment">/* Nmuber of root directory entries */</span>
<a name="l01427"></a>01427     tsect = LD_WORD(fs-&gt;win+BPB_TotSec16);              <span class="comment">/* Number of sectors on the file system */</span>
<a name="l01428"></a>01428     <span class="keywordflow">if</span> (!tsect) tsect = LD_DWORD(fs-&gt;win+BPB_TotSec32);
<a name="l01429"></a>01429     fs-&gt;max_clust = mclst = (tsect                      <span class="comment">/* Last cluster# + 1 */</span>
<a name="l01430"></a>01430         - LD_WORD(fs-&gt;win+BPB_RsvdSecCnt) - fsize - fs-&gt;n_rootdir / (SS(fs)/32)
<a name="l01431"></a>01431         ) / fs-&gt;csize + 2;
<a name="l01432"></a>01432 
<a name="l01433"></a>01433     fmt = FS_FAT12;                                     <span class="comment">/* Determine the FAT sub type */</span>
<a name="l01434"></a>01434     <span class="keywordflow">if</span> (mclst &gt;= 0xFF7) fmt = FS_FAT16;             <span class="comment">/* Number of clusters &gt;= 0xFF5 */</span>
<a name="l01435"></a>01435     <span class="keywordflow">if</span> (mclst &gt;= 0xFFF7) fmt = FS_FAT32;            <span class="comment">/* Number of clusters &gt;= 0xFFF5 */</span>
<a name="l01436"></a>01436 
<a name="l01437"></a>01437     <span class="keywordflow">if</span> (fmt == FS_FAT32)
<a name="l01438"></a>01438         fs-&gt;dirbase = LD_DWORD(fs-&gt;win+BPB_RootClus);   <span class="comment">/* Root directory start cluster */</span>
<a name="l01439"></a>01439     <span class="keywordflow">else</span>
<a name="l01440"></a>01440         fs-&gt;dirbase = fs-&gt;fatbase + fsize;              <span class="comment">/* Root directory start sector (lba) */</span>
<a name="l01441"></a>01441     fs-&gt;database = fs-&gt;fatbase + fsize + fs-&gt;n_rootdir / (SS(fs)/32);   <span class="comment">/* Data start sector (lba) */</span>
<a name="l01442"></a>01442 
<a name="l01443"></a>01443 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01444"></a>01444 <span class="preprocessor"></span>    <span class="comment">/* Initialize allocation information */</span>
<a name="l01445"></a>01445     fs-&gt;free_clust = 0xFFFFFFFF;
<a name="l01446"></a>01446     fs-&gt;wflag = 0;
<a name="l01447"></a>01447     <span class="comment">/* Get fsinfo if needed */</span>
<a name="l01448"></a>01448     <span class="keywordflow">if</span> (fmt == FS_FAT32) {
<a name="l01449"></a>01449         fs-&gt;fsi_sector = bsect + LD_WORD(fs-&gt;win+BPB_FSInfo);
<a name="l01450"></a>01450         fs-&gt;fsi_flag = 0;
<a name="l01451"></a>01451         <span class="keywordflow">if</span> (disk_read(fs-&gt;drive, fs-&gt;win, fs-&gt;fsi_sector, 1) == RES_OK &amp;&amp;
<a name="l01452"></a>01452             LD_WORD(fs-&gt;win+BS_55AA) == 0xAA55 &amp;&amp;
<a name="l01453"></a>01453             LD_DWORD(fs-&gt;win+FSI_LeadSig) == 0x41615252 &amp;&amp;
<a name="l01454"></a>01454             LD_DWORD(fs-&gt;win+FSI_StrucSig) == 0x61417272) {
<a name="l01455"></a>01455             fs-&gt;last_clust = LD_DWORD(fs-&gt;win+FSI_Nxt_Free);
<a name="l01456"></a>01456             fs-&gt;free_clust = LD_DWORD(fs-&gt;win+FSI_Free_Count);
<a name="l01457"></a>01457         }
<a name="l01458"></a>01458     }
<a name="l01459"></a>01459 <span class="preprocessor">#endif</span>
<a name="l01460"></a>01460 <span class="preprocessor"></span>    fs-&gt;winsect = 0;
<a name="l01461"></a>01461     fs-&gt;fs_type = fmt;          <span class="comment">/* FAT syb-type */</span>
<a name="l01462"></a>01462     fs-&gt;id = ++Fsid;            <span class="comment">/* File system mount ID */</span>
<a name="l01463"></a>01463     res = FR_OK;
<a name="l01464"></a>01464 
<a name="l01465"></a>01465     <span class="keywordflow">return</span> res;
<a name="l01466"></a>01466 }
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 
<a name="l01469"></a>01469 
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01472"></a>01472 <span class="comment">/* Check if the file/dir object is valid or not                          */</span>
<a name="l01473"></a>01473 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01474"></a>01474 
<a name="l01475"></a>01475 <span class="keyword">static</span>
<a name="l01476"></a>01476 FRESULT validate (  <span class="comment">/* FR_OK(0): The object is valid, !=0: Invalid */</span>
<a name="l01477"></a>01477     FATFS *fs,      <span class="comment">/* Pointer to the file system object */</span>
<a name="l01478"></a>01478     WORD <span class="keywordtype">id</span>         <span class="comment">/* Member id of the target object to be checked */</span>
<a name="l01479"></a>01479 )
<a name="l01480"></a>01480 {
<a name="l01481"></a>01481     <span class="keywordflow">if</span> (!fs || !fs-&gt;fs_type || fs-&gt;id != <span class="keywordtype">id</span>)
<a name="l01482"></a>01482         <span class="keywordflow">return</span> FR_INVALID_OBJECT;
<a name="l01483"></a>01483 
<a name="l01484"></a>01484     ENTER_FF(fs);       <span class="comment">/* Lock file system */</span>
<a name="l01485"></a>01485 
<a name="l01486"></a>01486     <span class="keywordflow">if</span> (disk_status(fs-&gt;drive) &amp; STA_NOINIT)
<a name="l01487"></a>01487         <span class="keywordflow">return</span> FR_NOT_READY;
<a name="l01488"></a>01488 
<a name="l01489"></a>01489     <span class="keywordflow">return</span> FR_OK;
<a name="l01490"></a>01490 }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 
<a name="l01494"></a>01494 
<a name="l01495"></a>01495 <span class="comment">/*--------------------------------------------------------------------------</span>
<a name="l01496"></a>01496 <span class="comment"></span>
<a name="l01497"></a>01497 <span class="comment">   Public Functions</span>
<a name="l01498"></a>01498 <span class="comment"></span>
<a name="l01499"></a>01499 <span class="comment">--------------------------------------------------------------------------*/</span>
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 
<a name="l01503"></a>01503 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01504"></a>01504 <span class="comment">/* Mount/Unmount a Locical Drive                                         */</span>
<a name="l01505"></a>01505 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 FRESULT f_mount (
<a name="l01508"></a>01508     BYTE vol,       <span class="comment">/* Logical drive number to be mounted/unmounted */</span>
<a name="l01509"></a>01509     FATFS *fs       <span class="comment">/* Pointer to new file system object (NULL for unmount)*/</span>
<a name="l01510"></a>01510 )
<a name="l01511"></a>01511 {
<a name="l01512"></a>01512     FATFS *rfs;
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 
<a name="l01515"></a>01515     <span class="keywordflow">if</span> (vol &gt;= _DRIVES)             <span class="comment">/* Check if the drive number is valid */</span>
<a name="l01516"></a>01516         <span class="keywordflow">return</span> FR_INVALID_DRIVE;
<a name="l01517"></a>01517     rfs = FatFs[vol];               <span class="comment">/* Get current state */</span>
<a name="l01518"></a>01518 
<a name="l01519"></a>01519     <span class="keywordflow">if</span> (rfs) {
<a name="l01520"></a>01520 <span class="preprocessor">#if _FS_REENTRANT                   </span><span class="comment">/* Discard sync object of the current volume */</span>
<a name="l01521"></a>01521         <span class="keywordflow">if</span> (!ff_del_syncobj(fs-&gt;sobj)) <span class="keywordflow">return</span> FR_INT_ERR;
<a name="l01522"></a>01522 <span class="preprocessor">#endif</span>
<a name="l01523"></a>01523 <span class="preprocessor"></span>        rfs-&gt;fs_type = 0;           <span class="comment">/* Clear old fs object */</span>
<a name="l01524"></a>01524     }
<a name="l01525"></a>01525 
<a name="l01526"></a>01526     <span class="keywordflow">if</span> (fs) {
<a name="l01527"></a>01527         fs-&gt;fs_type = 0;            <span class="comment">/* Clear new fs object */</span>
<a name="l01528"></a>01528 <span class="preprocessor">#if _FS_REENTRANT                   </span><span class="comment">/* Create sync object for the new volume */</span>
<a name="l01529"></a>01529         <span class="keywordflow">if</span> (!ff_cre_syncobj(vol, &amp;fs-&gt;sobj)) <span class="keywordflow">return</span> FR_INT_ERR;
<a name="l01530"></a>01530 <span class="preprocessor">#endif</span>
<a name="l01531"></a>01531 <span class="preprocessor"></span>    }
<a name="l01532"></a>01532     FatFs[vol] = fs;                <span class="comment">/* Register new fs object */</span>
<a name="l01533"></a>01533 
<a name="l01534"></a>01534     <span class="keywordflow">return</span> FR_OK;
<a name="l01535"></a>01535 }
<a name="l01536"></a>01536 
<a name="l01537"></a>01537 
<a name="l01538"></a>01538 
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01541"></a>01541 <span class="comment">/* Open or Create a File                                                 */</span>
<a name="l01542"></a>01542 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 FRESULT f_open (
<a name="l01545"></a>01545     FIL *fp,            <span class="comment">/* Pointer to the blank file object */</span>
<a name="l01546"></a>01546     <span class="keyword">const</span> <span class="keywordtype">char</span> *path,   <span class="comment">/* Pointer to the file name */</span>
<a name="l01547"></a>01547     BYTE mode           <span class="comment">/* Access mode and file open mode flags */</span>
<a name="l01548"></a>01548 )
<a name="l01549"></a>01549 {
<a name="l01550"></a>01550     FRESULT res;
<a name="l01551"></a>01551     DIR dj;
<a name="l01552"></a>01552     NAMEBUF(sfn, lfn);
<a name="l01553"></a>01553     BYTE *dir;
<a name="l01554"></a>01554 
<a name="l01555"></a>01555 
<a name="l01556"></a>01556     fp-&gt;fs = NULL;      <span class="comment">/* Clear file object */</span>
<a name="l01557"></a>01557 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01558"></a>01558 <span class="preprocessor"></span>    mode &amp;= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
<a name="l01559"></a>01559     res = auto_mount(&amp;path, &amp;dj.fs, (BYTE)(mode &amp; (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)));
<a name="l01560"></a>01560 <span class="preprocessor">#else</span>
<a name="l01561"></a>01561 <span class="preprocessor"></span>    mode &amp;= FA_READ;
<a name="l01562"></a>01562     res = auto_mount(&amp;path, &amp;dj.fs, 0);
<a name="l01563"></a>01563 <span class="preprocessor">#endif</span>
<a name="l01564"></a>01564 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res);
<a name="l01565"></a>01565     INITBUF(dj, sfn, lfn);
<a name="l01566"></a>01566     res = follow_path(&amp;dj, path);   <span class="comment">/* Follow the file path */</span>
<a name="l01567"></a>01567 
<a name="l01568"></a>01568 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01569"></a>01569 <span class="preprocessor"></span>    <span class="comment">/* Create or Open a file */</span>
<a name="l01570"></a>01570     <span class="keywordflow">if</span> (mode &amp; (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
<a name="l01571"></a>01571         DWORD ps, cl;
<a name="l01572"></a>01572 
<a name="l01573"></a>01573         <span class="keywordflow">if</span> (res != FR_OK) {     <span class="comment">/* No file, create new */</span>
<a name="l01574"></a>01574             <span class="keywordflow">if</span> (res == FR_NO_FILE)
<a name="l01575"></a>01575                 res = dir_register(&amp;dj);
<a name="l01576"></a>01576             <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res);
<a name="l01577"></a>01577             mode |= FA_CREATE_ALWAYS;
<a name="l01578"></a>01578             dir = dj.dir;
<a name="l01579"></a>01579         }
<a name="l01580"></a>01580         <span class="keywordflow">else</span> {                  <span class="comment">/* Any object is already existing */</span>
<a name="l01581"></a>01581             <span class="keywordflow">if</span> (mode &amp; FA_CREATE_NEW)           <span class="comment">/* Cannot create new */</span>
<a name="l01582"></a>01582                 LEAVE_FF(dj.fs, FR_EXIST);
<a name="l01583"></a>01583             dir = dj.dir;
<a name="l01584"></a>01584             <span class="keywordflow">if</span> (!dir || (dir[DIR_Attr] &amp; (AM_RDO | AM_DIR)))    <span class="comment">/* Cannot overwrite it (R/O or DIR) */</span>
<a name="l01585"></a>01585                 LEAVE_FF(dj.fs, FR_DENIED);
<a name="l01586"></a>01586             <span class="keywordflow">if</span> (mode &amp; FA_CREATE_ALWAYS) {      <span class="comment">/* Resize it to zero if needed */</span>
<a name="l01587"></a>01587                 cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);    <span class="comment">/* Get start cluster */</span>
<a name="l01588"></a>01588                 ST_WORD(dir+DIR_FstClusHI, 0);  <span class="comment">/* cluster = 0 */</span>
<a name="l01589"></a>01589                 ST_WORD(dir+DIR_FstClusLO, 0);
<a name="l01590"></a>01590                 ST_DWORD(dir+DIR_FileSize, 0);  <span class="comment">/* size = 0 */</span>
<a name="l01591"></a>01591                 dj.fs-&gt;wflag = 1;
<a name="l01592"></a>01592                 ps = dj.fs-&gt;winsect;            <span class="comment">/* Remove the cluster chain */</span>
<a name="l01593"></a>01593                 <span class="keywordflow">if</span> (cl) {
<a name="l01594"></a>01594                     res = remove_chain(dj.fs, cl);
<a name="l01595"></a>01595                     <span class="keywordflow">if</span> (res) LEAVE_FF(dj.fs, res);
<a name="l01596"></a>01596                     dj.fs-&gt;last_clust = cl - 1; <span class="comment">/* Reuse the cluster hole */</span>
<a name="l01597"></a>01597                 }
<a name="l01598"></a>01598                 res = move_window(dj.fs, ps);
<a name="l01599"></a>01599                 <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res);
<a name="l01600"></a>01600             }
<a name="l01601"></a>01601         }
<a name="l01602"></a>01602         <span class="keywordflow">if</span> (mode &amp; FA_CREATE_ALWAYS) {
<a name="l01603"></a>01603             dir[DIR_Attr] = 0;                  <span class="comment">/* Reset attribute */</span>
<a name="l01604"></a>01604             ps = get_fattime();
<a name="l01605"></a>01605             ST_DWORD(dir+DIR_CrtTime, ps);      <span class="comment">/* Created time */</span>
<a name="l01606"></a>01606             dj.fs-&gt;wflag = 1;
<a name="l01607"></a>01607             mode |= FA__WRITTEN;                <span class="comment">/* Set file changed flag */</span>
<a name="l01608"></a>01608         }
<a name="l01609"></a>01609     }
<a name="l01610"></a>01610     <span class="comment">/* Open an existing file */</span>
<a name="l01611"></a>01611     <span class="keywordflow">else</span> {
<a name="l01612"></a>01612 <span class="preprocessor">#endif </span><span class="comment">/* !_FS_READONLY */</span>
<a name="l01613"></a>01613         <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res); <span class="comment">/* Follow failed */</span>
<a name="l01614"></a>01614         dir = dj.dir;
<a name="l01615"></a>01615         <span class="keywordflow">if</span> (!dir || (dir[DIR_Attr] &amp; AM_DIR))   <span class="comment">/* It is a directory */</span>
<a name="l01616"></a>01616             LEAVE_FF(dj.fs, FR_NO_FILE);
<a name="l01617"></a>01617 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01618"></a>01618 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((mode &amp; FA_WRITE) &amp;&amp; (dir[DIR_Attr] &amp; AM_RDO)) <span class="comment">/* R/O violation */</span>
<a name="l01619"></a>01619             LEAVE_FF(dj.fs, FR_DENIED);
<a name="l01620"></a>01620     }
<a name="l01621"></a>01621     fp-&gt;dir_sect = dj.fs-&gt;winsect;      <span class="comment">/* Pointer to the directory entry */</span>
<a name="l01622"></a>01622     fp-&gt;dir_ptr = dj.dir;
<a name="l01623"></a>01623 <span class="preprocessor">#endif</span>
<a name="l01624"></a>01624 <span class="preprocessor"></span>    fp-&gt;flag = mode;                    <span class="comment">/* File access mode */</span>
<a name="l01625"></a>01625     fp-&gt;org_clust =                     <span class="comment">/* File start cluster */</span>
<a name="l01626"></a>01626         ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
<a name="l01627"></a>01627     fp-&gt;fsize = LD_DWORD(dir+DIR_FileSize); <span class="comment">/* File size */</span>
<a name="l01628"></a>01628     fp-&gt;fptr = 0; fp-&gt;csect = 255;      <span class="comment">/* File pointer */</span>
<a name="l01629"></a>01629     fp-&gt;dsect = 0;
<a name="l01630"></a>01630     fp-&gt;fs = dj.fs; fp-&gt;id = dj.fs-&gt;id; <span class="comment">/* Owner file system object of the file */</span>
<a name="l01631"></a>01631 
<a name="l01632"></a>01632     LEAVE_FF(dj.fs, FR_OK);
<a name="l01633"></a>01633 }
<a name="l01634"></a>01634 
<a name="l01635"></a>01635 
<a name="l01636"></a>01636 
<a name="l01637"></a>01637 
<a name="l01638"></a>01638 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01639"></a>01639 <span class="comment">/* Read File                                                             */</span>
<a name="l01640"></a>01640 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01641"></a>01641 
<a name="l01642"></a>01642 FRESULT f_read (
<a name="l01643"></a>01643     FIL *fp,        <span class="comment">/* Pointer to the file object */</span>
<a name="l01644"></a>01644     <span class="keywordtype">void</span> *buff,     <span class="comment">/* Pointer to data buffer */</span>
<a name="l01645"></a>01645     UINT btr,       <span class="comment">/* Number of bytes to read */</span>
<a name="l01646"></a>01646     UINT *br        <span class="comment">/* Pointer to number of bytes read */</span>
<a name="l01647"></a>01647 )
<a name="l01648"></a>01648 {
<a name="l01649"></a>01649     FRESULT res;
<a name="l01650"></a>01650     DWORD clst, sect, remain;
<a name="l01651"></a>01651     UINT rcnt, cc;
<a name="l01652"></a>01652     BYTE *rbuff = buff;
<a name="l01653"></a>01653 
<a name="l01654"></a>01654 
<a name="l01655"></a>01655     *br = 0;
<a name="l01656"></a>01656 
<a name="l01657"></a>01657     res = validate(fp-&gt;fs, fp-&gt;id);                 <span class="comment">/* Check validity of the object */</span>
<a name="l01658"></a>01658     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
<a name="l01659"></a>01659     <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__ERROR)                       <span class="comment">/* Check abort flag */</span>
<a name="l01660"></a>01660         LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
<a name="l01661"></a>01661     <span class="keywordflow">if</span> (!(fp-&gt;flag &amp; FA_READ))                      <span class="comment">/* Check access mode */</span>
<a name="l01662"></a>01662         LEAVE_FF(fp-&gt;fs, FR_DENIED);
<a name="l01663"></a>01663     remain = fp-&gt;fsize - fp-&gt;fptr;
<a name="l01664"></a>01664     <span class="keywordflow">if</span> (btr &gt; remain) btr = (UINT)remain;           <span class="comment">/* Truncate btr by remaining bytes */</span>
<a name="l01665"></a>01665 
<a name="l01666"></a>01666     <span class="keywordflow">for</span> ( ;  btr;                                   <span class="comment">/* Repeat until all data transferred */</span>
<a name="l01667"></a>01667         rbuff += rcnt, fp-&gt;fptr += rcnt, *br += rcnt, btr -= rcnt) {
<a name="l01668"></a>01668         <span class="keywordflow">if</span> ((fp-&gt;fptr % SS(fp-&gt;fs)) == 0) {         <span class="comment">/* On the sector boundary? */</span>
<a name="l01669"></a>01669             <span class="keywordflow">if</span> (fp-&gt;csect &gt;= fp-&gt;fs-&gt;csize) {       <span class="comment">/* On the cluster boundary? */</span>
<a name="l01670"></a>01670                 clst = (fp-&gt;fptr == 0) ?            <span class="comment">/* On the top of the file? */</span>
<a name="l01671"></a>01671                     fp-&gt;org_clust : get_cluster(fp-&gt;fs, fp-&gt;curr_clust);
<a name="l01672"></a>01672                 <span class="keywordflow">if</span> (clst &lt;= 1) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l01673"></a>01673                 <span class="keywordflow">if</span> (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01674"></a>01674                 fp-&gt;curr_clust = clst;              <span class="comment">/* Update current cluster */</span>
<a name="l01675"></a>01675                 fp-&gt;csect = 0;                      <span class="comment">/* Reset sector offset in the cluster */</span>
<a name="l01676"></a>01676             }
<a name="l01677"></a>01677             sect = clust2sect(fp-&gt;fs, fp-&gt;curr_clust);  <span class="comment">/* Get current sector */</span>
<a name="l01678"></a>01678             <span class="keywordflow">if</span> (!sect) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l01679"></a>01679             sect += fp-&gt;csect;
<a name="l01680"></a>01680             cc = btr / SS(fp-&gt;fs);                  <span class="comment">/* When remaining bytes &gt;= sector size, */</span>
<a name="l01681"></a>01681             <span class="keywordflow">if</span> (cc) {                               <span class="comment">/* Read maximum contiguous sectors directly */</span>
<a name="l01682"></a>01682                 <span class="keywordflow">if</span> (fp-&gt;csect + cc &gt; fp-&gt;fs-&gt;csize) <span class="comment">/* Clip at cluster boundary */</span>
<a name="l01683"></a>01683                     cc = fp-&gt;fs-&gt;csize - fp-&gt;csect;
<a name="l01684"></a>01684                 <span class="keywordflow">if</span> (disk_read(fp-&gt;fs-&gt;drive, rbuff, sect, (BYTE)cc) != RES_OK)
<a name="l01685"></a>01685                     ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01686"></a>01686                 fp-&gt;csect += (BYTE)cc;              <span class="comment">/* Next sector address in the cluster */</span>
<a name="l01687"></a>01687                 rcnt = SS(fp-&gt;fs) * cc;             <span class="comment">/* Number of bytes transferred */</span>
<a name="l01688"></a>01688                 <span class="keywordflow">continue</span>;
<a name="l01689"></a>01689             }
<a name="l01690"></a>01690 <span class="preprocessor">#if !_FS_TINY</span>
<a name="l01691"></a>01691 <span class="preprocessor"></span><span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01692"></a>01692 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__DIRTY) {         <span class="comment">/* Write sector I/O buffer if needed */</span>
<a name="l01693"></a>01693                 <span class="keywordflow">if</span> (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buf, fp-&gt;dsect, 1) != RES_OK)
<a name="l01694"></a>01694                     ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01695"></a>01695                 fp-&gt;flag &amp;= (BYTE)~FA__DIRTY;
<a name="l01696"></a>01696             }
<a name="l01697"></a>01697 <span class="preprocessor">#endif</span>
<a name="l01698"></a>01698 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fp-&gt;dsect != sect) {            <span class="comment">/* Fill sector buffer with file data */</span>
<a name="l01699"></a>01699                 <span class="keywordflow">if</span> (disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buf, sect, 1) != RES_OK)
<a name="l01700"></a>01700                     ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01701"></a>01701             }
<a name="l01702"></a>01702 <span class="preprocessor">#endif</span>
<a name="l01703"></a>01703 <span class="preprocessor"></span>            fp-&gt;dsect = sect;
<a name="l01704"></a>01704             fp-&gt;csect++;                            <span class="comment">/* Next sector address in the cluster */</span>
<a name="l01705"></a>01705         }
<a name="l01706"></a>01706         rcnt = SS(fp-&gt;fs) - (fp-&gt;fptr % SS(fp-&gt;fs));    <span class="comment">/* Get partial sector data from sector buffer */</span>
<a name="l01707"></a>01707         <span class="keywordflow">if</span> (rcnt &gt; btr) rcnt = btr;
<a name="l01708"></a>01708 <span class="preprocessor">#if _FS_TINY</span>
<a name="l01709"></a>01709 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (move_window(fp-&gt;fs, fp-&gt;dsect))         <span class="comment">/* Move sector window */</span>
<a name="l01710"></a>01710             ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01711"></a>01711         mem_cpy(rbuff, &amp;fp-&gt;fs-&gt;win[fp-&gt;fptr % SS(fp-&gt;fs)], rcnt);  <span class="comment">/* Pick partial sector */</span>
<a name="l01712"></a>01712 <span class="preprocessor">#else</span>
<a name="l01713"></a>01713 <span class="preprocessor"></span>        mem_cpy(rbuff, &amp;fp-&gt;buf[fp-&gt;fptr % SS(fp-&gt;fs)], rcnt);  <span class="comment">/* Pick partial sector */</span>
<a name="l01714"></a>01714 <span class="preprocessor">#endif</span>
<a name="l01715"></a>01715 <span class="preprocessor"></span>    }
<a name="l01716"></a>01716 
<a name="l01717"></a>01717 
<a name="l01718"></a>01718     LEAVE_FF(fp-&gt;fs, FR_OK);
<a name="l01719"></a>01719 }
<a name="l01720"></a>01720 
<a name="l01721"></a>01721 
<a name="l01722"></a>01722 
<a name="l01723"></a>01723 
<a name="l01724"></a>01724 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01725"></a>01725 <span class="preprocessor"></span><span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01726"></a>01726 <span class="comment">/* Write File                                                            */</span>
<a name="l01727"></a>01727 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01728"></a>01728 
<a name="l01729"></a>01729 FRESULT f_write (
<a name="l01730"></a>01730     FIL *fp,            <span class="comment">/* Pointer to the file object */</span>
<a name="l01731"></a>01731     <span class="keyword">const</span> <span class="keywordtype">void</span> *buff,   <span class="comment">/* Pointer to the data to be written */</span>
<a name="l01732"></a>01732     UINT btw,           <span class="comment">/* Number of bytes to write */</span>
<a name="l01733"></a>01733     UINT *bw            <span class="comment">/* Pointer to number of bytes written */</span>
<a name="l01734"></a>01734 )
<a name="l01735"></a>01735 {
<a name="l01736"></a>01736     FRESULT res;
<a name="l01737"></a>01737     DWORD clst, sect;
<a name="l01738"></a>01738     UINT wcnt, cc;
<a name="l01739"></a>01739     <span class="keyword">const</span> BYTE *wbuff = buff;
<a name="l01740"></a>01740 
<a name="l01741"></a>01741 
<a name="l01742"></a>01742     *bw = 0;
<a name="l01743"></a>01743 
<a name="l01744"></a>01744     res = validate(fp-&gt;fs, fp-&gt;id);                 <span class="comment">/* Check validity of the object */</span>
<a name="l01745"></a>01745     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
<a name="l01746"></a>01746     <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__ERROR)                       <span class="comment">/* Check abort flag */</span>
<a name="l01747"></a>01747         LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
<a name="l01748"></a>01748     <span class="keywordflow">if</span> (!(fp-&gt;flag &amp; FA_WRITE))                     <span class="comment">/* Check access mode */</span>
<a name="l01749"></a>01749         LEAVE_FF(fp-&gt;fs, FR_DENIED);
<a name="l01750"></a>01750     <span class="keywordflow">if</span> (fp-&gt;fsize + btw &lt; fp-&gt;fsize) btw = 0;       <span class="comment">/* File size cannot reach 4GB */</span>
<a name="l01751"></a>01751 
<a name="l01752"></a>01752     <span class="keywordflow">for</span> ( ;  btw;                                   <span class="comment">/* Repeat until all data transferred */</span>
<a name="l01753"></a>01753         wbuff += wcnt, fp-&gt;fptr += wcnt, *bw += wcnt, btw -= wcnt) {
<a name="l01754"></a>01754         <span class="keywordflow">if</span> ((fp-&gt;fptr % SS(fp-&gt;fs)) == 0) {         <span class="comment">/* On the sector boundary? */</span>
<a name="l01755"></a>01755             <span class="keywordflow">if</span> (fp-&gt;csect &gt;= fp-&gt;fs-&gt;csize) {       <span class="comment">/* On the cluster boundary? */</span>
<a name="l01756"></a>01756                 <span class="keywordflow">if</span> (fp-&gt;fptr == 0) {                <span class="comment">/* On the top of the file? */</span>
<a name="l01757"></a>01757                     clst = fp-&gt;org_clust;           <span class="comment">/* Follow from the origin */</span>
<a name="l01758"></a>01758                     <span class="keywordflow">if</span> (clst == 0)                  <span class="comment">/* When there is no cluster chain, */</span>
<a name="l01759"></a>01759                         fp-&gt;org_clust = clst = create_chain(fp-&gt;fs, 0); <span class="comment">/* Create a new cluster chain */</span>
<a name="l01760"></a>01760                 } <span class="keywordflow">else</span> {                            <span class="comment">/* Middle or end of the file */</span>
<a name="l01761"></a>01761                     clst = create_chain(fp-&gt;fs, fp-&gt;curr_clust);            <span class="comment">/* Follow or streach cluster chain */</span>
<a name="l01762"></a>01762                 }
<a name="l01763"></a>01763                 <span class="keywordflow">if</span> (clst == 0) <span class="keywordflow">break</span>;               <span class="comment">/* Could not allocate a new cluster (disk full) */</span>
<a name="l01764"></a>01764                 <span class="keywordflow">if</span> (clst == 1) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l01765"></a>01765                 <span class="keywordflow">if</span> (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01766"></a>01766                 fp-&gt;curr_clust = clst;              <span class="comment">/* Update current cluster */</span>
<a name="l01767"></a>01767                 fp-&gt;csect = 0;                      <span class="comment">/* Reset sector address in the cluster */</span>
<a name="l01768"></a>01768             }
<a name="l01769"></a>01769 <span class="preprocessor">#if _FS_TINY</span>
<a name="l01770"></a>01770 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fp-&gt;fs-&gt;winsect == fp-&gt;dsect &amp;&amp; move_window(fp-&gt;fs, 0)) <span class="comment">/* Write back data buffer prior to following direct transfer */</span>
<a name="l01771"></a>01771                 ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01772"></a>01772 <span class="preprocessor">#else</span>
<a name="l01773"></a>01773 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__DIRTY) {     <span class="comment">/* Write back data buffer prior to following direct transfer */</span>
<a name="l01774"></a>01774                 <span class="keywordflow">if</span> (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buf, fp-&gt;dsect, 1) != RES_OK)
<a name="l01775"></a>01775                     ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01776"></a>01776                 fp-&gt;flag &amp;= (BYTE)~FA__DIRTY;
<a name="l01777"></a>01777             }
<a name="l01778"></a>01778 <span class="preprocessor">#endif</span>
<a name="l01779"></a>01779 <span class="preprocessor"></span>            sect = clust2sect(fp-&gt;fs, fp-&gt;curr_clust);  <span class="comment">/* Get current sector */</span>
<a name="l01780"></a>01780             <span class="keywordflow">if</span> (!sect) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l01781"></a>01781             sect += fp-&gt;csect;
<a name="l01782"></a>01782             cc = btw / SS(fp-&gt;fs);                  <span class="comment">/* When remaining bytes &gt;= sector size, */</span>
<a name="l01783"></a>01783             <span class="keywordflow">if</span> (cc) {                               <span class="comment">/* Write maximum contiguous sectors directly */</span>
<a name="l01784"></a>01784                 <span class="keywordflow">if</span> (fp-&gt;csect + cc &gt; fp-&gt;fs-&gt;csize) <span class="comment">/* Clip at cluster boundary */</span>
<a name="l01785"></a>01785                     cc = fp-&gt;fs-&gt;csize - fp-&gt;csect;
<a name="l01786"></a>01786                 <span class="keywordflow">if</span> (disk_write(fp-&gt;fs-&gt;drive, wbuff, sect, (BYTE)cc) != RES_OK)
<a name="l01787"></a>01787                     ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01788"></a>01788 <span class="preprocessor">#if _FS_TINY</span>
<a name="l01789"></a>01789 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (fp-&gt;fs-&gt;winsect - sect &lt; cc) {  <span class="comment">/* Refill sector cache if it gets dirty by the direct write */</span>
<a name="l01790"></a>01790                     mem_cpy(fp-&gt;fs-&gt;win, wbuff + ((fp-&gt;fs-&gt;winsect - sect) * SS(fp-&gt;fs)), SS(fp-&gt;fs));
<a name="l01791"></a>01791                     fp-&gt;fs-&gt;wflag = 0;
<a name="l01792"></a>01792                 }
<a name="l01793"></a>01793 <span class="preprocessor">#else</span>
<a name="l01794"></a>01794 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (fp-&gt;dsect - sect &lt; cc) {  <span class="comment">/* Refill sector cache if it gets dirty by the direct write */</span>
<a name="l01795"></a>01795                     mem_cpy(fp-&gt;buf, wbuff + ((fp-&gt;dsect - sect) * SS(fp-&gt;fs)), SS(fp-&gt;fs));
<a name="l01796"></a>01796                     fp-&gt;flag &amp;= ~FA__DIRTY;
<a name="l01797"></a>01797                 }
<a name="l01798"></a>01798 <span class="preprocessor">#endif          </span>
<a name="l01799"></a>01799 <span class="preprocessor"></span>                fp-&gt;csect += (BYTE)cc;              <span class="comment">/* Next sector address in the cluster */</span>
<a name="l01800"></a>01800                 wcnt = SS(fp-&gt;fs) * cc;             <span class="comment">/* Number of bytes transferred */</span>
<a name="l01801"></a>01801                 <span class="keywordflow">continue</span>;
<a name="l01802"></a>01802             }
<a name="l01803"></a>01803 <span class="preprocessor">#if _FS_TINY</span>
<a name="l01804"></a>01804 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fp-&gt;fptr &gt;= fp-&gt;fsize) {            <span class="comment">/* Avoid silly buffer filling at growing edge */</span>
<a name="l01805"></a>01805                 <span class="keywordflow">if</span> (move_window(fp-&gt;fs, 0)) ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01806"></a>01806                 fp-&gt;fs-&gt;winsect = sect;
<a name="l01807"></a>01807             }
<a name="l01808"></a>01808 <span class="preprocessor">#else</span>
<a name="l01809"></a>01809 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fp-&gt;dsect != sect) {                <span class="comment">/* Fill sector buffer with file data */</span>
<a name="l01810"></a>01810                 <span class="keywordflow">if</span> (fp-&gt;fptr &lt; fp-&gt;fsize &amp;&amp;
<a name="l01811"></a>01811                     disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buf, sect, 1) != RES_OK)
<a name="l01812"></a>01812                         ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01813"></a>01813             }
<a name="l01814"></a>01814 <span class="preprocessor">#endif</span>
<a name="l01815"></a>01815 <span class="preprocessor"></span>            fp-&gt;dsect = sect;
<a name="l01816"></a>01816             fp-&gt;csect++;                            <span class="comment">/* Next sector address in the cluster */</span>
<a name="l01817"></a>01817         }
<a name="l01818"></a>01818         wcnt = SS(fp-&gt;fs) - (fp-&gt;fptr % SS(fp-&gt;fs));    <span class="comment">/* Put partial sector into file I/O buffer */</span>
<a name="l01819"></a>01819         <span class="keywordflow">if</span> (wcnt &gt; btw) wcnt = btw;
<a name="l01820"></a>01820 <span class="preprocessor">#if _FS_TINY</span>
<a name="l01821"></a>01821 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (move_window(fp-&gt;fs, fp-&gt;dsect))         <span class="comment">/* Move sector window */</span>
<a name="l01822"></a>01822             ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01823"></a>01823         mem_cpy(&amp;fp-&gt;fs-&gt;win[fp-&gt;fptr % SS(fp-&gt;fs)], wbuff, wcnt);  <span class="comment">/* Fit partial sector */</span>
<a name="l01824"></a>01824         fp-&gt;fs-&gt;wflag = 1;
<a name="l01825"></a>01825 <span class="preprocessor">#else</span>
<a name="l01826"></a>01826 <span class="preprocessor"></span>        mem_cpy(&amp;fp-&gt;buf[fp-&gt;fptr % SS(fp-&gt;fs)], wbuff, wcnt);  <span class="comment">/* Fit partial sector */</span>
<a name="l01827"></a>01827         fp-&gt;flag |= FA__DIRTY;
<a name="l01828"></a>01828 <span class="preprocessor">#endif</span>
<a name="l01829"></a>01829 <span class="preprocessor"></span>    }
<a name="l01830"></a>01830 
<a name="l01831"></a>01831     <span class="keywordflow">if</span> (fp-&gt;fptr &gt; fp-&gt;fsize) fp-&gt;fsize = fp-&gt;fptr; <span class="comment">/* Update file size if needed */</span>
<a name="l01832"></a>01832     fp-&gt;flag |= FA__WRITTEN;                        <span class="comment">/* Set file changed flag */</span>
<a name="l01833"></a>01833 
<a name="l01834"></a>01834     LEAVE_FF(fp-&gt;fs, FR_OK);
<a name="l01835"></a>01835 }
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 
<a name="l01838"></a>01838 
<a name="l01839"></a>01839 
<a name="l01840"></a>01840 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01841"></a>01841 <span class="comment">/* Synchronize the File Object                                           */</span>
<a name="l01842"></a>01842 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01843"></a>01843 
<a name="l01844"></a>01844 FRESULT f_sync (
<a name="l01845"></a>01845     FIL *fp     <span class="comment">/* Pointer to the file object */</span>
<a name="l01846"></a>01846 )
<a name="l01847"></a>01847 {
<a name="l01848"></a>01848     FRESULT res;
<a name="l01849"></a>01849     DWORD tim;
<a name="l01850"></a>01850     BYTE *dir;
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 
<a name="l01853"></a>01853     res = validate(fp-&gt;fs, fp-&gt;id);     <span class="comment">/* Check validity of the object */</span>
<a name="l01854"></a>01854     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l01855"></a>01855         <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__WRITTEN) {   <span class="comment">/* Has the file been written? */</span>
<a name="l01856"></a>01856 <span class="preprocessor">#if !_FS_TINY   </span><span class="comment">/* Write-back dirty buffer */</span>
<a name="l01857"></a>01857             <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__DIRTY) {
<a name="l01858"></a>01858                 <span class="keywordflow">if</span> (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buf, fp-&gt;dsect, 1) != RES_OK)
<a name="l01859"></a>01859                     LEAVE_FF(fp-&gt;fs, FR_DISK_ERR);
<a name="l01860"></a>01860                 fp-&gt;flag &amp;= (BYTE)~FA__DIRTY;
<a name="l01861"></a>01861             }
<a name="l01862"></a>01862 <span class="preprocessor">#endif</span>
<a name="l01863"></a>01863 <span class="preprocessor"></span>            <span class="comment">/* Update the directory entry */</span>
<a name="l01864"></a>01864             res = move_window(fp-&gt;fs, fp-&gt;dir_sect);
<a name="l01865"></a>01865             <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l01866"></a>01866                 dir = fp-&gt;dir_ptr;
<a name="l01867"></a>01867                 dir[DIR_Attr] |= AM_ARC;                    <span class="comment">/* Set archive bit */</span>
<a name="l01868"></a>01868                 ST_DWORD(dir+DIR_FileSize, fp-&gt;fsize);      <span class="comment">/* Update file size */</span>
<a name="l01869"></a>01869                 ST_WORD(dir+DIR_FstClusLO, fp-&gt;org_clust);  <span class="comment">/* Update start cluster */</span>
<a name="l01870"></a>01870                 ST_WORD(dir+DIR_FstClusHI, fp-&gt;org_clust &gt;&gt; 16);
<a name="l01871"></a>01871                 tim = get_fattime();                    <span class="comment">/* Updated time */</span>
<a name="l01872"></a>01872                 ST_DWORD(dir+DIR_WrtTime, tim);
<a name="l01873"></a>01873                 fp-&gt;flag &amp;= (BYTE)~FA__WRITTEN;
<a name="l01874"></a>01874                 fp-&gt;fs-&gt;wflag = 1;
<a name="l01875"></a>01875                 res = sync(fp-&gt;fs);
<a name="l01876"></a>01876             }
<a name="l01877"></a>01877         }
<a name="l01878"></a>01878     }
<a name="l01879"></a>01879 
<a name="l01880"></a>01880     LEAVE_FF(fp-&gt;fs, res);
<a name="l01881"></a>01881 }
<a name="l01882"></a>01882 
<a name="l01883"></a>01883 <span class="preprocessor">#endif </span><span class="comment">/* !_FS_READONLY */</span>
<a name="l01884"></a>01884 
<a name="l01885"></a>01885 
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 
<a name="l01888"></a>01888 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01889"></a>01889 <span class="comment">/* Close File                                                            */</span>
<a name="l01890"></a>01890 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01891"></a>01891 
<a name="l01892"></a>01892 FRESULT f_close (
<a name="l01893"></a>01893     FIL *fp     <span class="comment">/* Pointer to the file object to be closed */</span>
<a name="l01894"></a>01894 )
<a name="l01895"></a>01895 {
<a name="l01896"></a>01896     FRESULT res;
<a name="l01897"></a>01897 
<a name="l01898"></a>01898 
<a name="l01899"></a>01899 <span class="preprocessor">#if _FS_READONLY</span>
<a name="l01900"></a>01900 <span class="preprocessor"></span>    res = validate(fp-&gt;fs, fp-&gt;id);
<a name="l01901"></a>01901     <span class="keywordflow">if</span> (res == FR_OK) fp-&gt;fs = NULL;
<a name="l01902"></a>01902     LEAVE_FF(fp-&gt;fs, res);
<a name="l01903"></a>01903 <span class="preprocessor">#else</span>
<a name="l01904"></a>01904 <span class="preprocessor"></span>    res = f_sync(fp);
<a name="l01905"></a>01905     <span class="keywordflow">if</span> (res == FR_OK) fp-&gt;fs = NULL;
<a name="l01906"></a>01906     <span class="keywordflow">return</span> res;
<a name="l01907"></a>01907 <span class="preprocessor">#endif</span>
<a name="l01908"></a>01908 <span class="preprocessor"></span>}
<a name="l01909"></a>01909 
<a name="l01910"></a>01910 
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 
<a name="l01913"></a>01913 <span class="preprocessor">#if _FS_MINIMIZE &lt;= 2</span>
<a name="l01914"></a>01914 <span class="preprocessor"></span><span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01915"></a>01915 <span class="comment">/* Seek File R/W Pointer                                                 */</span>
<a name="l01916"></a>01916 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l01917"></a>01917 
<a name="l01918"></a>01918 FRESULT f_lseek (
<a name="l01919"></a>01919     FIL *fp,        <span class="comment">/* Pointer to the file object */</span>
<a name="l01920"></a>01920     DWORD ofs       <span class="comment">/* File pointer from top of file */</span>
<a name="l01921"></a>01921 )
<a name="l01922"></a>01922 {
<a name="l01923"></a>01923     FRESULT res;
<a name="l01924"></a>01924     DWORD clst, bcs, nsect, ifptr;
<a name="l01925"></a>01925 
<a name="l01926"></a>01926 
<a name="l01927"></a>01927     res = validate(fp-&gt;fs, fp-&gt;id);     <span class="comment">/* Check validity of the object */</span>
<a name="l01928"></a>01928     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
<a name="l01929"></a>01929     <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__ERROR)           <span class="comment">/* Check abort flag */</span>
<a name="l01930"></a>01930         LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
<a name="l01931"></a>01931     <span class="keywordflow">if</span> (ofs &gt; fp-&gt;fsize                 <span class="comment">/* In read-only mode, clip offset with the file size */</span>
<a name="l01932"></a>01932 #<span class="keywordflow">if</span> !_FS_READONLY
<a name="l01933"></a>01933          &amp;&amp; !(fp-&gt;flag &amp; FA_WRITE)
<a name="l01934"></a>01934 #endif
<a name="l01935"></a>01935         ) ofs = fp-&gt;fsize;
<a name="l01936"></a>01936 
<a name="l01937"></a>01937     ifptr = fp-&gt;fptr;
<a name="l01938"></a>01938     fp-&gt;fptr = 0; fp-&gt;csect = 255;
<a name="l01939"></a>01939     nsect = 0;
<a name="l01940"></a>01940     <span class="keywordflow">if</span> (ofs &gt; 0) {
<a name="l01941"></a>01941         bcs = (DWORD)fp-&gt;fs-&gt;csize * SS(fp-&gt;fs);    <span class="comment">/* Cluster size (byte) */</span>
<a name="l01942"></a>01942         <span class="keywordflow">if</span> (ifptr &gt; 0 &amp;&amp;
<a name="l01943"></a>01943             (ofs - 1) / bcs &gt;= (ifptr - 1) / bcs) { <span class="comment">/* When seek to same or following cluster, */</span>
<a name="l01944"></a>01944             fp-&gt;fptr = (ifptr - 1) &amp; ~(bcs - 1);    <span class="comment">/* start from the current cluster */</span>
<a name="l01945"></a>01945             ofs -= fp-&gt;fptr;
<a name="l01946"></a>01946             clst = fp-&gt;curr_clust;
<a name="l01947"></a>01947         } <span class="keywordflow">else</span> {                                    <span class="comment">/* When seek to back cluster, */</span>
<a name="l01948"></a>01948             clst = fp-&gt;org_clust;                   <span class="comment">/* start from the first cluster */</span>
<a name="l01949"></a>01949 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01950"></a>01950 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (clst == 0) {                        <span class="comment">/* If no cluster chain, create a new chain */</span>
<a name="l01951"></a>01951                 clst = create_chain(fp-&gt;fs, 0);
<a name="l01952"></a>01952                 <span class="keywordflow">if</span> (clst == 1) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l01953"></a>01953                 <span class="keywordflow">if</span> (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01954"></a>01954                 fp-&gt;org_clust = clst;
<a name="l01955"></a>01955             }
<a name="l01956"></a>01956 <span class="preprocessor">#endif</span>
<a name="l01957"></a>01957 <span class="preprocessor"></span>            fp-&gt;curr_clust = clst;
<a name="l01958"></a>01958         }
<a name="l01959"></a>01959         <span class="keywordflow">if</span> (clst != 0) {
<a name="l01960"></a>01960             <span class="keywordflow">while</span> (ofs &gt; bcs) {                     <span class="comment">/* Cluster following loop */</span>
<a name="l01961"></a>01961 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01962"></a>01962 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA_WRITE) {          <span class="comment">/* Check if in write mode or not */</span>
<a name="l01963"></a>01963                     clst = create_chain(fp-&gt;fs, clst);  <span class="comment">/* Force streached if in write mode */</span>
<a name="l01964"></a>01964                     <span class="keywordflow">if</span> (clst == 0) {                <span class="comment">/* When disk gets full, clip file size */</span>
<a name="l01965"></a>01965                         ofs = bcs; <span class="keywordflow">break</span>;
<a name="l01966"></a>01966                     }
<a name="l01967"></a>01967                 } <span class="keywordflow">else</span>
<a name="l01968"></a>01968 <span class="preprocessor">#endif</span>
<a name="l01969"></a>01969 <span class="preprocessor"></span>                    clst = get_cluster(fp-&gt;fs, clst);   <span class="comment">/* Follow cluster chain if not in write mode */</span>
<a name="l01970"></a>01970                 <span class="keywordflow">if</span> (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01971"></a>01971                 <span class="keywordflow">if</span> (clst &lt;= 1 || clst &gt;= fp-&gt;fs-&gt;max_clust) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l01972"></a>01972                 fp-&gt;curr_clust = clst;
<a name="l01973"></a>01973                 fp-&gt;fptr += bcs;
<a name="l01974"></a>01974                 ofs -= bcs;
<a name="l01975"></a>01975             }
<a name="l01976"></a>01976             fp-&gt;fptr += ofs;
<a name="l01977"></a>01977             fp-&gt;csect = (BYTE)(ofs / SS(fp-&gt;fs));   <span class="comment">/* Sector offset in the cluster */</span>
<a name="l01978"></a>01978             <span class="keywordflow">if</span> (ofs % SS(fp-&gt;fs)) {
<a name="l01979"></a>01979                 nsect = clust2sect(fp-&gt;fs, clst);   <span class="comment">/* Current sector */</span>
<a name="l01980"></a>01980                 <span class="keywordflow">if</span> (!nsect) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l01981"></a>01981                 nsect += fp-&gt;csect;
<a name="l01982"></a>01982                 fp-&gt;csect++;
<a name="l01983"></a>01983             }
<a name="l01984"></a>01984         }
<a name="l01985"></a>01985     }
<a name="l01986"></a>01986     <span class="keywordflow">if</span> (nsect &amp;&amp; nsect != fp-&gt;dsect &amp;&amp; fp-&gt;fptr % SS(fp-&gt;fs)) {
<a name="l01987"></a>01987 <span class="preprocessor">#if !_FS_TINY</span>
<a name="l01988"></a>01988 <span class="preprocessor"></span><span class="preprocessor">#if !_FS_READONLY</span>
<a name="l01989"></a>01989 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__DIRTY) {         <span class="comment">/* Write-back dirty buffer if needed */</span>
<a name="l01990"></a>01990             <span class="keywordflow">if</span> (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buf, fp-&gt;dsect, 1) != RES_OK)
<a name="l01991"></a>01991                 ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01992"></a>01992             fp-&gt;flag &amp;= (BYTE)~FA__DIRTY;
<a name="l01993"></a>01993         }
<a name="l01994"></a>01994 <span class="preprocessor">#endif</span>
<a name="l01995"></a>01995 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buf, nsect, 1) != RES_OK)
<a name="l01996"></a>01996             ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l01997"></a>01997 <span class="preprocessor">#endif</span>
<a name="l01998"></a>01998 <span class="preprocessor"></span>        fp-&gt;dsect = nsect;
<a name="l01999"></a>01999     }
<a name="l02000"></a>02000 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l02001"></a>02001 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (fp-&gt;fptr &gt; fp-&gt;fsize) {         <span class="comment">/* Set changed flag if the file size is extended */</span>
<a name="l02002"></a>02002         fp-&gt;fsize = fp-&gt;fptr;
<a name="l02003"></a>02003         fp-&gt;flag |= FA__WRITTEN;
<a name="l02004"></a>02004     }
<a name="l02005"></a>02005 <span class="preprocessor">#endif</span>
<a name="l02006"></a>02006 <span class="preprocessor"></span>
<a name="l02007"></a>02007     LEAVE_FF(fp-&gt;fs, res);
<a name="l02008"></a>02008 }
<a name="l02009"></a>02009 
<a name="l02010"></a>02010 
<a name="l02011"></a>02011 
<a name="l02012"></a>02012 
<a name="l02013"></a>02013 <span class="preprocessor">#if _FS_MINIMIZE &lt;= 1</span>
<a name="l02014"></a>02014 <span class="preprocessor"></span><span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02015"></a>02015 <span class="comment">/* Create a Directroy Object                                             */</span>
<a name="l02016"></a>02016 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02017"></a>02017 
<a name="l02018"></a>02018 FRESULT f_opendir (
<a name="l02019"></a>02019     DIR *dj,            <span class="comment">/* Pointer to directory object to create */</span>
<a name="l02020"></a>02020     <span class="keyword">const</span> <span class="keywordtype">char</span> *path    <span class="comment">/* Pointer to the directory path */</span>
<a name="l02021"></a>02021 )
<a name="l02022"></a>02022 {
<a name="l02023"></a>02023     FRESULT res;
<a name="l02024"></a>02024     NAMEBUF(sfn, lfn);
<a name="l02025"></a>02025     BYTE *dir;
<a name="l02026"></a>02026 
<a name="l02027"></a>02027 
<a name="l02028"></a>02028     res = auto_mount(&amp;path, &amp;dj-&gt;fs, 0);
<a name="l02029"></a>02029     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02030"></a>02030         INITBUF((*dj), sfn, lfn);
<a name="l02031"></a>02031         res = follow_path(dj, path);            <span class="comment">/* Follow the path to the directory */</span>
<a name="l02032"></a>02032         <span class="keywordflow">if</span> (res == FR_OK) {                     <span class="comment">/* Follow completed */</span>
<a name="l02033"></a>02033             dir = dj-&gt;dir;
<a name="l02034"></a>02034             <span class="keywordflow">if</span> (dir) {                          <span class="comment">/* It is not the root dir */</span>
<a name="l02035"></a>02035                 <span class="keywordflow">if</span> (dir[DIR_Attr] &amp; AM_DIR) {   <span class="comment">/* The object is a directory */</span>
<a name="l02036"></a>02036                     dj-&gt;sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
<a name="l02037"></a>02037                 } <span class="keywordflow">else</span> {                        <span class="comment">/* The object is not a directory */</span>
<a name="l02038"></a>02038                     res = FR_NO_PATH;
<a name="l02039"></a>02039                 }
<a name="l02040"></a>02040             } <span class="keywordflow">else</span> {                            <span class="comment">/* It is the root dir */</span>
<a name="l02041"></a>02041                 dj-&gt;sclust = (dj-&gt;fs-&gt;fs_type == FS_FAT32) ? dj-&gt;fs-&gt;dirbase : 0;
<a name="l02042"></a>02042             }
<a name="l02043"></a>02043             <span class="keywordflow">if</span> (res == FR_OK) res = dir_seek(dj, 0);
<a name="l02044"></a>02044             dj-&gt;id = dj-&gt;fs-&gt;id;
<a name="l02045"></a>02045         } <span class="keywordflow">else</span> {
<a name="l02046"></a>02046             <span class="keywordflow">if</span> (res == FR_NO_FILE) res = FR_NO_PATH;
<a name="l02047"></a>02047         }
<a name="l02048"></a>02048     }
<a name="l02049"></a>02049 
<a name="l02050"></a>02050     LEAVE_FF(dj-&gt;fs, res);
<a name="l02051"></a>02051 }
<a name="l02052"></a>02052 
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 
<a name="l02055"></a>02055 
<a name="l02056"></a>02056 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02057"></a>02057 <span class="comment">/* Read Directory Entry in Sequense                                      */</span>
<a name="l02058"></a>02058 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 FRESULT f_readdir (
<a name="l02061"></a>02061     DIR *dj,            <span class="comment">/* Pointer to the open directory object */</span>
<a name="l02062"></a>02062     FILINFO *fno        <span class="comment">/* Pointer to file information to return */</span>
<a name="l02063"></a>02063 )
<a name="l02064"></a>02064 {
<a name="l02065"></a>02065     FRESULT res;
<a name="l02066"></a>02066     NAMEBUF(sfn, lfn);
<a name="l02067"></a>02067 
<a name="l02068"></a>02068 
<a name="l02069"></a>02069     res = validate(dj-&gt;fs, dj-&gt;id);         <span class="comment">/* Check validity of the object */</span>
<a name="l02070"></a>02070     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02071"></a>02071         INITBUF((*dj), sfn, lfn);
<a name="l02072"></a>02072         <span class="keywordflow">if</span> (!fno) {
<a name="l02073"></a>02073             res = dir_seek(dj, 0);
<a name="l02074"></a>02074         } <span class="keywordflow">else</span> {
<a name="l02075"></a>02075             res = dir_read(dj);
<a name="l02076"></a>02076             <span class="keywordflow">if</span> (res == FR_NO_FILE) {
<a name="l02077"></a>02077                 dj-&gt;sect = 0;
<a name="l02078"></a>02078                 res = FR_OK;
<a name="l02079"></a>02079             }
<a name="l02080"></a>02080             <span class="keywordflow">if</span> (res == FR_OK) {             <span class="comment">/* A valid entry is found */</span>
<a name="l02081"></a>02081                 get_fileinfo(dj, fno);      <span class="comment">/* Get the object information */</span>
<a name="l02082"></a>02082                 res = dir_next(dj, FALSE);  <span class="comment">/* Increment index for next */</span>
<a name="l02083"></a>02083                 <span class="keywordflow">if</span> (res == FR_NO_FILE) {
<a name="l02084"></a>02084                     dj-&gt;sect = 0;
<a name="l02085"></a>02085                     res = FR_OK;
<a name="l02086"></a>02086                 }
<a name="l02087"></a>02087             }
<a name="l02088"></a>02088         }
<a name="l02089"></a>02089     }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091     LEAVE_FF(dj-&gt;fs, res);
<a name="l02092"></a>02092 }
<a name="l02093"></a>02093 
<a name="l02094"></a>02094 
<a name="l02095"></a>02095 
<a name="l02096"></a>02096 <span class="preprocessor">#if _FS_MINIMIZE == 0</span>
<a name="l02097"></a>02097 <span class="preprocessor"></span><span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02098"></a>02098 <span class="comment">/* Get File Status                                                       */</span>
<a name="l02099"></a>02099 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02100"></a>02100 
<a name="l02101"></a>02101 FRESULT f_stat (
<a name="l02102"></a>02102     <span class="keyword">const</span> <span class="keywordtype">char</span> *path,   <span class="comment">/* Pointer to the file path */</span>
<a name="l02103"></a>02103     FILINFO *fno        <span class="comment">/* Pointer to file information to return */</span>
<a name="l02104"></a>02104 )
<a name="l02105"></a>02105 {
<a name="l02106"></a>02106     FRESULT res;
<a name="l02107"></a>02107     DIR dj;
<a name="l02108"></a>02108     NAMEBUF(sfn, lfn);
<a name="l02109"></a>02109 
<a name="l02110"></a>02110 
<a name="l02111"></a>02111     res = auto_mount(&amp;path, &amp;dj.fs, 0);
<a name="l02112"></a>02112     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02113"></a>02113         INITBUF(dj, sfn, lfn);
<a name="l02114"></a>02114         res = follow_path(&amp;dj, path);   <span class="comment">/* Follow the file path */</span>
<a name="l02115"></a>02115         <span class="keywordflow">if</span> (res == FR_OK) {             <span class="comment">/* Follwo completed */</span>
<a name="l02116"></a>02116             <span class="keywordflow">if</span> (dj.dir) <span class="comment">/* Found an object */</span>
<a name="l02117"></a>02117                 get_fileinfo(&amp;dj, fno);
<a name="l02118"></a>02118             <span class="keywordflow">else</span>        <span class="comment">/* It is root dir */</span>
<a name="l02119"></a>02119                 res = FR_INVALID_NAME;
<a name="l02120"></a>02120         }
<a name="l02121"></a>02121     }
<a name="l02122"></a>02122 
<a name="l02123"></a>02123     LEAVE_FF(dj.fs, res);
<a name="l02124"></a>02124 }
<a name="l02125"></a>02125 
<a name="l02126"></a>02126 
<a name="l02127"></a>02127 
<a name="l02128"></a>02128 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l02129"></a>02129 <span class="preprocessor"></span><span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02130"></a>02130 <span class="comment">/* Truncate File                                                         */</span>
<a name="l02131"></a>02131 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02132"></a>02132 
<a name="l02133"></a>02133 FRESULT f_truncate (
<a name="l02134"></a>02134     FIL *fp     <span class="comment">/* Pointer to the file object */</span>
<a name="l02135"></a>02135 )
<a name="l02136"></a>02136 {
<a name="l02137"></a>02137     FRESULT res;
<a name="l02138"></a>02138     DWORD ncl;
<a name="l02139"></a>02139 
<a name="l02140"></a>02140 
<a name="l02141"></a>02141     res = validate(fp-&gt;fs, fp-&gt;id);     <span class="comment">/* Check validity of the object */</span>
<a name="l02142"></a>02142     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
<a name="l02143"></a>02143     <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__ERROR)           <span class="comment">/* Check abort flag */</span>
<a name="l02144"></a>02144         LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
<a name="l02145"></a>02145     <span class="keywordflow">if</span> (!(fp-&gt;flag &amp; FA_WRITE))         <span class="comment">/* Check access mode */</span>
<a name="l02146"></a>02146         LEAVE_FF(fp-&gt;fs, FR_DENIED);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148     <span class="keywordflow">if</span> (fp-&gt;fsize &gt; fp-&gt;fptr) {
<a name="l02149"></a>02149         fp-&gt;fsize = fp-&gt;fptr;   <span class="comment">/* Set file size to current R/W point */</span>
<a name="l02150"></a>02150         fp-&gt;flag |= FA__WRITTEN;
<a name="l02151"></a>02151         <span class="keywordflow">if</span> (fp-&gt;fptr == 0) {    <span class="comment">/* When set file size to zero, remove entire cluster chain */</span>
<a name="l02152"></a>02152             res = remove_chain(fp-&gt;fs, fp-&gt;org_clust);
<a name="l02153"></a>02153             fp-&gt;org_clust = 0;
<a name="l02154"></a>02154         } <span class="keywordflow">else</span> {                <span class="comment">/* When truncate a part of the file, remove remaining clusters */</span>
<a name="l02155"></a>02155             ncl = get_cluster(fp-&gt;fs, fp-&gt;curr_clust);
<a name="l02156"></a>02156             res = FR_OK;
<a name="l02157"></a>02157             <span class="keywordflow">if</span> (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
<a name="l02158"></a>02158             <span class="keywordflow">if</span> (ncl == 1) res = FR_INT_ERR;
<a name="l02159"></a>02159             <span class="keywordflow">if</span> (res == FR_OK &amp;&amp; ncl &lt; fp-&gt;fs-&gt;max_clust) {
<a name="l02160"></a>02160                 res = put_cluster(fp-&gt;fs, fp-&gt;curr_clust, 0x0FFFFFFF);
<a name="l02161"></a>02161                 <span class="keywordflow">if</span> (res == FR_OK) res = remove_chain(fp-&gt;fs, ncl);
<a name="l02162"></a>02162             }
<a name="l02163"></a>02163         }
<a name="l02164"></a>02164     }
<a name="l02165"></a>02165     <span class="keywordflow">if</span> (res != FR_OK) fp-&gt;flag |= FA__ERROR;
<a name="l02166"></a>02166 
<a name="l02167"></a>02167     LEAVE_FF(fp-&gt;fs, res);
<a name="l02168"></a>02168 }
<a name="l02169"></a>02169 
<a name="l02170"></a>02170 
<a name="l02171"></a>02171 
<a name="l02172"></a>02172 
<a name="l02173"></a>02173 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02174"></a>02174 <span class="comment">/* Get Number of Free Clusters                                           */</span>
<a name="l02175"></a>02175 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02176"></a>02176 
<a name="l02177"></a>02177 FRESULT f_getfree (
<a name="l02178"></a>02178     <span class="keyword">const</span> <span class="keywordtype">char</span> *path,   <span class="comment">/* Pointer to the logical drive number (root dir) */</span>
<a name="l02179"></a>02179     DWORD *nclst,       <span class="comment">/* Pointer to the variable to return number of free clusters */</span>
<a name="l02180"></a>02180     FATFS **fatfs       <span class="comment">/* Pointer to pointer to corresponding file system object to return */</span>
<a name="l02181"></a>02181 )
<a name="l02182"></a>02182 {
<a name="l02183"></a>02183     FRESULT res;
<a name="l02184"></a>02184     DWORD n, clst, sect;
<a name="l02185"></a>02185     BYTE fat, f, *p;
<a name="l02186"></a>02186 
<a name="l02187"></a>02187 
<a name="l02188"></a>02188     <span class="comment">/* Get drive number */</span>
<a name="l02189"></a>02189     res = auto_mount(&amp;path, fatfs, 0);
<a name="l02190"></a>02190     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(*fatfs, res);
<a name="l02191"></a>02191 
<a name="l02192"></a>02192     <span class="comment">/* If number of free cluster is valid, return it without cluster scan. */</span>
<a name="l02193"></a>02193     <span class="keywordflow">if</span> ((*fatfs)-&gt;free_clust &lt;= (*fatfs)-&gt;max_clust - 2) {
<a name="l02194"></a>02194         *nclst = (*fatfs)-&gt;free_clust;
<a name="l02195"></a>02195         LEAVE_FF(*fatfs, FR_OK);
<a name="l02196"></a>02196     }
<a name="l02197"></a>02197 
<a name="l02198"></a>02198     <span class="comment">/* Get number of free clusters */</span>
<a name="l02199"></a>02199     fat = (*fatfs)-&gt;fs_type;
<a name="l02200"></a>02200     n = 0;
<a name="l02201"></a>02201     <span class="keywordflow">if</span> (fat == FS_FAT12) {
<a name="l02202"></a>02202         clst = 2;
<a name="l02203"></a>02203         <span class="keywordflow">do</span> {
<a name="l02204"></a>02204             <span class="keywordflow">if</span> ((WORD)get_cluster(*fatfs, clst) == 0) n++;
<a name="l02205"></a>02205         } <span class="keywordflow">while</span> (++clst &lt; (*fatfs)-&gt;max_clust);
<a name="l02206"></a>02206     } <span class="keywordflow">else</span> {
<a name="l02207"></a>02207         clst = (*fatfs)-&gt;max_clust;
<a name="l02208"></a>02208         sect = (*fatfs)-&gt;fatbase;
<a name="l02209"></a>02209         f = 0; p = 0;
<a name="l02210"></a>02210         <span class="keywordflow">do</span> {
<a name="l02211"></a>02211             <span class="keywordflow">if</span> (!f) {
<a name="l02212"></a>02212                 res = move_window(*fatfs, sect++);
<a name="l02213"></a>02213                 <span class="keywordflow">if</span> (res != FR_OK)
<a name="l02214"></a>02214                     LEAVE_FF(*fatfs, res);
<a name="l02215"></a>02215                 p = (*fatfs)-&gt;win;
<a name="l02216"></a>02216             }
<a name="l02217"></a>02217             <span class="keywordflow">if</span> (fat == FS_FAT16) {
<a name="l02218"></a>02218                 <span class="keywordflow">if</span> (LD_WORD(p) == 0) n++;
<a name="l02219"></a>02219                 p += 2; f += 1;
<a name="l02220"></a>02220             } <span class="keywordflow">else</span> {
<a name="l02221"></a>02221                 <span class="keywordflow">if</span> (LD_DWORD(p) == 0) n++;
<a name="l02222"></a>02222                 p += 4; f += 2;
<a name="l02223"></a>02223             }
<a name="l02224"></a>02224         } <span class="keywordflow">while</span> (--clst);
<a name="l02225"></a>02225     }
<a name="l02226"></a>02226     (*fatfs)-&gt;free_clust = n;
<a name="l02227"></a>02227     <span class="keywordflow">if</span> (fat == FS_FAT32) (*fatfs)-&gt;fsi_flag = 1;
<a name="l02228"></a>02228     *nclst = n;
<a name="l02229"></a>02229 
<a name="l02230"></a>02230     LEAVE_FF(*fatfs, FR_OK);
<a name="l02231"></a>02231 }
<a name="l02232"></a>02232 
<a name="l02233"></a>02233 
<a name="l02234"></a>02234 
<a name="l02235"></a>02235 
<a name="l02236"></a>02236 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02237"></a>02237 <span class="comment">/* Delete a File or Directory                                            */</span>
<a name="l02238"></a>02238 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02239"></a>02239 
<a name="l02240"></a>02240 FRESULT f_unlink (
<a name="l02241"></a>02241     <span class="keyword">const</span> <span class="keywordtype">char</span> *path        <span class="comment">/* Pointer to the file or directory path */</span>
<a name="l02242"></a>02242 )
<a name="l02243"></a>02243 {
<a name="l02244"></a>02244     FRESULT res;
<a name="l02245"></a>02245     DIR dj, sdj;
<a name="l02246"></a>02246     NAMEBUF(sfn, lfn);
<a name="l02247"></a>02247     BYTE *dir;
<a name="l02248"></a>02248     DWORD dclst;
<a name="l02249"></a>02249 
<a name="l02250"></a>02250 
<a name="l02251"></a>02251     res = auto_mount(&amp;path, &amp;dj.fs, 1);
<a name="l02252"></a>02252     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res);
<a name="l02253"></a>02253 
<a name="l02254"></a>02254     INITBUF(dj, sfn, lfn);
<a name="l02255"></a>02255     res = follow_path(&amp;dj, path);           <span class="comment">/* Follow the file path */</span>
<a name="l02256"></a>02256     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res); <span class="comment">/* Follow failed */</span>
<a name="l02257"></a>02257 
<a name="l02258"></a>02258     dir = dj.dir;
<a name="l02259"></a>02259     <span class="keywordflow">if</span> (!dir)                               <span class="comment">/* Is it the root directory? */</span>
<a name="l02260"></a>02260         LEAVE_FF(dj.fs, FR_INVALID_NAME);
<a name="l02261"></a>02261     <span class="keywordflow">if</span> (dir[DIR_Attr] &amp; AM_RDO)             <span class="comment">/* Is it a R/O object? */</span>
<a name="l02262"></a>02262         LEAVE_FF(dj.fs, FR_DENIED);
<a name="l02263"></a>02263     dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
<a name="l02264"></a>02264 
<a name="l02265"></a>02265     <span class="keywordflow">if</span> (dir[DIR_Attr] &amp; AM_DIR) {           <span class="comment">/* It is a sub-directory */</span>
<a name="l02266"></a>02266         <span class="keywordflow">if</span> (dclst &lt; 2) LEAVE_FF(dj.fs, FR_INT_ERR);
<a name="l02267"></a>02267         mem_cpy(&amp;sdj, &amp;dj, <span class="keyword">sizeof</span>(DIR));        <span class="comment">/* Check if the sub-dir is empty or not */</span>
<a name="l02268"></a>02268         sdj.sclust = dclst;
<a name="l02269"></a>02269         res = dir_seek(&amp;sdj, 0);
<a name="l02270"></a>02270         <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res);
<a name="l02271"></a>02271         res = dir_read(&amp;sdj);
<a name="l02272"></a>02272         <span class="keywordflow">if</span> (res == FR_OK) res = FR_DENIED;  <span class="comment">/* Not empty sub-dir */</span>
<a name="l02273"></a>02273         <span class="keywordflow">if</span> (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
<a name="l02274"></a>02274     }
<a name="l02275"></a>02275 
<a name="l02276"></a>02276     res = dir_remove(&amp;dj);                  <span class="comment">/* Remove directory entry */</span>
<a name="l02277"></a>02277     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02278"></a>02278         <span class="keywordflow">if</span> (dclst)
<a name="l02279"></a>02279             res = remove_chain(dj.fs, dclst);   <span class="comment">/* Remove the cluster chain */</span>
<a name="l02280"></a>02280         <span class="keywordflow">if</span> (res == FR_OK) res = sync(dj.fs);
<a name="l02281"></a>02281     }
<a name="l02282"></a>02282 
<a name="l02283"></a>02283     LEAVE_FF(dj.fs, res);
<a name="l02284"></a>02284 }
<a name="l02285"></a>02285 
<a name="l02286"></a>02286 
<a name="l02287"></a>02287 
<a name="l02288"></a>02288 
<a name="l02289"></a>02289 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02290"></a>02290 <span class="comment">/* Create a Directory                                                    */</span>
<a name="l02291"></a>02291 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02292"></a>02292 
<a name="l02293"></a>02293 FRESULT f_mkdir (
<a name="l02294"></a>02294     <span class="keyword">const</span> <span class="keywordtype">char</span> *path        <span class="comment">/* Pointer to the directory path */</span>
<a name="l02295"></a>02295 )
<a name="l02296"></a>02296 {
<a name="l02297"></a>02297     FRESULT res;
<a name="l02298"></a>02298     DIR dj;
<a name="l02299"></a>02299     NAMEBUF(sfn, lfn);
<a name="l02300"></a>02300     BYTE *dir, n;
<a name="l02301"></a>02301     DWORD dsect, dclst, pclst, tim;
<a name="l02302"></a>02302 
<a name="l02303"></a>02303 
<a name="l02304"></a>02304     res = auto_mount(&amp;path, &amp;dj.fs, 1);
<a name="l02305"></a>02305     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res);
<a name="l02306"></a>02306 
<a name="l02307"></a>02307     INITBUF(dj, sfn, lfn);
<a name="l02308"></a>02308     res = follow_path(&amp;dj, path);           <span class="comment">/* Follow the file path */</span>
<a name="l02309"></a>02309     <span class="keywordflow">if</span> (res == FR_OK) res = FR_EXIST;       <span class="comment">/* Any file or directory is already existing */</span>
<a name="l02310"></a>02310     <span class="keywordflow">if</span> (res != FR_NO_FILE)                  <span class="comment">/* Any error occured */</span>
<a name="l02311"></a>02311         LEAVE_FF(dj.fs, res);
<a name="l02312"></a>02312 
<a name="l02313"></a>02313     dclst = create_chain(dj.fs, 0);         <span class="comment">/* Allocate a new cluster for new directory table */</span>
<a name="l02314"></a>02314     res = FR_OK;
<a name="l02315"></a>02315     <span class="keywordflow">if</span> (dclst == 0) res = FR_DENIED;
<a name="l02316"></a>02316     <span class="keywordflow">if</span> (dclst == 1) res = FR_INT_ERR;
<a name="l02317"></a>02317     <span class="keywordflow">if</span> (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
<a name="l02318"></a>02318     <span class="keywordflow">if</span> (res == FR_OK)
<a name="l02319"></a>02319         res = move_window(dj.fs, 0);
<a name="l02320"></a>02320     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj.fs, res);
<a name="l02321"></a>02321     dsect = clust2sect(dj.fs, dclst);
<a name="l02322"></a>02322 
<a name="l02323"></a>02323     dir = dj.fs-&gt;win;                       <span class="comment">/* Initialize the new directory table */</span>
<a name="l02324"></a>02324     mem_set(dir, 0, SS(dj.fs));
<a name="l02325"></a>02325     mem_set(dir+DIR_Name, <span class="charliteral">&#39; &#39;</span>, 8+3);        <span class="comment">/* Create &quot;.&quot; entry */</span>
<a name="l02326"></a>02326     dir[DIR_Name] = <span class="charliteral">&#39;.&#39;</span>;
<a name="l02327"></a>02327     dir[DIR_Attr] = AM_DIR;
<a name="l02328"></a>02328     tim = get_fattime();
<a name="l02329"></a>02329     ST_DWORD(dir+DIR_WrtTime, tim);
<a name="l02330"></a>02330     ST_WORD(dir+DIR_FstClusLO, dclst);
<a name="l02331"></a>02331     ST_WORD(dir+DIR_FstClusHI, dclst &gt;&gt; 16);
<a name="l02332"></a>02332     mem_cpy(dir+32, dir, 32);           <span class="comment">/* Create &quot;..&quot; entry */</span>
<a name="l02333"></a>02333     dir[33] = <span class="charliteral">&#39;.&#39;</span>;
<a name="l02334"></a>02334     pclst = dj.sclust;
<a name="l02335"></a>02335     <span class="keywordflow">if</span> (dj.fs-&gt;fs_type == FS_FAT32 &amp;&amp; pclst == dj.fs-&gt;dirbase)
<a name="l02336"></a>02336         pclst = 0;
<a name="l02337"></a>02337     ST_WORD(dir+32+DIR_FstClusLO, pclst);
<a name="l02338"></a>02338     ST_WORD(dir+32+DIR_FstClusHI, pclst &gt;&gt; 16);
<a name="l02339"></a>02339     <span class="keywordflow">for</span> (n = 0; n &lt; dj.fs-&gt;csize; n++) {    <span class="comment">/* Write dot entries and clear left sectors */</span>
<a name="l02340"></a>02340         dj.fs-&gt;winsect = dsect++;
<a name="l02341"></a>02341         dj.fs-&gt;wflag = 1;
<a name="l02342"></a>02342         res = move_window(dj.fs, 0);
<a name="l02343"></a>02343         <span class="keywordflow">if</span> (res) LEAVE_FF(dj.fs, res);
<a name="l02344"></a>02344         mem_set(dir, 0, SS(dj.fs));
<a name="l02345"></a>02345     }
<a name="l02346"></a>02346 
<a name="l02347"></a>02347     res = dir_register(&amp;dj);
<a name="l02348"></a>02348     <span class="keywordflow">if</span> (res != FR_OK) {
<a name="l02349"></a>02349         remove_chain(dj.fs, dclst);
<a name="l02350"></a>02350     } <span class="keywordflow">else</span> {
<a name="l02351"></a>02351         dir = dj.dir;
<a name="l02352"></a>02352         dir[DIR_Attr] = AM_DIR;                 <span class="comment">/* Attribute */</span>
<a name="l02353"></a>02353         ST_DWORD(dir+DIR_WrtTime, tim);         <span class="comment">/* Crated time */</span>
<a name="l02354"></a>02354         ST_WORD(dir+DIR_FstClusLO, dclst);      <span class="comment">/* Table start cluster */</span>
<a name="l02355"></a>02355         ST_WORD(dir+DIR_FstClusHI, dclst &gt;&gt; 16);
<a name="l02356"></a>02356         dj.fs-&gt;wflag = 1;
<a name="l02357"></a>02357         res = sync(dj.fs);
<a name="l02358"></a>02358     }
<a name="l02359"></a>02359 
<a name="l02360"></a>02360     LEAVE_FF(dj.fs, res);
<a name="l02361"></a>02361 }
<a name="l02362"></a>02362 
<a name="l02363"></a>02363 
<a name="l02364"></a>02364 
<a name="l02365"></a>02365 
<a name="l02366"></a>02366 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02367"></a>02367 <span class="comment">/* Change File Attribute                                                 */</span>
<a name="l02368"></a>02368 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02369"></a>02369 
<a name="l02370"></a>02370 FRESULT f_chmod (
<a name="l02371"></a>02371     <span class="keyword">const</span> <span class="keywordtype">char</span> *path,   <span class="comment">/* Pointer to the file path */</span>
<a name="l02372"></a>02372     BYTE value,         <span class="comment">/* Attribute bits */</span>
<a name="l02373"></a>02373     BYTE mask           <span class="comment">/* Attribute mask to change */</span>
<a name="l02374"></a>02374 )
<a name="l02375"></a>02375 {
<a name="l02376"></a>02376     FRESULT res;
<a name="l02377"></a>02377     DIR dj;
<a name="l02378"></a>02378     NAMEBUF(sfn, lfn);
<a name="l02379"></a>02379     BYTE *dir;
<a name="l02380"></a>02380 
<a name="l02381"></a>02381 
<a name="l02382"></a>02382     res = auto_mount(&amp;path, &amp;dj.fs, 1);
<a name="l02383"></a>02383     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02384"></a>02384         INITBUF(dj, sfn, lfn);
<a name="l02385"></a>02385         res = follow_path(&amp;dj, path);       <span class="comment">/* Follow the file path */</span>
<a name="l02386"></a>02386         <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02387"></a>02387             dir = dj.dir;
<a name="l02388"></a>02388             <span class="keywordflow">if</span> (!dir) {                     <span class="comment">/* Is it a root directory? */</span>
<a name="l02389"></a>02389                 res = FR_INVALID_NAME;
<a name="l02390"></a>02390             } <span class="keywordflow">else</span> {                        <span class="comment">/* File or sub directory */</span>
<a name="l02391"></a>02391                 mask &amp;= AM_RDO|AM_HID|AM_SYS|AM_ARC;    <span class="comment">/* Valid attribute mask */</span>
<a name="l02392"></a>02392                 dir[DIR_Attr] = (value &amp; mask) | (dir[DIR_Attr] &amp; (BYTE)~mask); <span class="comment">/* Apply attribute change */</span>
<a name="l02393"></a>02393                 dj.fs-&gt;wflag = 1;
<a name="l02394"></a>02394                 res = sync(dj.fs);
<a name="l02395"></a>02395             }
<a name="l02396"></a>02396         }
<a name="l02397"></a>02397     }
<a name="l02398"></a>02398 
<a name="l02399"></a>02399     LEAVE_FF(dj.fs, res);
<a name="l02400"></a>02400 }
<a name="l02401"></a>02401 
<a name="l02402"></a>02402 
<a name="l02403"></a>02403 
<a name="l02404"></a>02404 
<a name="l02405"></a>02405 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02406"></a>02406 <span class="comment">/* Change Timestamp                                                      */</span>
<a name="l02407"></a>02407 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02408"></a>02408 
<a name="l02409"></a>02409 FRESULT f_utime (
<a name="l02410"></a>02410     <span class="keyword">const</span> <span class="keywordtype">char</span> *path,   <span class="comment">/* Pointer to the file/directory name */</span>
<a name="l02411"></a>02411     <span class="keyword">const</span> FILINFO *fno  <span class="comment">/* Pointer to the timestamp to be set */</span>
<a name="l02412"></a>02412 )
<a name="l02413"></a>02413 {
<a name="l02414"></a>02414     FRESULT res;
<a name="l02415"></a>02415     DIR dj;
<a name="l02416"></a>02416     NAMEBUF(sfn, lfn);
<a name="l02417"></a>02417     BYTE *dir;
<a name="l02418"></a>02418 
<a name="l02419"></a>02419 
<a name="l02420"></a>02420     res = auto_mount(&amp;path, &amp;dj.fs, 1);
<a name="l02421"></a>02421     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02422"></a>02422         INITBUF(dj, sfn, lfn);
<a name="l02423"></a>02423         res = follow_path(&amp;dj, path);   <span class="comment">/* Follow the file path */</span>
<a name="l02424"></a>02424         <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02425"></a>02425             dir = dj.dir;
<a name="l02426"></a>02426             <span class="keywordflow">if</span> (!dir) {             <span class="comment">/* Root directory */</span>
<a name="l02427"></a>02427                 res = FR_INVALID_NAME;
<a name="l02428"></a>02428             } <span class="keywordflow">else</span> {                <span class="comment">/* File or sub-directory */</span>
<a name="l02429"></a>02429                 ST_WORD(dir+DIR_WrtTime, fno-&gt;ftime);
<a name="l02430"></a>02430                 ST_WORD(dir+DIR_WrtDate, fno-&gt;fdate);
<a name="l02431"></a>02431                 dj.fs-&gt;wflag = 1;
<a name="l02432"></a>02432                 res = sync(dj.fs);
<a name="l02433"></a>02433             }
<a name="l02434"></a>02434         }
<a name="l02435"></a>02435     }
<a name="l02436"></a>02436 
<a name="l02437"></a>02437     LEAVE_FF(dj.fs, res);
<a name="l02438"></a>02438 }
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 
<a name="l02441"></a>02441 
<a name="l02442"></a>02442 
<a name="l02443"></a>02443 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02444"></a>02444 <span class="comment">/* Rename File/Directory                                                 */</span>
<a name="l02445"></a>02445 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02446"></a>02446 
<a name="l02447"></a>02447 FRESULT f_rename (
<a name="l02448"></a>02448     <span class="keyword">const</span> <span class="keywordtype">char</span> *path_old,   <span class="comment">/* Pointer to the old name */</span>
<a name="l02449"></a>02449     <span class="keyword">const</span> <span class="keywordtype">char</span> *path_new    <span class="comment">/* Pointer to the new name */</span>
<a name="l02450"></a>02450 )
<a name="l02451"></a>02451 {
<a name="l02452"></a>02452     FRESULT res;
<a name="l02453"></a>02453     DIR dj_old, dj_new;
<a name="l02454"></a>02454     NAMEBUF(sfn, lfn);
<a name="l02455"></a>02455     BYTE buf[21], *dir;
<a name="l02456"></a>02456     DWORD dw;
<a name="l02457"></a>02457 
<a name="l02458"></a>02458 
<a name="l02459"></a>02459     INITBUF(dj_old, sfn, lfn);
<a name="l02460"></a>02460     res = auto_mount(&amp;path_old, &amp;dj_old.fs, 1);
<a name="l02461"></a>02461     <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02462"></a>02462         dj_new.fs = dj_old.fs;
<a name="l02463"></a>02463         res = follow_path(&amp;dj_old, path_old);   <span class="comment">/* Check old object */</span>
<a name="l02464"></a>02464     }
<a name="l02465"></a>02465     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(dj_old.fs, res); <span class="comment">/* The old object is not found */</span>
<a name="l02466"></a>02466 
<a name="l02467"></a>02467     <span class="keywordflow">if</span> (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);   <span class="comment">/* Is root dir? */</span>
<a name="l02468"></a>02468     mem_cpy(buf, dj_old.dir+DIR_Attr, 21);      <span class="comment">/* Save the object information */</span>
<a name="l02469"></a>02469 
<a name="l02470"></a>02470     mem_cpy(&amp;dj_new, &amp;dj_old, <span class="keyword">sizeof</span>(DIR));
<a name="l02471"></a>02471     res = follow_path(&amp;dj_new, path_new);       <span class="comment">/* Check new object */</span>
<a name="l02472"></a>02472     <span class="keywordflow">if</span> (res == FR_OK) res = FR_EXIST;           <span class="comment">/* The new object name is already existing */</span>
<a name="l02473"></a>02473     <span class="keywordflow">if</span> (res == FR_NO_FILE) {                    <span class="comment">/* Is it a valid path and no name collision? */</span>
<a name="l02474"></a>02474         res = dir_register(&amp;dj_new);            <span class="comment">/* Register the new object */</span>
<a name="l02475"></a>02475         <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02476"></a>02476             dir = dj_new.dir;                   <span class="comment">/* Copy object information into new entry */</span>
<a name="l02477"></a>02477             mem_cpy(dir+13, buf+2, 19);
<a name="l02478"></a>02478             dir[DIR_Attr] = buf[0];
<a name="l02479"></a>02479             dj_old.fs-&gt;wflag = 1;
<a name="l02480"></a>02480             <span class="keywordflow">if</span> (dir[DIR_Attr] &amp; AM_DIR) {       <span class="comment">/* Update .. entry in the directory if needed */</span>
<a name="l02481"></a>02481                 dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
<a name="l02482"></a>02482                 <span class="keywordflow">if</span> (!dw) {
<a name="l02483"></a>02483                     res = FR_INT_ERR;
<a name="l02484"></a>02484                 } <span class="keywordflow">else</span> {
<a name="l02485"></a>02485                     res = move_window(dj_new.fs, dw);
<a name="l02486"></a>02486                     dir = dj_new.fs-&gt;win+32;
<a name="l02487"></a>02487                     <span class="keywordflow">if</span> (res == FR_OK &amp;&amp; dir[1] == <span class="charliteral">&#39;.&#39;</span>) {
<a name="l02488"></a>02488                         dw = (dj_new.fs-&gt;fs_type == FS_FAT32 &amp;&amp; dj_new.sclust == dj_new.fs-&gt;dirbase) ? 0 : dj_new.sclust;
<a name="l02489"></a>02489                         ST_WORD(dir+DIR_FstClusLO, dw);
<a name="l02490"></a>02490                         ST_WORD(dir+DIR_FstClusHI, dw &gt;&gt; 16);
<a name="l02491"></a>02491                         dj_new.fs-&gt;wflag = 1;
<a name="l02492"></a>02492                     }
<a name="l02493"></a>02493                 }
<a name="l02494"></a>02494             }
<a name="l02495"></a>02495             <span class="keywordflow">if</span> (res == FR_OK) {
<a name="l02496"></a>02496                 res = dir_remove(&amp;dj_old);          <span class="comment">/* Remove old entry */</span>
<a name="l02497"></a>02497                 <span class="keywordflow">if</span> (res == FR_OK)
<a name="l02498"></a>02498                     res = sync(dj_old.fs);
<a name="l02499"></a>02499             }
<a name="l02500"></a>02500         }
<a name="l02501"></a>02501     }
<a name="l02502"></a>02502 
<a name="l02503"></a>02503     LEAVE_FF(dj_old.fs, res);
<a name="l02504"></a>02504 }
<a name="l02505"></a>02505 
<a name="l02506"></a>02506 <span class="preprocessor">#endif </span><span class="comment">/* !_FS_READONLY */</span>
<a name="l02507"></a>02507 <span class="preprocessor">#endif </span><span class="comment">/* _FS_MINIMIZE == 0 */</span>
<a name="l02508"></a>02508 <span class="preprocessor">#endif </span><span class="comment">/* _FS_MINIMIZE &lt;= 1 */</span>
<a name="l02509"></a>02509 <span class="preprocessor">#endif </span><span class="comment">/* _FS_MINIMIZE &lt;= 2 */</span>
<a name="l02510"></a>02510 
<a name="l02511"></a>02511 
<a name="l02512"></a>02512 
<a name="l02513"></a>02513 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02514"></a>02514 <span class="comment">/* Forward data to the stream directly (Available on only _FS_TINY cfg)  */</span>
<a name="l02515"></a>02515 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02516"></a>02516 <span class="preprocessor">#if _USE_FORWARD &amp;&amp; _FS_TINY</span>
<a name="l02517"></a>02517 <span class="preprocessor"></span>
<a name="l02518"></a>02518 FRESULT f_forward (
<a name="l02519"></a>02519     FIL *fp,                        <span class="comment">/* Pointer to the file object */</span>
<a name="l02520"></a>02520     UINT (*func)(<span class="keyword">const</span> BYTE*,UINT), <span class="comment">/* Pointer to the streaming function */</span>
<a name="l02521"></a>02521     UINT btr,                       <span class="comment">/* Number of bytes to forward */</span>
<a name="l02522"></a>02522     UINT *bf                        <span class="comment">/* Pointer to number of bytes forwarded */</span>
<a name="l02523"></a>02523 )
<a name="l02524"></a>02524 {
<a name="l02525"></a>02525     FRESULT res;
<a name="l02526"></a>02526     DWORD remain, clst, sect;
<a name="l02527"></a>02527     UINT rcnt;
<a name="l02528"></a>02528 
<a name="l02529"></a>02529 
<a name="l02530"></a>02530     *bf = 0;
<a name="l02531"></a>02531 
<a name="l02532"></a>02532     res = validate(fp-&gt;fs, fp-&gt;id);                 <span class="comment">/* Check validity of the object */</span>
<a name="l02533"></a>02533     <span class="keywordflow">if</span> (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
<a name="l02534"></a>02534     <span class="keywordflow">if</span> (fp-&gt;flag &amp; FA__ERROR)                       <span class="comment">/* Check error flag */</span>
<a name="l02535"></a>02535         LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
<a name="l02536"></a>02536     <span class="keywordflow">if</span> (!(fp-&gt;flag &amp; FA_READ))                      <span class="comment">/* Check access mode */</span>
<a name="l02537"></a>02537         LEAVE_FF(fp-&gt;fs, FR_DENIED);
<a name="l02538"></a>02538 
<a name="l02539"></a>02539     remain = fp-&gt;fsize - fp-&gt;fptr;
<a name="l02540"></a>02540     <span class="keywordflow">if</span> (btr &gt; remain) btr = (UINT)remain;           <span class="comment">/* Truncate btr by remaining bytes */</span>
<a name="l02541"></a>02541 
<a name="l02542"></a>02542     <span class="keywordflow">for</span> ( ;  btr &amp;&amp; (*func)(NULL, 0);               <span class="comment">/* Repeat until all data transferred or stream becomes busy */</span>
<a name="l02543"></a>02543         fp-&gt;fptr += rcnt, *bf += rcnt, btr -= rcnt) {
<a name="l02544"></a>02544         <span class="keywordflow">if</span> ((fp-&gt;fptr % SS(fp-&gt;fs)) == 0) {         <span class="comment">/* On the sector boundary? */</span>
<a name="l02545"></a>02545             <span class="keywordflow">if</span> (fp-&gt;csect &gt;= fp-&gt;fs-&gt;csize) {       <span class="comment">/* On the cluster boundary? */</span>
<a name="l02546"></a>02546                 clst = (fp-&gt;fptr == 0) ?            <span class="comment">/* On the top of the file? */</span>
<a name="l02547"></a>02547                     fp-&gt;org_clust : get_cluster(fp-&gt;fs, fp-&gt;curr_clust);
<a name="l02548"></a>02548                 <span class="keywordflow">if</span> (clst &lt;= 1) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l02549"></a>02549                 <span class="keywordflow">if</span> (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l02550"></a>02550                 fp-&gt;curr_clust = clst;              <span class="comment">/* Update current cluster */</span>
<a name="l02551"></a>02551                 fp-&gt;csect = 0;                      <span class="comment">/* Reset sector address in the cluster */</span>
<a name="l02552"></a>02552             }
<a name="l02553"></a>02553             fp-&gt;csect++;                            <span class="comment">/* Next sector address in the cluster */</span>
<a name="l02554"></a>02554         }
<a name="l02555"></a>02555         sect = clust2sect(fp-&gt;fs, fp-&gt;curr_clust);  <span class="comment">/* Get current data sector */</span>
<a name="l02556"></a>02556         <span class="keywordflow">if</span> (!sect) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l02557"></a>02557         sect += fp-&gt;csect - 1;
<a name="l02558"></a>02558         <span class="keywordflow">if</span> (move_window(fp-&gt;fs, sect))              <span class="comment">/* Move sector window */</span>
<a name="l02559"></a>02559             ABORT(fp-&gt;fs, FR_DISK_ERR);
<a name="l02560"></a>02560         fp-&gt;dsect = sect;
<a name="l02561"></a>02561         rcnt = SS(fp-&gt;fs) - (WORD)(fp-&gt;fptr % SS(fp-&gt;fs));  <span class="comment">/* Forward data from sector window */</span>
<a name="l02562"></a>02562         <span class="keywordflow">if</span> (rcnt &gt; btr) rcnt = btr;
<a name="l02563"></a>02563         rcnt = (*func)(&amp;fp-&gt;fs-&gt;win[(WORD)fp-&gt;fptr % SS(fp-&gt;fs)], rcnt);
<a name="l02564"></a>02564         <span class="keywordflow">if</span> (!rcnt) ABORT(fp-&gt;fs, FR_INT_ERR);
<a name="l02565"></a>02565     }
<a name="l02566"></a>02566 
<a name="l02567"></a>02567     LEAVE_FF(fp-&gt;fs, FR_OK);
<a name="l02568"></a>02568 }
<a name="l02569"></a>02569 <span class="preprocessor">#endif </span><span class="comment">/* _USE_FORWARD */</span>
<a name="l02570"></a>02570 
<a name="l02571"></a>02571 
<a name="l02572"></a>02572 
<a name="l02573"></a>02573 <span class="preprocessor">#if _USE_MKFS &amp;&amp; !_FS_READONLY</span>
<a name="l02574"></a>02574 <span class="preprocessor"></span><span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02575"></a>02575 <span class="comment">/* Create File System on the Drive                                       */</span>
<a name="l02576"></a>02576 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02577"></a>02577 <span class="preprocessor">#define N_ROOTDIR   512         </span><span class="comment">/* Multiple of 32 and &lt;= 2048 */</span>
<a name="l02578"></a>02578 <span class="preprocessor">#define N_FATS      1           </span><span class="comment">/* 1 or 2 */</span>
<a name="l02579"></a>02579 <span class="preprocessor">#define MAX_SECTOR  131072000UL </span><span class="comment">/* Maximum partition size */</span>
<a name="l02580"></a>02580 <span class="preprocessor">#define MIN_SECTOR  2000UL      </span><span class="comment">/* Minimum partition size */</span>
<a name="l02581"></a>02581 
<a name="l02582"></a>02582 
<a name="l02583"></a>02583 FRESULT f_mkfs (
<a name="l02584"></a>02584     BYTE drv,           <span class="comment">/* Logical drive number */</span>
<a name="l02585"></a>02585     BYTE partition,     <span class="comment">/* Partitioning rule 0:FDISK, 1:SFD */</span>
<a name="l02586"></a>02586     WORD allocsize      <span class="comment">/* Allocation unit size [bytes] */</span>
<a name="l02587"></a>02587 )
<a name="l02588"></a>02588 {
<a name="l02589"></a>02589     <span class="keyword">static</span> <span class="keyword">const</span> DWORD sstbl[] = { 2048000, 1024000, 512000, 256000, 128000, 64000, 32000, 16000, 8000, 4000,   0 };
<a name="l02590"></a>02590     <span class="keyword">static</span> <span class="keyword">const</span> WORD cstbl[] =  {   32768,   16384,   8192,   4096,   2048, 16384,  8192,  4096, 2048, 1024, 512 };
<a name="l02591"></a>02591     BYTE fmt, m, *tbl;
<a name="l02592"></a>02592     DWORD b_part, b_fat, b_dir, b_data;     <span class="comment">/* Area offset (LBA) */</span>
<a name="l02593"></a>02593     DWORD n_part, n_rsv, n_fat, n_dir;      <span class="comment">/* Area size */</span>
<a name="l02594"></a>02594     DWORD n_clst, n;
<a name="l02595"></a>02595     WORD as;
<a name="l02596"></a>02596     FATFS *fs;
<a name="l02597"></a>02597     DSTATUS stat;
<a name="l02598"></a>02598 
<a name="l02599"></a>02599 
<a name="l02600"></a>02600     <span class="comment">/* Check validity of the parameters */</span>
<a name="l02601"></a>02601     <span class="keywordflow">if</span> (drv &gt;= _DRIVES) <span class="keywordflow">return</span> FR_INVALID_DRIVE;
<a name="l02602"></a>02602     <span class="keywordflow">if</span> (partition &gt;= 2) <span class="keywordflow">return</span> FR_MKFS_ABORTED;
<a name="l02603"></a>02603 
<a name="l02604"></a>02604     <span class="comment">/* Check mounted drive and clear work area */</span>
<a name="l02605"></a>02605     fs = FatFs[drv];
<a name="l02606"></a>02606     <span class="keywordflow">if</span> (!fs) <span class="keywordflow">return</span> FR_NOT_ENABLED;
<a name="l02607"></a>02607     fs-&gt;fs_type = 0;
<a name="l02608"></a>02608     drv = LD2PD(drv);
<a name="l02609"></a>02609 
<a name="l02610"></a>02610     <span class="comment">/* Get disk statics */</span>
<a name="l02611"></a>02611     stat = disk_initialize(drv);
<a name="l02612"></a>02612     <span class="keywordflow">if</span> (stat &amp; STA_NOINIT) <span class="keywordflow">return</span> FR_NOT_READY;
<a name="l02613"></a>02613     <span class="keywordflow">if</span> (stat &amp; STA_PROTECT) <span class="keywordflow">return</span> FR_WRITE_PROTECTED;
<a name="l02614"></a>02614     <span class="keywordflow">if</span> (disk_ioctl(drv, GET_SECTOR_COUNT, &amp;n_part) != RES_OK || n_part &lt; MIN_SECTOR)
<a name="l02615"></a>02615         <span class="keywordflow">return</span> FR_MKFS_ABORTED;
<a name="l02616"></a>02616     <span class="keywordflow">if</span> (n_part &gt; MAX_SECTOR) n_part = MAX_SECTOR;
<a name="l02617"></a>02617     b_part = (!partition) ? 63 : 0;     <span class="comment">/* Boot sector */</span>
<a name="l02618"></a>02618     n_part -= b_part;
<a name="l02619"></a>02619 <span class="preprocessor">#if _MAX_SS == 512</span>
<a name="l02620"></a>02620 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!allocsize) {                   <span class="comment">/* Auto selection of cluster size */</span>
<a name="l02621"></a>02621         <span class="keywordflow">for</span> (n = 0; n_part &lt; sstbl[n]; n++) ;
<a name="l02622"></a>02622         allocsize = cstbl[n];
<a name="l02623"></a>02623     }
<a name="l02624"></a>02624 <span class="preprocessor">#endif</span>
<a name="l02625"></a>02625 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (as = 512; as &lt;= 32768U &amp;&amp; as != allocsize; as &lt;&lt;= 1);
<a name="l02626"></a>02626     <span class="keywordflow">if</span> (as != allocsize) <span class="keywordflow">return</span> FR_MKFS_ABORTED;
<a name="l02627"></a>02627 <span class="preprocessor">#if _MAX_SS != 512                      </span><span class="comment">/* Check disk sector size */</span>
<a name="l02628"></a>02628     <span class="keywordflow">if</span> (disk_ioctl(drv, GET_SECTOR_SIZE, &amp;SS(fs)) != RES_OK
<a name="l02629"></a>02629         || SS(fs) &gt; _MAX_SS
<a name="l02630"></a>02630         || SS(fs) &gt; allocsize)
<a name="l02631"></a>02631         <span class="keywordflow">return</span> FR_MKFS_ABORTED;
<a name="l02632"></a>02632 <span class="preprocessor">#endif</span>
<a name="l02633"></a>02633 <span class="preprocessor"></span>    allocsize /= SS(fs);        <span class="comment">/* Number of sectors per cluster */</span>
<a name="l02634"></a>02634 
<a name="l02635"></a>02635     <span class="comment">/* Pre-compute number of clusters and FAT type */</span>
<a name="l02636"></a>02636     n_clst = n_part / allocsize;
<a name="l02637"></a>02637     fmt = FS_FAT12;
<a name="l02638"></a>02638     <span class="keywordflow">if</span> (n_clst &gt;= 0xFF5) fmt = FS_FAT16;
<a name="l02639"></a>02639     <span class="keywordflow">if</span> (n_clst &gt;= 0xFFF5) fmt = FS_FAT32;
<a name="l02640"></a>02640 
<a name="l02641"></a>02641     <span class="comment">/* Determine offset and size of FAT structure */</span>
<a name="l02642"></a>02642     <span class="keywordflow">switch</span> (fmt) {
<a name="l02643"></a>02643     <span class="keywordflow">case</span> FS_FAT12:
<a name="l02644"></a>02644         n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
<a name="l02645"></a>02645         n_rsv = 1 + partition;
<a name="l02646"></a>02646         n_dir = N_ROOTDIR * 32 / SS(fs);
<a name="l02647"></a>02647         <span class="keywordflow">break</span>;
<a name="l02648"></a>02648     <span class="keywordflow">case</span> FS_FAT16:
<a name="l02649"></a>02649         n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
<a name="l02650"></a>02650         n_rsv = 1 + partition;
<a name="l02651"></a>02651         n_dir = N_ROOTDIR * 32 / SS(fs);
<a name="l02652"></a>02652         <span class="keywordflow">break</span>;
<a name="l02653"></a>02653     <span class="keywordflow">default</span>:
<a name="l02654"></a>02654         n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
<a name="l02655"></a>02655         n_rsv = 33 - partition;
<a name="l02656"></a>02656         n_dir = 0;
<a name="l02657"></a>02657     }
<a name="l02658"></a>02658     b_fat = b_part + n_rsv;         <span class="comment">/* FATs start sector */</span>
<a name="l02659"></a>02659     b_dir = b_fat + n_fat * N_FATS; <span class="comment">/* Directory start sector */</span>
<a name="l02660"></a>02660     b_data = b_dir + n_dir;         <span class="comment">/* Data start sector */</span>
<a name="l02661"></a>02661 
<a name="l02662"></a>02662     <span class="comment">/* Align data start sector to erase block boundary (for flash memory media) */</span>
<a name="l02663"></a>02663     <span class="keywordflow">if</span> (disk_ioctl(drv, GET_BLOCK_SIZE, &amp;n) != RES_OK) <span class="keywordflow">return</span> FR_MKFS_ABORTED;
<a name="l02664"></a>02664     n = (b_data + n - 1) &amp; ~(n - 1);
<a name="l02665"></a>02665     n_fat += (n - b_data) / N_FATS;
<a name="l02666"></a>02666     <span class="comment">/* b_dir and b_data are no longer used below */</span>
<a name="l02667"></a>02667 
<a name="l02668"></a>02668     <span class="comment">/* Determine number of cluster and final check of validity of the FAT type */</span>
<a name="l02669"></a>02669     n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
<a name="l02670"></a>02670     <span class="keywordflow">if</span> (   (fmt == FS_FAT16 &amp;&amp; n_clst &lt; 0xFF5)
<a name="l02671"></a>02671         || (fmt == FS_FAT32 &amp;&amp; n_clst &lt; 0xFFF5))
<a name="l02672"></a>02672         <span class="keywordflow">return</span> FR_MKFS_ABORTED;
<a name="l02673"></a>02673 
<a name="l02674"></a>02674     <span class="comment">/* Create partition table if needed */</span>
<a name="l02675"></a>02675     <span class="keywordflow">if</span> (!partition) {
<a name="l02676"></a>02676         DWORD n_disk = b_part + n_part;
<a name="l02677"></a>02677 
<a name="l02678"></a>02678         tbl = fs-&gt;win+MBR_Table;
<a name="l02679"></a>02679         ST_DWORD(tbl, 0x00010180);      <span class="comment">/* Partition start in CHS */</span>
<a name="l02680"></a>02680         <span class="keywordflow">if</span> (n_disk &lt; 63UL * 255 * 1024) {   <span class="comment">/* Partition end in CHS */</span>
<a name="l02681"></a>02681             n_disk = n_disk / 63 / 255;
<a name="l02682"></a>02682             tbl[7] = (BYTE)n_disk;
<a name="l02683"></a>02683             tbl[6] = (BYTE)((n_disk &gt;&gt; 2) | 63);
<a name="l02684"></a>02684         } <span class="keywordflow">else</span> {
<a name="l02685"></a>02685             ST_WORD(&amp;tbl[6], 0xFFFF);
<a name="l02686"></a>02686         }
<a name="l02687"></a>02687         tbl[5] = 254;
<a name="l02688"></a>02688         <span class="keywordflow">if</span> (fmt != FS_FAT32)            <span class="comment">/* System ID */</span>
<a name="l02689"></a>02689             tbl[4] = (n_part &lt; 0x10000) ? 0x04 : 0x06;
<a name="l02690"></a>02690         <span class="keywordflow">else</span>
<a name="l02691"></a>02691             tbl[4] = 0x0c;
<a name="l02692"></a>02692         ST_DWORD(tbl+8, 63);            <span class="comment">/* Partition start in LBA */</span>
<a name="l02693"></a>02693         ST_DWORD(tbl+12, n_part);       <span class="comment">/* Partition size in LBA */</span>
<a name="l02694"></a>02694         ST_WORD(tbl+64, 0xAA55);        <span class="comment">/* Signature */</span>
<a name="l02695"></a>02695         <span class="keywordflow">if</span> (disk_write(drv, fs-&gt;win, 0, 1) != RES_OK)
<a name="l02696"></a>02696             <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l02697"></a>02697     }
<a name="l02698"></a>02698 
<a name="l02699"></a>02699     <span class="comment">/* Create boot record */</span>
<a name="l02700"></a>02700     tbl = fs-&gt;win;                              <span class="comment">/* Clear buffer */</span>
<a name="l02701"></a>02701     mem_set(tbl, 0, SS(fs));
<a name="l02702"></a>02702     ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);         <span class="comment">/* Boot code (jmp $, nop) */</span>
<a name="l02703"></a>02703     ST_WORD(tbl+BPB_BytsPerSec, SS(fs));        <span class="comment">/* Sector size */</span>
<a name="l02704"></a>02704     tbl[BPB_SecPerClus] = (BYTE)allocsize;      <span class="comment">/* Sectors per cluster */</span>
<a name="l02705"></a>02705     ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);         <span class="comment">/* Reserved sectors */</span>
<a name="l02706"></a>02706     tbl[BPB_NumFATs] = N_FATS;                  <span class="comment">/* Number of FATs */</span>
<a name="l02707"></a>02707     ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); <span class="comment">/* Number of rootdir entries */</span>
<a name="l02708"></a>02708     <span class="keywordflow">if</span> (n_part &lt; 0x10000) {                     <span class="comment">/* Number of total sectors */</span>
<a name="l02709"></a>02709         ST_WORD(tbl+BPB_TotSec16, n_part);
<a name="l02710"></a>02710     } <span class="keywordflow">else</span> {
<a name="l02711"></a>02711         ST_DWORD(tbl+BPB_TotSec32, n_part);
<a name="l02712"></a>02712     }
<a name="l02713"></a>02713     tbl[BPB_Media] = 0xF8;                      <span class="comment">/* Media descripter */</span>
<a name="l02714"></a>02714     ST_WORD(tbl+BPB_SecPerTrk, 63);             <span class="comment">/* Number of sectors per track */</span>
<a name="l02715"></a>02715     ST_WORD(tbl+BPB_NumHeads, 255);             <span class="comment">/* Number of heads */</span>
<a name="l02716"></a>02716     ST_DWORD(tbl+BPB_HiddSec, b_part);          <span class="comment">/* Hidden sectors */</span>
<a name="l02717"></a>02717     n = get_fattime();                          <span class="comment">/* Use current time as a VSN */</span>
<a name="l02718"></a>02718     <span class="keywordflow">if</span> (fmt != FS_FAT32) {
<a name="l02719"></a>02719         ST_DWORD(tbl+BS_VolID, n);              <span class="comment">/* Volume serial number */</span>
<a name="l02720"></a>02720         ST_WORD(tbl+BPB_FATSz16, n_fat);        <span class="comment">/* Number of secters per FAT */</span>
<a name="l02721"></a>02721         tbl[BS_DrvNum] = 0x80;                  <span class="comment">/* Drive number */</span>
<a name="l02722"></a>02722         tbl[BS_BootSig] = 0x29;                 <span class="comment">/* Extended boot signature */</span>
<a name="l02723"></a>02723         mem_cpy(tbl+BS_VolLab, <span class="stringliteral">&quot;NO NAME    FAT     &quot;</span>, 19);  <span class="comment">/* Volume lavel, FAT signature */</span>
<a name="l02724"></a>02724     } <span class="keywordflow">else</span> {
<a name="l02725"></a>02725         ST_DWORD(tbl+BS_VolID32, n);            <span class="comment">/* Volume serial number */</span>
<a name="l02726"></a>02726         ST_DWORD(tbl+BPB_FATSz32, n_fat);       <span class="comment">/* Number of secters per FAT */</span>
<a name="l02727"></a>02727         ST_DWORD(tbl+BPB_RootClus, 2);          <span class="comment">/* Root directory cluster (2) */</span>
<a name="l02728"></a>02728         ST_WORD(tbl+BPB_FSInfo, 1);             <span class="comment">/* FSInfo record offset (bs+1) */</span>
<a name="l02729"></a>02729         ST_WORD(tbl+BPB_BkBootSec, 6);          <span class="comment">/* Backup boot record offset (bs+6) */</span>
<a name="l02730"></a>02730         tbl[BS_DrvNum32] = 0x80;                <span class="comment">/* Drive number */</span>
<a name="l02731"></a>02731         tbl[BS_BootSig32] = 0x29;               <span class="comment">/* Extended boot signature */</span>
<a name="l02732"></a>02732         mem_cpy(tbl+BS_VolLab32, <span class="stringliteral">&quot;NO NAME    FAT32   &quot;</span>, 19);    <span class="comment">/* Volume lavel, FAT signature */</span>
<a name="l02733"></a>02733     }
<a name="l02734"></a>02734     ST_WORD(tbl+BS_55AA, 0xAA55);               <span class="comment">/* Signature */</span>
<a name="l02735"></a>02735     <span class="keywordflow">if</span> (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
<a name="l02736"></a>02736         <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l02737"></a>02737     <span class="keywordflow">if</span> (fmt == FS_FAT32)
<a name="l02738"></a>02738         disk_write(drv, tbl, b_part+6, 1);
<a name="l02739"></a>02739 
<a name="l02740"></a>02740     <span class="comment">/* Initialize FAT area */</span>
<a name="l02741"></a>02741     <span class="keywordflow">for</span> (m = 0; m &lt; N_FATS; m++) {
<a name="l02742"></a>02742         mem_set(tbl, 0, SS(fs));        <span class="comment">/* 1st sector of the FAT  */</span>
<a name="l02743"></a>02743         <span class="keywordflow">if</span> (fmt != FS_FAT32) {
<a name="l02744"></a>02744             n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
<a name="l02745"></a>02745             ST_DWORD(tbl, n);               <span class="comment">/* Reserve cluster #0-1 (FAT12/16) */</span>
<a name="l02746"></a>02746         } <span class="keywordflow">else</span> {
<a name="l02747"></a>02747             ST_DWORD(tbl+0, 0xFFFFFFF8);    <span class="comment">/* Reserve cluster #0-1 (FAT32) */</span>
<a name="l02748"></a>02748             ST_DWORD(tbl+4, 0xFFFFFFFF);
<a name="l02749"></a>02749             ST_DWORD(tbl+8, 0x0FFFFFFF);    <span class="comment">/* Reserve cluster #2 for root dir */</span>
<a name="l02750"></a>02750         }
<a name="l02751"></a>02751         <span class="keywordflow">if</span> (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
<a name="l02752"></a>02752             <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l02753"></a>02753         mem_set(tbl, 0, SS(fs));        <span class="comment">/* Following FAT entries are filled by zero */</span>
<a name="l02754"></a>02754         <span class="keywordflow">for</span> (n = 1; n &lt; n_fat; n++) {
<a name="l02755"></a>02755             <span class="keywordflow">if</span> (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
<a name="l02756"></a>02756                 <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l02757"></a>02757         }
<a name="l02758"></a>02758     }
<a name="l02759"></a>02759 
<a name="l02760"></a>02760     <span class="comment">/* Initialize Root directory */</span>
<a name="l02761"></a>02761     m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
<a name="l02762"></a>02762     <span class="keywordflow">do</span> {
<a name="l02763"></a>02763         <span class="keywordflow">if</span> (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
<a name="l02764"></a>02764             <span class="keywordflow">return</span> FR_DISK_ERR;
<a name="l02765"></a>02765     } <span class="keywordflow">while</span> (--m);
<a name="l02766"></a>02766 
<a name="l02767"></a>02767     <span class="comment">/* Create FSInfo record if needed */</span>
<a name="l02768"></a>02768     <span class="keywordflow">if</span> (fmt == FS_FAT32) {
<a name="l02769"></a>02769         ST_WORD(tbl+BS_55AA, 0xAA55);
<a name="l02770"></a>02770         ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
<a name="l02771"></a>02771         ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
<a name="l02772"></a>02772         ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
<a name="l02773"></a>02773         ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
<a name="l02774"></a>02774         disk_write(drv, tbl, b_part+1, 1);
<a name="l02775"></a>02775         disk_write(drv, tbl, b_part+7, 1);
<a name="l02776"></a>02776     }
<a name="l02777"></a>02777 
<a name="l02778"></a>02778     <span class="keywordflow">return</span> (disk_ioctl(drv, CTRL_SYNC, (<span class="keywordtype">void</span>*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
<a name="l02779"></a>02779 }
<a name="l02780"></a>02780 
<a name="l02781"></a>02781 <span class="preprocessor">#endif </span><span class="comment">/* _USE_MKFS &amp;&amp; !_FS_READONLY */</span>
<a name="l02782"></a>02782 
<a name="l02783"></a>02783 
<a name="l02784"></a>02784 
<a name="l02785"></a>02785 
<a name="l02786"></a>02786 <span class="preprocessor">#if _USE_STRFUNC</span>
<a name="l02787"></a>02787 <span class="preprocessor"></span><span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02788"></a>02788 <span class="comment">/* Get a string from the file                                            */</span>
<a name="l02789"></a>02789 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02790"></a>02790 <span class="keywordtype">char</span>* f_gets (
<a name="l02791"></a>02791     <span class="keywordtype">char</span>* buff, <span class="comment">/* Pointer to the string buffer to read */</span>
<a name="l02792"></a>02792     <span class="keywordtype">int</span> len,    <span class="comment">/* Size of string buffer */</span>
<a name="l02793"></a>02793     FIL* fil    <span class="comment">/* Pointer to the file object */</span>
<a name="l02794"></a>02794 )
<a name="l02795"></a>02795 {
<a name="l02796"></a>02796     <span class="keywordtype">int</span> i = 0;
<a name="l02797"></a>02797     <span class="keywordtype">char</span> *p = buff;
<a name="l02798"></a>02798     UINT rc;
<a name="l02799"></a>02799 
<a name="l02800"></a>02800 
<a name="l02801"></a>02801     <span class="keywordflow">while</span> (i &lt; len - 1) {           <span class="comment">/* Read bytes until buffer gets filled */</span>
<a name="l02802"></a>02802         f_read(fil, p, 1, &amp;rc);
<a name="l02803"></a>02803         <span class="keywordflow">if</span> (rc != 1) <span class="keywordflow">break</span>;         <span class="comment">/* Break when no data to read */</span>
<a name="l02804"></a>02804 <span class="preprocessor">#if _USE_STRFUNC &gt;= 2</span>
<a name="l02805"></a>02805 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;\r&#39;</span>) <span class="keywordflow">continue</span>;   <span class="comment">/* Strip &#39;\r&#39; */</span>
<a name="l02806"></a>02806 <span class="preprocessor">#endif</span>
<a name="l02807"></a>02807 <span class="preprocessor"></span>        i++;
<a name="l02808"></a>02808         <span class="keywordflow">if</span> (*p++ == <span class="charliteral">&#39;\n&#39;</span>) <span class="keywordflow">break</span>;    <span class="comment">/* Break when reached end of line */</span>
<a name="l02809"></a>02809     }
<a name="l02810"></a>02810     *p = 0;
<a name="l02811"></a>02811     <span class="keywordflow">return</span> i ? buff : NULL;         <span class="comment">/* When no data read (eof or error), return with error. */</span>
<a name="l02812"></a>02812 }
<a name="l02813"></a>02813 
<a name="l02814"></a>02814 
<a name="l02815"></a>02815 
<a name="l02816"></a>02816 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l02817"></a>02817 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l02818"></a>02818 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02819"></a>02819 <span class="comment">/* Put a character to the file                                           */</span>
<a name="l02820"></a>02820 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02821"></a>02821 <span class="keywordtype">int</span> f_putc (
<a name="l02822"></a>02822     <span class="keywordtype">int</span> chr,    <span class="comment">/* A character to be output */</span>
<a name="l02823"></a>02823     FIL* fil    <span class="comment">/* Ponter to the file object */</span>
<a name="l02824"></a>02824 )
<a name="l02825"></a>02825 {
<a name="l02826"></a>02826     UINT bw;
<a name="l02827"></a>02827     <span class="keywordtype">char</span> c;
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 
<a name="l02830"></a>02830 <span class="preprocessor">#if _USE_STRFUNC &gt;= 2</span>
<a name="l02831"></a>02831 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (chr == <span class="charliteral">&#39;\n&#39;</span>) f_putc (<span class="charliteral">&#39;\r&#39;</span>, fil);    <span class="comment">/* LF -&gt; CRLF conversion */</span>
<a name="l02832"></a>02832 <span class="preprocessor">#endif</span>
<a name="l02833"></a>02833 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!fil) { <span class="comment">/* Special value may be used to switch the destination to any other device */</span>
<a name="l02834"></a>02834     <span class="comment">/*  put_console(chr);   */</span>
<a name="l02835"></a>02835         <span class="keywordflow">return</span> chr;
<a name="l02836"></a>02836     }
<a name="l02837"></a>02837     c = (char)chr;
<a name="l02838"></a>02838     f_write(fil, &amp;c, 1, &amp;bw);   <span class="comment">/* Write a byte to the file */</span>
<a name="l02839"></a>02839     <span class="keywordflow">return</span> bw ? chr : EOF;      <span class="comment">/* Return the result */</span>
<a name="l02840"></a>02840 }
<a name="l02841"></a>02841 
<a name="l02842"></a>02842 
<a name="l02843"></a>02843 
<a name="l02844"></a>02844 
<a name="l02845"></a>02845 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02846"></a>02846 <span class="comment">/* Put a string to the file                                              */</span>
<a name="l02847"></a>02847 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02848"></a>02848 <span class="keywordtype">int</span> f_puts (
<a name="l02849"></a>02849     <span class="keyword">const</span> <span class="keywordtype">char</span>* str,    <span class="comment">/* Pointer to the string to be output */</span>
<a name="l02850"></a>02850     FIL* fil            <span class="comment">/* Pointer to the file object */</span>
<a name="l02851"></a>02851 )
<a name="l02852"></a>02852 {
<a name="l02853"></a>02853     <span class="keywordtype">int</span> n;
<a name="l02854"></a>02854 
<a name="l02855"></a>02855 
<a name="l02856"></a>02856     <span class="keywordflow">for</span> (n = 0; *str; str++, n++) {
<a name="l02857"></a>02857         <span class="keywordflow">if</span> (f_putc(*str, fil) == EOF) <span class="keywordflow">return</span> EOF;
<a name="l02858"></a>02858     }
<a name="l02859"></a>02859     <span class="keywordflow">return</span> n;
<a name="l02860"></a>02860 }
<a name="l02861"></a>02861 
<a name="l02862"></a>02862 
<a name="l02863"></a>02863 
<a name="l02864"></a>02864 
<a name="l02865"></a>02865 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02866"></a>02866 <span class="comment">/* Put a formatted string to the file                                    */</span>
<a name="l02867"></a>02867 <span class="comment">/*-----------------------------------------------------------------------*/</span>
<a name="l02868"></a>02868 <span class="keywordtype">int</span> f_printf (
<a name="l02869"></a>02869     FIL* fil,           <span class="comment">/* Pointer to the file object */</span>
<a name="l02870"></a>02870     <span class="keyword">const</span> <span class="keywordtype">char</span>* str,    <span class="comment">/* Pointer to the format string */</span>
<a name="l02871"></a>02871     ...                 <span class="comment">/* Optional arguments... */</span>
<a name="l02872"></a>02872 )
<a name="l02873"></a>02873 {
<a name="l02874"></a>02874     va_list arp;
<a name="l02875"></a>02875     UCHAR c, f, r;
<a name="l02876"></a>02876     ULONG val;
<a name="l02877"></a>02877     <span class="keywordtype">char</span> s[16];
<a name="l02878"></a>02878     <span class="keywordtype">int</span> i, w, res, cc;
<a name="l02879"></a>02879 
<a name="l02880"></a>02880 
<a name="l02881"></a>02881     va_start(arp, str);
<a name="l02882"></a>02882 
<a name="l02883"></a>02883     <span class="keywordflow">for</span> (cc = res = 0; cc != EOF; res += cc) {
<a name="l02884"></a>02884         c = *str++;
<a name="l02885"></a>02885         <span class="keywordflow">if</span> (c == 0) <span class="keywordflow">break</span>;          <span class="comment">/* End of string */</span>
<a name="l02886"></a>02886         <span class="keywordflow">if</span> (c != <span class="charliteral">&#39;%&#39;</span>) {             <span class="comment">/* Non escape cahracter */</span>
<a name="l02887"></a>02887             cc = f_putc(c, fil);
<a name="l02888"></a>02888             <span class="keywordflow">if</span> (cc != EOF) cc = 1;
<a name="l02889"></a>02889             <span class="keywordflow">continue</span>;
<a name="l02890"></a>02890         }
<a name="l02891"></a>02891         w = f = 0;
<a name="l02892"></a>02892         c = *str++;
<a name="l02893"></a>02893         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;0&#39;</span>) {             <span class="comment">/* Flag: &#39;0&#39; padding */</span>
<a name="l02894"></a>02894             f = 1; c = *str++;
<a name="l02895"></a>02895         }
<a name="l02896"></a>02896         <span class="keywordflow">while</span> (c &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; c &lt;= <span class="charliteral">&#39;9&#39;</span>) {  <span class="comment">/* Precision */</span>
<a name="l02897"></a>02897             w = w * 10 + (c - <span class="charliteral">&#39;0&#39;</span>);
<a name="l02898"></a>02898             c = *str++;
<a name="l02899"></a>02899         }
<a name="l02900"></a>02900         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;l&#39;</span>) {             <span class="comment">/* Prefix: Size is long int */</span>
<a name="l02901"></a>02901             f |= 2; c = *str++;
<a name="l02902"></a>02902         }
<a name="l02903"></a>02903         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;s&#39;</span>) {             <span class="comment">/* Type is string */</span>
<a name="l02904"></a>02904             cc = f_puts(va_arg(arp, <span class="keywordtype">char</span>*), fil);
<a name="l02905"></a>02905             <span class="keywordflow">continue</span>;
<a name="l02906"></a>02906         }
<a name="l02907"></a>02907         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;c&#39;</span>) {             <span class="comment">/* Type is character */</span>
<a name="l02908"></a>02908             cc = f_putc(va_arg(arp, <span class="keywordtype">int</span>), fil);
<a name="l02909"></a>02909             <span class="keywordflow">if</span> (cc != EOF) cc = 1;
<a name="l02910"></a>02910             <span class="keywordflow">continue</span>;
<a name="l02911"></a>02911         }
<a name="l02912"></a>02912         r = 0;
<a name="l02913"></a>02913         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;d&#39;</span>) r = 10;       <span class="comment">/* Type is signed decimal */</span>
<a name="l02914"></a>02914         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;u&#39;</span>) r = 10;       <span class="comment">/* Type is unsigned decimal */</span>
<a name="l02915"></a>02915         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;X&#39;</span>) r = 16;       <span class="comment">/* Type is unsigned hexdecimal */</span>
<a name="l02916"></a>02916         <span class="keywordflow">if</span> (r == 0) <span class="keywordflow">break</span>;          <span class="comment">/* Unknown type */</span>
<a name="l02917"></a>02917         <span class="keywordflow">if</span> (f &amp; 2) {                <span class="comment">/* Get the value */</span>
<a name="l02918"></a>02918             val = (ULONG)va_arg(arp, <span class="keywordtype">long</span>);
<a name="l02919"></a>02919         } <span class="keywordflow">else</span> {
<a name="l02920"></a>02920             val = (c == <span class="charliteral">&#39;d&#39;</span>) ? (ULONG)(long)va_arg(arp, <span class="keywordtype">int</span>) : (ULONG)va_arg(arp, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l02921"></a>02921         }
<a name="l02922"></a>02922         <span class="comment">/* Put numeral string */</span>
<a name="l02923"></a>02923         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;d&#39;</span>) {
<a name="l02924"></a>02924             <span class="keywordflow">if</span> (val &amp; 0x80000000) {
<a name="l02925"></a>02925                 val = 0 - val;
<a name="l02926"></a>02926                 f |= 4;
<a name="l02927"></a>02927             }
<a name="l02928"></a>02928         }
<a name="l02929"></a>02929         i = <span class="keyword">sizeof</span>(s) - 1; s[i] = 0;
<a name="l02930"></a>02930         <span class="keywordflow">do</span> {
<a name="l02931"></a>02931             c = (UCHAR)(val % r + <span class="charliteral">&#39;0&#39;</span>);
<a name="l02932"></a>02932             <span class="keywordflow">if</span> (c &gt; <span class="charliteral">&#39;9&#39;</span>) c += 7;
<a name="l02933"></a>02933             s[--i] = c;
<a name="l02934"></a>02934             val /= r;
<a name="l02935"></a>02935         } <span class="keywordflow">while</span> (i &amp;&amp; val);
<a name="l02936"></a>02936         <span class="keywordflow">if</span> (i &amp;&amp; (f &amp; 4)) s[--i] = <span class="charliteral">&#39;-&#39;</span>;
<a name="l02937"></a>02937         w = <span class="keyword">sizeof</span>(s) - 1 - w;
<a name="l02938"></a>02938         <span class="keywordflow">while</span> (i &amp;&amp; i &gt; w) s[--i] = (f &amp; 1) ? <span class="charliteral">&#39;0&#39;</span> : <span class="charliteral">&#39; &#39;</span>;
<a name="l02939"></a>02939         cc = f_puts(&amp;s[i], fil);
<a name="l02940"></a>02940     }
<a name="l02941"></a>02941 
<a name="l02942"></a>02942     va_end(arp);
<a name="l02943"></a>02943     <span class="keywordflow">return</span> (cc == EOF) ? cc : res;
<a name="l02944"></a>02944 }
<a name="l02945"></a>02945 
<a name="l02946"></a>02946 <span class="preprocessor">#endif </span><span class="comment">/* !_FS_READONLY */</span>
<a name="l02947"></a>02947 <span class="preprocessor">#endif </span><span class="comment">/* _USE_STRFUNC */</span>
</pre></div></div>
</div>


