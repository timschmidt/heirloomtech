

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_e91c80130e425b11d52da5b92a7aa933.html">net</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">tftp.c</div>  </div>
</div>
<div class="contents">
<a href="tftp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="tftp_8h.html" title="TFTP protocol implementation.">tftp.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;cfg/cfg_tftp.h&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#define LOG_LEVEL   TFTP_LOG_LEVEL</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define LOG_FORMAT  TFTP_LOG_FORMAT</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="log_8h.html">cfg/log.h</a>&gt;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">//#include &lt;lwip/in.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;lwip/inet.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;lwip/sockets.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;string.h&gt;</span> <span class="comment">//memset</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#define TFTP_PACKET_SIZE 516</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>
<a name="l00053"></a>00053 <span class="preprocessor">#define DECLARE_TIMEOUT(name, timeout) \</span>
<a name="l00054"></a>00054 <span class="preprocessor">    struct timeval name; \</span>
<a name="l00055"></a>00055 <span class="preprocessor">    name.tv_sec = timeout / 1000; \</span>
<a name="l00056"></a>00056 <span class="preprocessor">    name.tv_usec = (timeout % 1000) * 1000;</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058 <span class="preprocessor">#define KFT_TFTPSESSION MAKE_ID(&#39;T&#39;, &#39;F&#39;, &#39;T&#39;, &#39;P&#39;)</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>INLINE TftpSession *TFTP_CAST(<a class="code" href="structKFile.html" title="Context data for callback functions which operate on pseudo files.">KFile</a> *fd)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061     <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(fd-&gt;_type == KFT_TFTPSESSION);
<a name="l00062"></a>00062     <span class="keywordflow">return</span> (TftpSession *)<a class="code" href="compiler_8h.html#ad8a293330664172f7fb87c204bac34b3" title="Cast a member of a structure out to the containing structure.">containerof</a>(fd, TftpSession, kfile_request);
<a name="l00063"></a>00063 }
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="comment">/*</span>
<a name="l00066"></a>00066 <span class="comment"> * Check if received data is correct and send ACK if ok.</span>
<a name="l00067"></a>00067 <span class="comment"> */</span>
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keywordtype">int</span> checkPacket(TftpSession *ctx, <span class="keyword">const</span> Tftpframe *frame)
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070     <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Checking block %hd\n&quot;</span>, ctx-&gt;block);
<a name="l00071"></a>00071     <span class="keywordflow">if</span> (ntohs(frame-&gt;hdr.opcode) != TFTP_DATA)
<a name="l00072"></a>00072     {
<a name="l00073"></a>00073         <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Opcode != TFTP_DATA (%hd != %d)\n&quot;</span>, ntohs(frame-&gt;hdr.opcode), TFTP_DATA);
<a name="l00074"></a>00074         <span class="keywordflow">return</span> -1;
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076     <span class="keywordflow">if</span> (ntohs(frame-&gt;hdr.th_u.block) != ctx-&gt;block + 1)
<a name="l00077"></a>00077         <span class="keywordflow">return</span> -1;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079     ctx-&gt;block++;
<a name="l00080"></a>00080     <span class="comment">// if everything was ok, send ACK</span>
<a name="l00081"></a>00081     <span class="comment">// ACK is already in network order</span>
<a name="l00082"></a>00082     <span class="keyword">struct </span>ackframe ack;
<a name="l00083"></a>00083     ack.opcode = TFTP_ACK;
<a name="l00084"></a>00084     ack.block_num = htons(ctx-&gt;block);
<a name="l00085"></a>00085     ssize_t rc = lwip_sendto(ctx-&gt;sock, &amp;ack, 4, 0, (<span class="keyword">struct</span> sockaddr *)&amp;ctx-&gt;addr, ctx-&gt;addr_len);
<a name="l00086"></a>00086     <span class="keywordflow">if</span> (rc == 4)
<a name="l00087"></a>00087         <span class="keywordflow">return</span> rc;
<a name="l00088"></a>00088     <span class="keywordflow">else</span>
<a name="l00089"></a>00089         <span class="keywordflow">return</span> -1;
<a name="l00090"></a>00090 }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">/*</span>
<a name="l00093"></a>00093 <span class="comment"> * Return &gt;0 if there&#39;s something to read in ctx, 0 on timeout, -1 on errors</span>
<a name="l00094"></a>00094 <span class="comment"> */</span>
<a name="l00095"></a>00095 <span class="keyword">static</span> <span class="keywordtype">int</span> tftp_waitEvent(TftpSession *ctx, <span class="keyword">struct</span> timeval *timeout)
<a name="l00096"></a>00096 {
<a name="l00097"></a>00097     fd_set inset;
<a name="l00098"></a>00098     FD_ZERO(&amp;inset);
<a name="l00099"></a>00099     FD_SET(ctx-&gt;sock, &amp;inset);
<a name="l00100"></a>00100     <span class="keyword">struct </span>timeval tmp = *timeout;
<a name="l00101"></a>00101     <span class="keywordflow">return</span> lwip_select(ctx-&gt;sock + 1, &amp;inset, NULL, NULL, &amp;tmp);
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment">/*</span>
<a name="l00105"></a>00105 <span class="comment"> * Read a block from TFTP.</span>
<a name="l00106"></a>00106 <span class="comment"> * \param size Must be exactly 516 bytes</span>
<a name="l00107"></a>00107 <span class="comment"> * \param timeout Time to wait the network connection, may be NULL to wait forever</span>
<a name="l00108"></a>00108 <span class="comment"> * \return Number of bytes read if success, TFTP_ERR_TIMEOUT on timeout, TFTP_ERR otherwise</span>
<a name="l00109"></a>00109 <span class="comment"> */</span>
<a name="l00110"></a>00110 <span class="keyword">static</span> ssize_t tftp_readPacket(TftpSession *ctx, Tftpframe *frame, <a class="code" href="compiler_8h.html#ac6f57181b1edf6b9b510c8a1a66201c1" title="Type for time expressed in milliseconds.">mtime_t</a> timeout)
<a name="l00111"></a>00111 {
<a name="l00112"></a>00112     DECLARE_TIMEOUT(wait_tm, timeout);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114     <span class="keywordtype">int</span> res = tftp_waitEvent(ctx, &amp;wait_tm);
<a name="l00115"></a>00115     <span class="keywordflow">if</span> (res == 0)
<a name="l00116"></a>00116         <span class="keywordflow">return</span> TFTP_ERR_TIMEOUT;
<a name="l00117"></a>00117     <span class="keywordflow">if</span> (res == -1)
<a name="l00118"></a>00118         <span class="keywordflow">return</span> TFTP_ERR;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     ssize_t rlen = lwip_recvfrom(ctx-&gt;sock, frame, <span class="keyword">sizeof</span>(Tftpframe), 0, NULL, NULL);
<a name="l00121"></a>00121     <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Received %zd bytes\n&quot;</span>, rlen);
<a name="l00122"></a>00122     <span class="keywordflow">if</span> (rlen &gt; 0 &amp;&amp; (checkPacket(ctx, frame) &gt; 0))
<a name="l00123"></a>00123         <span class="keywordflow">return</span> rlen;
<a name="l00124"></a>00124     <span class="keywordflow">else</span>
<a name="l00125"></a>00125         <span class="keywordflow">return</span> TFTP_ERR;
<a name="l00126"></a>00126 }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="keyword">static</span> <span class="keywordtype">size_t</span> tftp_read(<span class="keyword">struct</span> <a class="code" href="structKFile.html" title="Context data for callback functions which operate on pseudo files.">KFile</a> *fd, <span class="keywordtype">void</span> *buf, <span class="keywordtype">size_t</span> size)
<a name="l00129"></a>00129 {
<a name="l00130"></a>00130     TftpSession *fds = TFTP_CAST(fd);
<a name="l00131"></a>00131     uint8_t *_buf = (uint8_t *) buf;
<a name="l00132"></a>00132     <span class="keywordtype">size_t</span> read_bytes = 0;
<a name="l00133"></a>00133     <span class="keywordtype">size_t</span> offset = fds-&gt;valid_data - fds-&gt;bytes_available;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="keywordflow">if</span> (fds-&gt;pending_ack)
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137         <a class="code" href="group__debug.html#gaca68c0d4ac8df0838e209fb5300f7be3" title="Assert a pre-condition on code.">ASSERT</a>(fds-&gt;block == 0);
<a name="l00138"></a>00138         <span class="keyword">struct </span>ackframe ack;
<a name="l00139"></a>00139         ack.opcode = TFTP_ACK;
<a name="l00140"></a>00140         ack.block_num = fds-&gt;block;
<a name="l00141"></a>00141         lwip_sendto(fds-&gt;sock, &amp;ack, 4, 0, (<span class="keyword">struct</span> sockaddr *)&amp;fds-&gt;addr, fds-&gt;addr_len);
<a name="l00142"></a>00142         fds-&gt;pending_ack = <span class="keyword">false</span>;
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     <span class="keywordflow">if</span> (fds-&gt;bytes_available &lt; size)
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147         <span class="comment">/* check if we were called again after an error */</span>
<a name="l00148"></a>00148         <span class="keywordflow">if</span> (fds-&gt;bytes_available &gt; 0)
<a name="l00149"></a>00149         {
<a name="l00150"></a>00150             memcpy(_buf, fds-&gt;frame.data + offset, fds-&gt;bytes_available);
<a name="l00151"></a>00151             <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;ba &lt; size. Copied %zd bytes from offset %zd\n&quot;</span>, fds-&gt;bytes_available, offset);
<a name="l00152"></a>00152             <span class="comment">/* adjust buf and size */</span>
<a name="l00153"></a>00153             _buf += fds-&gt;bytes_available;
<a name="l00154"></a>00154             size -= fds-&gt;bytes_available;
<a name="l00155"></a>00155             read_bytes += fds-&gt;bytes_available;
<a name="l00156"></a>00156         }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         <span class="keywordflow">if</span> (!fds-&gt;is_xfer_end)
<a name="l00159"></a>00159         {
<a name="l00160"></a>00160             <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Waiting for new TFTP packet\n&quot;</span>);
<a name="l00161"></a>00161             <span class="comment">/* get more data, we can wait since the function is blocking */</span>
<a name="l00162"></a>00162             ssize_t rd = tftp_readPacket(fds, &amp;fds-&gt;frame, fds-&gt;timeout);
<a name="l00163"></a>00163             <span class="keywordflow">if</span> (rd &lt; 0)
<a name="l00164"></a>00164             {
<a name="l00165"></a>00165                 fds-&gt;bytes_available = 0;
<a name="l00166"></a>00166                 fds-&gt;error = rd;
<a name="l00167"></a>00167                 <span class="keywordflow">return</span> 0;
<a name="l00168"></a>00168             }
<a name="l00169"></a>00169             <span class="keywordflow">else</span>
<a name="l00170"></a>00170             {
<a name="l00171"></a>00171                 <span class="keywordflow">if</span> (rd &lt; TFTP_PACKET_SIZE)
<a name="l00172"></a>00172                 {
<a name="l00173"></a>00173                     fds-&gt;is_xfer_end = <span class="keyword">true</span>;
<a name="l00174"></a>00174                     <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Received the last packet\n&quot;</span>);
<a name="l00175"></a>00175                 }
<a name="l00176"></a>00176                 fds-&gt;bytes_available = (size_t)rd - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> TftpHeader);
<a name="l00177"></a>00177                 fds-&gt;valid_data = fds-&gt;bytes_available;
<a name="l00178"></a>00178                 offset = 0;
<a name="l00179"></a>00179             }
<a name="l00180"></a>00180         }
<a name="l00181"></a>00181         <span class="keywordflow">else</span>
<a name="l00182"></a>00182         {
<a name="l00183"></a>00183             <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Transfer finished\n&quot;</span>);
<a name="l00184"></a>00184             fds-&gt;bytes_available -= fds-&gt;bytes_available;
<a name="l00185"></a>00185             fds-&gt;valid_data = 0;
<a name="l00186"></a>00186             <span class="keywordflow">return</span> read_bytes;
<a name="l00187"></a>00187         }
<a name="l00188"></a>00188     }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     <span class="comment">/* check how many bytes we need to copy */</span>
<a name="l00191"></a>00191     <span class="keywordtype">size_t</span> res = MIN(fds-&gt;bytes_available, size);
<a name="l00192"></a>00192     <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Copying %zd bytes from offset %zd\n&quot;</span>, res, offset);
<a name="l00193"></a>00193     memcpy(_buf, fds-&gt;frame.data + offset, res);
<a name="l00194"></a>00194     fds-&gt;bytes_available -= res;
<a name="l00195"></a>00195     read_bytes += res;
<a name="l00196"></a>00196     <span class="keywordflow">return</span> read_bytes;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keyword">static</span> <span class="keywordtype">int</span> tftp_error(<span class="keyword">struct</span> <a class="code" href="structKFile.html" title="Context data for callback functions which operate on pseudo files.">KFile</a> *fd)
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201     TftpSession *fds = TFTP_CAST(fd);
<a name="l00202"></a>00202     <span class="keywordflow">return</span> fds-&gt;error;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keyword">static</span> <span class="keywordtype">void</span> tftp_clearerr(<span class="keyword">struct</span> <a class="code" href="structKFile.html" title="Context data for callback functions which operate on pseudo files.">KFile</a> *fd)
<a name="l00206"></a>00206 {
<a name="l00207"></a>00207     TftpSession *fds = TFTP_CAST(fd);
<a name="l00208"></a>00208     fds-&gt;error = 0;
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="keyword">static</span> <span class="keywordtype">int</span> tftp_close(<span class="keyword">struct</span> <a class="code" href="structKFile.html" title="Context data for callback functions which operate on pseudo files.">KFile</a> *fd)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213     TftpSession *fds = TFTP_CAST(fd);
<a name="l00214"></a>00214     <span class="keyword">struct </span>errframe err;
<a name="l00215"></a>00215     <span class="keywordflow">if</span> (fds-&gt;pending_ack)
<a name="l00216"></a>00216     {
<a name="l00217"></a>00217         err.opcode = TFTP_PROTOERR;
<a name="l00218"></a>00218         err.errcode = TFTP_PROTOERR_ACCESS_VIOLATION;
<a name="l00219"></a>00219         err.str = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00220"></a>00220         lwip_sendto(fds-&gt;sock, &amp;err, 5, 0, (<span class="keyword">struct</span> sockaddr *)&amp;fds-&gt;addr, fds-&gt;addr_len);
<a name="l00221"></a>00221         <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Closed connection upon user request\n&quot;</span>);
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223     <span class="keywordflow">return</span> 0;
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="keyword">static</span> <span class="keywordtype">void</span> resetTftpState(TftpSession *ctx)
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228     ctx-&gt;block = 0;
<a name="l00229"></a>00229     ctx-&gt;error = 0;
<a name="l00230"></a>00230     ctx-&gt;bytes_available = 0;
<a name="l00231"></a>00231     ctx-&gt;valid_data = 0;
<a name="l00232"></a>00232     ctx-&gt;is_xfer_end = <span class="keyword">false</span>;
<a name="l00233"></a>00233     ctx-&gt;pending_ack = <span class="keyword">false</span>;
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00247"></a><a class="code" href="tftp_8h.html#aedc0010c0e79ecf2cea0aea3e1acb522">00247</a> <a class="code" href="structKFile.html" title="Context data for callback functions which operate on pseudo files.">KFile</a> *<a class="code" href="tftp_8c.html#aedc0010c0e79ecf2cea0aea3e1acb522" title="Listen for incoming tftp sessions.">tftp_listen</a>(TftpSession *ctx, <span class="keywordtype">char</span> *filename, <span class="keywordtype">size_t</span> len, TftpOpenMode *mode)
<a name="l00248"></a>00248 {
<a name="l00249"></a>00249     DECLARE_TIMEOUT(wait_tm, ctx-&gt;timeout);
<a name="l00250"></a>00250     resetTftpState(ctx);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="keywordtype">int</span> res = tftp_waitEvent(ctx, &amp;wait_tm);
<a name="l00253"></a>00253     <span class="keywordflow">if</span> (res == 0)
<a name="l00254"></a>00254     {
<a name="l00255"></a>00255         ctx-&gt;error = TFTP_ERR_TIMEOUT;
<a name="l00256"></a>00256         <span class="keywordflow">return</span> NULL;
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258     <span class="keywordflow">if</span> (res == -1)
<a name="l00259"></a>00259     {
<a name="l00260"></a>00260         ctx-&gt;error = TFTP_ERR;
<a name="l00261"></a>00261         <span class="keywordflow">return</span> NULL;
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     <span class="comment">// listen onto TFTP port</span>
<a name="l00265"></a>00265     ctx-&gt;addr_len = <span class="keyword">sizeof</span>(ctx-&gt;addr);
<a name="l00266"></a>00266     ssize_t rd = 0;
<a name="l00267"></a>00267     <span class="keywordflow">if</span> ((rd = lwip_recvfrom(ctx-&gt;sock, &amp;ctx-&gt;frame, <span class="keyword">sizeof</span>(Tftpframe), 0, (<span class="keyword">struct</span> sockaddr *)&amp;ctx-&gt;addr, &amp;ctx-&gt;addr_len)) &gt; 0)
<a name="l00268"></a>00268     {
<a name="l00269"></a>00269         <span class="comment">// check if the packet is WRQ, otherwise discard the packet</span>
<a name="l00270"></a>00270         <span class="keywordflow">if</span> (ctx-&gt;frame.hdr.opcode == TFTP_WRQ)
<a name="l00271"></a>00271         {
<a name="l00272"></a>00272             *mode = TFTP_WRITE;
<a name="l00273"></a>00273             ctx-&gt;pending_ack = <span class="keyword">true</span>;
<a name="l00274"></a>00274             strncpy(filename, (<span class="keywordtype">char</span> *)&amp;ctx-&gt;frame.hdr.th_u, len);
<a name="l00275"></a>00275             filename[len - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00276"></a>00276             ctx-&gt;error = 0;
<a name="l00277"></a>00277             <span class="keywordflow">return</span> &amp;ctx-&gt;kfile_request;
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279         <span class="keywordflow">else</span>
<a name="l00280"></a>00280             *mode = TFTP_READ;
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282     ctx-&gt;error = TFTP_ERR;
<a name="l00283"></a>00283     <span class="keywordflow">return</span> NULL;
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 
<a name="l00296"></a><a class="code" href="tftp_8h.html#a49b305674d22839b24d28c467da2765f">00296</a> <span class="keywordtype">int</span> <a class="code" href="tftp_8c.html#a49b305674d22839b24d28c467da2765f" title="Init a server session.">tftp_init</a>(TftpSession *ctx, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port, <a class="code" href="compiler_8h.html#ac6f57181b1edf6b9b510c8a1a66201c1" title="Type for time expressed in milliseconds.">mtime_t</a> timeout)
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298     <a class="code" href="group__debug.html#ga5ae59b9945c3ef623af1719976ef3a1f" title="This macro can be used to conditionally exclude one or more statements conditioned on _DEBUG...">DB</a>(ctx-&gt;kfile_request._type = KFT_TFTPSESSION);
<a name="l00299"></a>00299     ctx-&gt;kfile_request.read = tftp_read;
<a name="l00300"></a>00300     ctx-&gt;kfile_request.error = tftp_error;
<a name="l00301"></a>00301     ctx-&gt;kfile_request.clearerr = tftp_clearerr;
<a name="l00302"></a>00302     ctx-&gt;kfile_request.close = tftp_close;
<a name="l00303"></a>00303     resetTftpState(ctx);
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     <span class="comment">/* Unused kfile methods */</span>
<a name="l00306"></a>00306     ctx-&gt;kfile_request.seek = NULL;
<a name="l00307"></a>00307     ctx-&gt;kfile_request.write = NULL;
<a name="l00308"></a>00308     ctx-&gt;kfile_request.flush = NULL;
<a name="l00309"></a>00309     ctx-&gt;kfile_request.reopen = NULL;
<a name="l00310"></a>00310 
<a name="l00311"></a>00311     <span class="keyword">struct </span>sockaddr_in sa;
<a name="l00312"></a>00312     sa.sin_family = AF_INET;
<a name="l00313"></a>00313         sa.sin_addr.s_addr = htonl(INADDR_ANY);
<a name="l00314"></a>00314         sa.sin_port = htons(port);
<a name="l00315"></a>00315     ctx-&gt;timeout = timeout;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317     ctx-&gt;sock = lwip_socket(AF_INET, SOCK_DGRAM, 0);
<a name="l00318"></a>00318     <span class="keywordflow">if</span> (ctx-&gt;sock == -1)
<a name="l00319"></a>00319     {
<a name="l00320"></a>00320         <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;TFTP socket error\n&quot;</span>);
<a name="l00321"></a>00321         <span class="keywordflow">return</span> -1;
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324     <span class="keywordflow">if</span>(lwip_bind(ctx-&gt;sock, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa)))
<a name="l00325"></a>00325     {
<a name="l00326"></a>00326         <a class="code" href="group__logging.html#gaa5595314cc54c304a127c75cfcec4017" title="Output an informative message.">LOG_INFO</a>(<span class="stringliteral">&quot;Error binding socket\n&quot;</span>);
<a name="l00327"></a>00327         <span class="keywordflow">return</span> -1;
<a name="l00328"></a>00328     }
<a name="l00329"></a>00329     <span class="keywordflow">return</span> 0;
<a name="l00330"></a>00330 }
<a name="l00331"></a>00331 
</pre></div></div>
</div>


