

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9fd71c1ac00056e7d855336b2291c56c.html">bertos</a>      </li>
      <li class="navelem"><a class="el" href="dir_5b85ff6a72c79a71106598e13514bf0c.html">mware</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">readline.c File Reference</div>  </div>
</div>
<div class="contents">

<p>Line editing support with history.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="readline_8h_source.html">readline.h</a>&quot;</code><br/>
<code>#include &lt;<a class="el" href="compiler_8h_source.html">cfg/compiler.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="debug_8h_source.html">cfg/debug.h</a>&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
</div>
<p><a href="readline_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a485cf50ff9fc8be940e4ecfce101e378"></a><!-- doxytag: member="readline.c::DEBUG_UNIT_TEST" ref="a485cf50ff9fc8be940e4ecfce101e378" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#a485cf50ff9fc8be940e4ecfce101e378">DEBUG_UNIT_TEST</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable compilation of the unit test code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40e907ebb750cca95829f5fba308b726"></a><!-- doxytag: member="readline.c::DEBUG_DUMP_HISTORY" ref="a40e907ebb750cca95829f5fba308b726" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#a40e907ebb750cca95829f5fba308b726">DEBUG_DUMP_HISTORY</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable dump of the history after each line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#aa32da2f19c37f413ab7bf3d4338eaac6">IS_WORD_SEPARATOR</a>(c)&#160;&#160;&#160;((c) == ' ' || (c) == '\0')</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <em>c</em> is a separator between words.  <a href="#aa32da2f19c37f413ab7bf3d4338eaac6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#a3e83e1ff33cdbf99d34836c043e47340">RL_KEYS</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Special keys (escape sequences converted to a single code) <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae86f7c105d3a57ae40463c3bcb348a7c"></a><!-- doxytag: member="readline.c::rl_puts" ref="ae86f7c105d3a57ae40463c3bcb348a7c" args="(const struct RLContext *ctx, const char *txt)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#ae86f7c105d3a57ae40463c3bcb348a7c">rl_puts</a> (const struct RLContext *ctx, const char *txt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the string <em>txt</em> to the IO output (without any kind of termination) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17ccbaebdc12c1a3916cdda11296b704"></a><!-- doxytag: member="readline.c::rl_putc" ref="a17ccbaebdc12c1a3916cdda11296b704" args="(const struct RLContext *ctx, char ch)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#a17ccbaebdc12c1a3916cdda11296b704">rl_putc</a> (const struct RLContext *ctx, char ch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write character <em>ch</em> to the IO output. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#a52278b23cdbd49540c34c36732a60082">rl_getc</a> (const struct RLContext *ctx, int *ch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a character from the IO into <em>ch</em>.  <a href="#a52278b23cdbd49540c34c36732a60082"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a693126a280d98096c582949776e90ab2"></a><!-- doxytag: member="readline.c::is_history_begin" ref="a693126a280d98096c582949776e90ab2" args="(struct RLContext *ctx, int i)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#a693126a280d98096c582949776e90ab2">is_history_begin</a> (struct RLContext *ctx, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if index <em>i</em> points to the begin of the history. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37ac27c1ed5ec39bfa3d90101c40c049"></a><!-- doxytag: member="readline.c::is_history_end" ref="a37ac27c1ed5ec39bfa3d90101c40c049" args="(struct RLContext *ctx, int i)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#a37ac27c1ed5ec39bfa3d90101c40c049">is_history_end</a> (struct RLContext *ctx, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if index <em>i</em> points to the (exclusive) end of history. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7320769d8660ba6fb2a9e7e4567a604a"></a><!-- doxytag: member="readline.c::is_history_past_end" ref="a7320769d8660ba6fb2a9e7e4567a604a" args="(struct RLContext *ctx, int i)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#a7320769d8660ba6fb2a9e7e4567a604a">is_history_past_end</a> (struct RLContext *ctx, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if index <em>i</em> points to the (exclusive) end of history, or somewhere past the end. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#acb6f5c07b1873b766d296a057951a7ed">insert_chars</a> (struct RLContext *ctx, size_t *curpos, const char *ch, int num_chars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>num_chars</em> characters from <em>ch</em> into the history buffer at the position indicated by <em>curpos</em>.  <a href="#acb6f5c07b1873b766d296a057951a7ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9407c79083bbc38e1342b28e83c5236"></a><!-- doxytag: member="readline.c::insert_char" ref="ae9407c79083bbc38e1342b28e83c5236" args="(struct RLContext *ctx, size_t *curpos, char ch)" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#ae9407c79083bbc38e1342b28e83c5236">insert_char</a> (struct RLContext *ctx, size_t *curpos, char ch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a single character <em>ch</em> into the buffer (with the same semantic of <code><a class="el" href="readline_8c.html#acb6f5c07b1873b766d296a057951a7ed" title="Insert num_chars characters from ch into the history buffer at the position indicated by curpos...">insert_chars()</a></code>) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0bc927b481c4822f0531c9678ebf6c7"></a><!-- doxytag: member="readline.c::complete_word" ref="ab0bc927b481c4822f0531c9678ebf6c7" args="(struct RLContext *ctx, size_t *curpos)" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="readline_8c.html#ab0bc927b481c4822f0531c9678ebf6c7">complete_word</a> (struct RLContext *ctx, size_t *curpos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete the current word. Return false if no unambiguous completion was found. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Line editing support with history. </p>
<p>Rationale for basic implementation choices:</p>
<ul>
<li>The history is implemented storing consecutive ASCIIZ strings within an array of memory. When the history is full, the first (oldest) line is cancelled and the whole buffer is memmoved to overwrite it and make room. while this is is obviously not the fastest algorithm (which would require the use of a circular buffer) it is surely good enough for this module, which does not aim at fast performances (line editing does not require to be blazingly fast).</li>
</ul>
<ul>
<li>The first character in the history is always <code>\0</code>, and it is used as a guard. By 'wasting' it in this way, the code actually gets much simpler in that we remove many checks when moving backward (<code>i&gt;0</code> and similar).</li>
</ul>
<ul>
<li>While editing, the current index points to the position of the buffer which contains the last character typed in (exactly like a stack pointer). This also allows to simplify calculations and to make easier using the last byte of history.</li>
</ul>
<ul>
<li>While editing, the current line is always kept null-terminated. This is important because if the user press ENTER, we must have room to add a <code>\0</code> to terminate the line. If the line is as long as the whole history buffer, there would not be space for it. By always keeping the <code>\0</code> at the end, we properly ensure this without making index checks harder.</li>
</ul>
<ul>
<li>When removing a line from the history (see <code>pop_history()</code>), instead of updating all the indices we have around, we move backward the pointer to the history we use. This way, we don't have to update anything. This means that we keep two pointers to the history: <code>real_history</code> always points to the physical start, while <code>history</code> is the adjusted pointer (that is dereference to read/write to it).</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Giovanni Bajo &lt;<a href="mailto:rasky@develer.com">rasky@develer.com</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="readline_8c_source.html">readline.c</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="aa32da2f19c37f413ab7bf3d4338eaac6"></a><!-- doxytag: member="readline.c::IS_WORD_SEPARATOR" ref="aa32da2f19c37f413ab7bf3d4338eaac6" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_WORD_SEPARATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;((c) == ' ' || (c) == '\0')</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if <em>c</em> is a separator between words. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Parameter <em>c</em> is evaluated multiple times </dd></dl>

<p>Definition at line <a class="el" href="readline_8c_source.html#l00139">139</a> of file <a class="el" href="readline_8c_source.html">readline.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="acb6f5c07b1873b766d296a057951a7ed"></a><!-- doxytag: member="readline.c::insert_chars" ref="acb6f5c07b1873b766d296a057951a7ed" args="(struct RLContext *ctx, size_t *curpos, const char *ch, int num_chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool insert_chars </td>
          <td>(</td>
          <td class="paramtype">struct RLContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>curpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert <em>num_chars</em> characters from <em>ch</em> into the history buffer at the position indicated by <em>curpos</em>. </p>
<p>If needed, remove old history to make room. Returns true if everything was successful, false if there was no room to add the characters. </p>
<dl class="note"><dt><b>Note:</b></dt><dd><em>num_chars</em> can be 0, in which case we just make sure the line is correctly zero-terminated (ASCIIZ format). </dd></dl>

<p>Definition at line <a class="el" href="readline_8c_source.html#l00270">270</a> of file <a class="el" href="readline_8c_source.html">readline.c</a>.</p>

</div>
</div>
<a class="anchor" id="a52278b23cdbd49540c34c36732a60082"></a><!-- doxytag: member="readline.c::rl_getc" ref="a52278b23cdbd49540c34c36732a60082" args="(const struct RLContext *ctx, int *ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool rl_getc </td>
          <td>(</td>
          <td class="paramtype">const struct RLContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a character from the IO into <em>ch</em>. </p>
<p>This function also takes care of converting the ANSI escape sequences into one of the codes defined in <code>RL_KEYS</code>. </p>

<p>Definition at line <a class="el" href="readline_8c_source.html#l00162">162</a> of file <a class="el" href="readline_8c_source.html">readline.c</a>.</p>

</div>
</div>
</div>


