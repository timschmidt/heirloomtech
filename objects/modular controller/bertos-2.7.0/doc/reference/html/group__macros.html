

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">General purpose macros</div>  </div>
<div class="ingroups"><a class="el" href="group__core.html">BeRTOS core functionality</a></div></div>
<div class="contents">

<p>Common and handy function macros.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga31543af52440ac9068b6b691617944a6"></a><!-- doxytag: member="macros::ALIGN_UP" ref="ga31543af52440ac9068b6b691617944a6" args="(value, align)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga31543af52440ac9068b6b691617944a6">ALIGN_UP</a>(value, align)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <code>value</code> to the next <code>align</code> boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga78bf3bcf1ddef16de76fd74c3669d2fe">MINMAX</a>(min, x, max)&#160;&#160;&#160;(MIN(MAX(min, x), max))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound <em>x</em> between <em>min</em> and <em>max</em>.  <a href="#ga78bf3bcf1ddef16de76fd74c3669d2fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b3faaa52bab8d724d07912876d30eee"></a><!-- doxytag: member="macros::SHUFFLE" ref="ga5b3faaa52bab8d724d07912876d30eee" args="(array, len)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga5b3faaa52bab8d724d07912876d30eee">SHUFFLE</a>(array, len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the content of <em>array</em> that counts <em>len</em> elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga1f2d0d4825f9d715d719726418f1a1a3">SWAP_T</a>(a, b, T)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to swap <em>a</em> with <em>b</em>, with explicit type <em>T</em> for dumb C89 compilers.  <a href="#ga1f2d0d4825f9d715d719726418f1a1a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga72967c75e0aea318bc37e0312a4709fe">REVERSE_UINT8</a>(b)&#160;&#160;&#160;((uint8_t)((((b) * 0x0802UL &amp; 0x22110UL) | ((b) * 0x8020UL &amp; 0x88440UL)) * 0x10101UL &gt;&gt; 16))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the bits contained in b (LSB becomes the MSB and so on).  <a href="#ga72967c75e0aea318bc37e0312a4709fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d">BV</a>(x)&#160;&#160;&#160;(1&lt;&lt;(x))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bit value to a binary flag.  <a href="#ga663d8c125655d41622b1e6bc96e5d63d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb74846f185fce952149504881407d7c"></a><!-- doxytag: member="macros::BV32" ref="gabb74846f185fce952149504881407d7c" args="(x)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#gabb74846f185fce952149504881407d7c">BV32</a>(x)&#160;&#160;&#160;((uint32_t)1&lt;&lt;(x))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV()</a> but with 32 bit result. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ff94c42974df549c5497fb5d43a350c"></a><!-- doxytag: member="macros::BV16" ref="ga4ff94c42974df549c5497fb5d43a350c" args="(x)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga4ff94c42974df549c5497fb5d43a350c">BV16</a>(x)&#160;&#160;&#160;((uint16_t)1&lt;&lt;(x))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV()</a> but with 16 bit result. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa9d28d9d4dfdcdfa9f313bf395cd4c85"></a><!-- doxytag: member="macros::BV8" ref="gaa9d28d9d4dfdcdfa9f313bf395cd4c85" args="(x)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#gaa9d28d9d4dfdcdfa9f313bf395cd4c85">BV8</a>(x)&#160;&#160;&#160;((uint8_t)1&lt;&lt;(x))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV()</a> but with 8 bit result. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga1ddec5826f8a1f9010183107bb77c06d">DIV_ROUND</a>(dividend, divisor)&#160;&#160;&#160;(((dividend) + (divisor) / 2) / (divisor))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an integer division rounding the result to the nearest int value.  <a href="#ga1ddec5826f8a1f9010183107bb77c06d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga51077bdff86718802d118c5e3e4edf24">DIV_ROUNDUP</a>(dividend, divisor)&#160;&#160;&#160;(((dividend) + (divisor) - 1) / (divisor))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an integer division rounding the result to the upper int value.  <a href="#ga51077bdff86718802d118c5e3e4edf24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga16bc6c98497e5a9963cb2a59d80f2dc8">INT_MULT</a>(a, f, prec)&#160;&#160;&#160;(((a) * (long)((f) * (1 &lt;&lt; (prec)) + 0.5)) &gt;&gt; (prec))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a multiply between the integer <em>a</em> and the float constant <em>f</em>.  <a href="#ga16bc6c98497e5a9963cb2a59d80f2dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga55934d910abbf7e49f0a0828a024920c">ROUND_UP2</a>(x, pad)&#160;&#160;&#160;(((x) + ((pad) - 1)) &amp; ~((pad) - 1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up <em>x</em> to an even multiple of the 2's power <em>pad</em>.  <a href="#ga55934d910abbf7e49f0a0828a024920c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#gafd922d5a863aa3844c5390af42d97638">IS_POW2</a>(x)&#160;&#160;&#160;(!(bool)((x) &amp; ((x)-1)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <em>x</em> is an integer power of 2.  <a href="#gafd922d5a863aa3844c5390af42d97638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66165e0ad2a8eea89e026c82800a1390"></a><!-- doxytag: member="macros::UINT8_LOG2" ref="ga66165e0ad2a8eea89e026c82800a1390" args="(x)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga66165e0ad2a8eea89e026c82800a1390">UINT8_LOG2</a>(x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a compile-time log2 for a uint8_t. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab053af8124b2e53bcf16a7c6797a0964"></a><!-- doxytag: member="macros::UINT16_LOG2" ref="gab053af8124b2e53bcf16a7c6797a0964" args="(x)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#gab053af8124b2e53bcf16a7c6797a0964">UINT16_LOG2</a>(x)&#160;&#160;&#160;((x &lt; 256) ? UINT8_LOG2(x) : UINT8_LOG2((x) &gt;&gt; 8) + 8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a compile-time log2 for a uint16_t. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d9caa30fffe7e2d220668afb5e310a5"></a><!-- doxytag: member="macros::UINT32_LOG2" ref="ga6d9caa30fffe7e2d220668afb5e310a5" args="(x)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga6d9caa30fffe7e2d220668afb5e310a5">UINT32_LOG2</a>(x)&#160;&#160;&#160;((x &lt; 65536UL) ? UINT16_LOG2(x) : UINT16_LOG2((x) &gt;&gt; 16) + 16)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a compile-time log2 for a uint32_t. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga9b70059bfe852c77e9156f3608a9b859">PP_COUNT</a>(...)&#160;&#160;&#160;PP_COUNT__(__VA_ARGS__,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of arguments (up to 16).  <a href="#ga9b70059bfe852c77e9156f3608a9b859"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga19bb8506799c1c5dba9287bd7ccf498b">BIT_CHANGE</a>(reg,...)&#160;&#160;&#160;BIT_CHANGE__(reg, 0, __VA_ARGS__)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro allows for efficient and compact bit toggling in a hardware register.  <a href="#ga19bb8506799c1c5dba9287bd7ccf498b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga11693cb11b2396de38b5747c1a0b621d"></a><!-- doxytag: member="macros::BIT_CHANGE_BV" ref="ga11693cb11b2396de38b5747c1a0b621d" args="(reg,...)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga11693cb11b2396de38b5747c1a0b621d">BIT_CHANGE_BV</a>(reg,...)&#160;&#160;&#160;BIT_CHANGE__(reg, 1, __VA_ARGS__)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__macros.html#ga19bb8506799c1c5dba9287bd7ccf498b" title="This macro allows for efficient and compact bit toggling in a hardware register.">BIT_CHANGE()</a>, but get bits instead of masks (and applies <a class="el" href="group__macros.html#ga663d8c125655d41622b1e6bc96e5d63d" title="Convert a bit value to a binary flag.">BV()</a> to convert them to masks). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga648d090bf791904e2b6fe26e058275a2"></a><!-- doxytag: member="macros::MAKE_ID" ref="ga648d090bf791904e2b6fe26e058275a2" args="(a, b, c, d)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga648d090bf791904e2b6fe26e058275a2">MAKE_ID</a>(a, b, c, d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an id from 4 letters, useful for file formats and kfile ids. <br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga513ee83176411bfc889c87bff2f5b6e4"></a><!-- doxytag: member="macros::id_t" ref="ga513ee83176411bfc889c87bff2f5b6e4" args="" -->
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga513ee83176411bfc889c87bff2f5b6e4">id_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for id generated by <a class="el" href="group__macros.html#ga648d090bf791904e2b6fe26e058275a2" title="Make an id from 4 letters, useful for file formats and kfile ids.">MAKE_ID()</a>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4550a2efeccf177fe13cad3c53b9d9a4"></a><!-- doxytag: member="macros::is_aligned" ref="ga4550a2efeccf177fe13cad3c53b9d9a4" args="(const void *addr, size_t size)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga4550a2efeccf177fe13cad3c53b9d9a4">is_aligned</a> (const void *addr, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a pointer is aligned to a certain power-of-2 size. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Integer round macros.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2fb6ab9c47783c49d7bddea4fc39f07e"></a>Round <em>x</em> to a multiple of <em>base</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>x</em> is signed these macros generate a lot of code. </dd></dl>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga675687f382f933cabb294a858697c770"></a><!-- doxytag: member="macros::ROUND_DOWN" ref="ga675687f382f933cabb294a858697c770" args="(x, base)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROUND_DOWN</b>(x, base)&#160;&#160;&#160;( (x) - ((x) % (base)) )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf33272ea57675a9656791b9703511c7e"></a><!-- doxytag: member="macros::ROUND_UP" ref="gaf33272ea57675a9656791b9703511c7e" args="(x, base)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROUND_UP</b>(x, base)&#160;&#160;&#160;( ((x) + (base) - 1) - (((x) + (base) - 1) % (base)) )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4391b414ee666d481fad525138b37ec0"></a><!-- doxytag: member="macros::ROUND_NEAREST" ref="ga4391b414ee666d481fad525138b37ec0" args="(x, base)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROUND_NEAREST</b>(x, base)&#160;&#160;&#160;( ((x) + (base) / 2) - (((x) + (base) / 2) % (base)) )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad14c19eb02ca88957d5dca2d84681cc6"></a><!-- doxytag: member="macros::ROTR" ref="gad14c19eb02ca88957d5dca2d84681cc6" args="(var, rot)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#gad14c19eb02ca88957d5dca2d84681cc6">ROTR</a>(var, rot)&#160;&#160;&#160;(((var) &gt;&gt; (rot)) | ((var) &lt;&lt; ((sizeof(var) * 8) - (rot))))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for rotating bit left or right. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6048cbe6fa55af3dd748a1bb208b556e"></a><!-- doxytag: member="macros::ROTL" ref="ga6048cbe6fa55af3dd748a1bb208b556e" args="(var, rot)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga6048cbe6fa55af3dd748a1bb208b556e">ROTL</a>(var, rot)&#160;&#160;&#160;(((var) &lt;&lt; (rot)) | ((var) &gt;&gt; ((sizeof(var) * 8) - (rot))))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for rotating bit left or right. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Common and handy function macros. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Bernie Innocenti &lt;<a href="mailto:bernie@codewiz.org">bernie@codewiz.org</a>&gt; </dd>
<dd>
Giovanni Bajo &lt;<a href="mailto:rasky@develer.com">rasky@develer.com</a>&gt; </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga19bb8506799c1c5dba9287bd7ccf498b"></a><!-- doxytag: member="macros.h::BIT_CHANGE" ref="ga19bb8506799c1c5dba9287bd7ccf498b" args="(reg,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT_CHANGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;BIT_CHANGE__(reg, 0, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro allows for efficient and compact bit toggling in a hardware register. </p>
<p>It is meant to replace hand-coded cruft which toggles bits in sequence.</p>
<p>It is possible to specify an unlimited pair of (mask, value) parameters. For instance:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> set_timer(<span class="keywordtype">bool</span> start)
 {
     <a class="code" href="group__macros.html#ga19bb8506799c1c5dba9287bd7ccf498b" title="This macro allows for efficient and compact bit toggling in a hardware register.">BIT_CHANGE</a>(REG_CTRL_TIMER,
        (TIMER_MODE, MODE_COUNT),
        (OVL_IRQ, 1),
        (CMP_IRQ, 1),
        (START, start)
     );
 }
</pre></div><p>The macro expansion will be roughly the following:</p>
<div class="fragment"><pre class="fragment"> REG_CTRL_TIMER = (REG_CTRL_TIMER &amp; ~(TIMER_MODE|OVL_IRQ|CMP_IRQ|START)
                  | (MODE_COUNT|OVL_IRQ|CMP_IRQ|(start ? START : 0));
</pre></div><p>It is up to the compiler to produce the optimal code. We checked that GCC produces the best code in most cases. We preferred this expansion over the use of a block with a local variable because CodeWarrior 6.1 was not able to remove completely the allocation of the local from the stack.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This macro is available only in C99 because it makes use of variadic macros. It would be possible to make up an implementation with a slightly different syntax for use with C90 compilers, through Boost Preprocessor. </dd></dl>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00373">373</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga663d8c125655d41622b1e6bc96e5d63d"></a><!-- doxytag: member="macros.h::BV" ref="ga663d8c125655d41622b1e6bc96e5d63d" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(1&lt;&lt;(x))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a bit value to a binary flag. </p>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00174">174</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ddec5826f8a1f9010183107bb77c06d"></a><!-- doxytag: member="macros.h::DIV_ROUND" ref="ga1ddec5826f8a1f9010183107bb77c06d" args="(dividend, divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DIV_ROUND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dividend, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">divisor&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((dividend) + (divisor) / 2) / (divisor))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform an integer division rounding the result to the nearest int value. </p>
<dl class="note"><dt><b>Note:</b></dt><dd><em>divisor</em> should preferibly be a costant, otherwise this macro generates 2 division. Also divisor is evaluated twice. </dd></dl>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00191">191</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga51077bdff86718802d118c5e3e4edf24"></a><!-- doxytag: member="macros.h::DIV_ROUNDUP" ref="ga51077bdff86718802d118c5e3e4edf24" args="(dividend, divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DIV_ROUNDUP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dividend, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">divisor&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((dividend) + (divisor) - 1) / (divisor))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform an integer division rounding the result to the upper int value. </p>
<dl class="note"><dt><b>Note:</b></dt><dd><em>divisor</em> is evaluated twice. </dd></dl>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00197">197</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga16bc6c98497e5a9963cb2a59d80f2dc8"></a><!-- doxytag: member="macros.h::INT_MULT" ref="ga16bc6c98497e5a9963cb2a59d80f2dc8" args="(a, f, prec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_MULT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prec&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((a) * (long)((f) * (1 &lt;&lt; (prec)) + 0.5)) &gt;&gt; (prec))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a multiply between the integer <em>a</em> and the float constant <em>f</em>. </p>
<p>This macro can be used in order to avoid floating point arithmetics in expressions like this: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> a, b;
 a = b * 0.5579652750;
</pre></div><p>This macro rounds the floating point constant to a fraction, usign (2 ^ prec) as the denominator. For instance, with prec = 8, the constant 0.5579652750 will be rounded to: (143 / 256) = 0.55859375 So, the former code will be transformed to: </p>
<div class="fragment"><pre class="fragment"> a = b * 143 / 256;
</pre></div><p>Since the denominator is a power of 2, we rely on the compiler to optimize this to a right shift. So, when you have to multiply an integer by a float constant, this macro will not use the floating point arithmentics. The operation will be converted to a mul + shift, with a huge performance boost.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><em>f</em> MUST be a constant in order gain performance benefits.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer you want to multiply </td></tr>
    <tr><td class="paramname">f</td><td>floating point constant which you want to multply with <em>a</em> </td></tr>
    <tr><td class="paramname">prec</td><td>conversion precision, ranges from 1 to the number of bits in a long. The higher, the better the approximation of the float constant will be. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00232">232</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafd922d5a863aa3844c5390af42d97638"></a><!-- doxytag: member="macros.h::IS_POW2" ref="gafd922d5a863aa3844c5390af42d97638" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_POW2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(!(bool)((x) &amp; ((x)-1)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if <em>x</em> is an integer power of 2. </p>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00251">251</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga78bf3bcf1ddef16de76fd74c3669d2fe"></a><!-- doxytag: member="macros.h::MINMAX" ref="ga78bf3bcf1ddef16de76fd74c3669d2fe" args="(min, x, max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MINMAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">min, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(MIN(MAX(min, x), max))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bound <em>x</em> between <em>min</em> and <em>max</em>. </p>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00107">107</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b70059bfe852c77e9156f3608a9b859"></a><!-- doxytag: member="macros.h::PP_COUNT" ref="ga9b70059bfe852c77e9156f3608a9b859" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PP_COUNT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;PP_COUNT__(__VA_ARGS__,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count the number of arguments (up to 16). </p>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00273">273</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga72967c75e0aea318bc37e0312a4709fe"></a><!-- doxytag: member="macros.h::REVERSE_UINT8" ref="ga72967c75e0aea318bc37e0312a4709fe" args="(b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REVERSE_UINT8</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;((uint8_t)((((b) * 0x0802UL &amp; 0x22110UL) | ((b) * 0x8020UL &amp; 0x88440UL)) * 0x10101UL &gt;&gt; 16))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse the bits contained in b (LSB becomes the MSB and so on). </p>
<dl class="note"><dt><b>Note:</b></dt><dd><em>b</em> is evaluated twice </dd></dl>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00169">169</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga55934d910abbf7e49f0a0828a024920c"></a><!-- doxytag: member="macros.h::ROUND_UP2" ref="ga55934d910abbf7e49f0a0828a024920c" args="(x, pad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ROUND_UP2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pad&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((x) + ((pad) - 1)) &amp; ~((pad) - 1))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Round up <em>x</em> to an even multiple of the 2's power <em>pad</em>. </p>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00236">236</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f2d0d4825f9d715d719726418f1a1a3"></a><!-- doxytag: member="macros.h::SWAP_T" ref="ga1f2d0d4825f9d715d719726418f1a1a3" args="(a, b, T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SWAP_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        T tmp; \
        ASSERT_TYPE_IS(a, T); \
        ASSERT_TYPE_IS(b, T); \
        tmp = (a); \
        (a) = (b); \
        (b) = tmp; \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Macro to swap <em>a</em> with <em>b</em>, with explicit type <em>T</em> for dumb C89 compilers. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Arguments are evaluated multiple times. </dd></dl>

<p>Definition at line <a class="el" href="macros_8h_source.html#l00155">155</a> of file <a class="el" href="macros_8h_source.html">macros.h</a>.</p>

</div>
</div>
</div>


